//! Security Analysis and Threat Detection
//!
//! This module provides real-time security analysis, threat detection,
//! and anomaly identification for network traffic.

use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant};

use parking_lot::RwLock;
use prometheus::{Counter, Gauge, register_counter, register_gauge};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tracing::{debug, error, info, warn, instrument};

use crate::{DpiError, PacketData, SecurityFlag};
use crate::features::PacketFeatures;

/// Security analysis errors
#[derive(Error, Debug)]
pub enum SecurityError {
    #[error("Threat detection failed: {0}")]
    ThreatDetectionFailed(String),
    
    #[error("Anomaly detection failed: {0}")]
    AnomalyDetectionFailed(String),
    
    #[error("Policy validation failed: {0}")]
    PolicyValidationFailed(String),
    
    #[error("Signature matching failed: {0}")]
    SignatureMatchingFailed(String),
}

type Result<T> = std::result::Result<T, SecurityError>;

/// Security event generated by analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityEvent {
    pub event_id: String,
    pub timestamp: u64,
    pub event_type: ThreatType,
    pub severity: ThreatSeverity,
    pub confidence: f32,
    pub source_ip: std::net::IpAddr,
    pub target_ip: Option<std::net::IpAddr>,
    pub source_port: Option<u16>,
    pub target_port: Option<u16>,
    pub description: String,
    pub indicators: Vec<ThreatIndicator>,
    pub mitre_attack_techniques: Vec<String>,
    pub remediation_suggestions: Vec<String>,
    pub false_positive_likelihood: f32,
    pub related_events: Vec<String>,
}

/// Types of security threats
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ThreatType {
    Malware,
    Ransomware,
    Botnet,
    CommandAndControl,
    DataExfiltration,
    Phishing,
    SqlInjection,
    XssAttack,
    PortScan,
    DenialOfService,
    BruteForce,
    PrivilegeEscalation,
    LateralMovement,
    Reconnaissance,
    Persistence,
    DefenseEvasion,
    CredentialAccess,
    Discovery,
    Collection,
    Impact,
    Anomalous,
    PolicyViolation,
    Custom(String),
}

/// Threat severity levels
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum ThreatSeverity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

/// Threat indicators for detailed analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatIndicator {
    pub indicator_type: IndicatorType,
    pub value: String,
    pub confidence: f32,
    pub first_seen: u64,
    pub last_seen: u64,
    pub count: u32,
    pub context: HashMap<String, String>,
}

/// Types of threat indicators
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum IndicatorType {
    IpAddress,
    Domain,
    Url,
    FileHash,
    EmailAddress,
    UserAgent,
    Certificate,
    Ja3Hash,
    Ja3sHash,
    NetworkPattern,
    BehavioralAnomaly,
    Custom(String),
}

/// Main security analyzer
pub struct SecurityAnalyzer {
    config: SecurityConfig,
    threat_detector: Arc<ThreatDetector>,
    anomaly_detector: Arc<AnomalyDetector>,
    policy_engine: Arc<PolicyEngine>,
    intelligence_feeds: Arc<RwLock<ThreatIntelligence>>,
    security_rules: Arc<RwLock<Vec<SecurityRule>>>,
    statistics: Arc<RwLock<SecurityStats>>,
    event_correlation: Arc<EventCorrelator>,
}

/// Security analyzer configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityConfig {
    pub enable_threat_detection: bool,
    pub enable_anomaly_detection: bool,
    pub enable_policy_enforcement: bool,
    pub threat_confidence_threshold: f32,
    pub anomaly_threshold: f32,
    pub max_events_per_second: u32,
    pub correlation_window_seconds: u64,
    pub enable_threat_intelligence: bool,
    pub intelligence_update_interval_minutes: u32,
}

impl Default for SecurityConfig {
    fn default() -> Self {
        Self {
            enable_threat_detection: true,
            enable_anomaly_detection: true,
            enable_policy_enforcement: true,
            threat_confidence_threshold: 0.7,
            anomaly_threshold: 2.0,
            max_events_per_second: 1000,
            correlation_window_seconds: 300,
            enable_threat_intelligence: true,
            intelligence_update_interval_minutes: 60,
        }
    }
}

/// Threat detector for signature-based detection
pub struct ThreatDetector {
    malware_signatures: Vec<MalwareSignature>,
    network_signatures: Vec<NetworkSignature>,
    behavioral_rules: Vec<BehavioralRule>,
    detection_cache: Arc<RwLock<HashMap<u64, DetectionResult>>>,
}

/// Malware signature for detection
#[derive(Debug, Clone)]
pub struct MalwareSignature {
    pub id: String,
    pub family: String,
    pub pattern: Vec<u8>,
    pub offset: Option<usize>,
    pub confidence: f32,
    pub metadata: HashMap<String, String>,
}

/// Network-based signature
#[derive(Debug, Clone)]
pub struct NetworkSignature {
    pub id: String,
    pub name: String,
    pub pattern: String,
    pub protocol: Option<String>,
    pub direction: TrafficDirection,
    pub confidence: f32,
}

/// Traffic direction for signatures
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TrafficDirection {
    Inbound,
    Outbound,
    Bidirectional,
}

/// Behavioral detection rule
#[derive(Debug, Clone)]
pub struct BehavioralRule {
    pub id: String,
    pub name: String,
    pub conditions: Vec<BehavioralCondition>,
    pub threat_type: ThreatType,
    pub confidence: f32,
    pub time_window: Duration,
}

/// Behavioral condition for rules
#[derive(Debug, Clone)]
pub struct BehavioralCondition {
    pub metric: String,
    pub operator: ComparisonOperator,
    pub threshold: f64,
    pub aggregation: AggregationType,
}

/// Comparison operators for conditions
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ComparisonOperator {
    GreaterThan,
    LessThan,
    Equals,
    NotEquals,
    Contains,
    StartsWith,
    EndsWith,
}

/// Aggregation types for behavioral analysis
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AggregationType {
    Count,
    Sum,
    Average,
    Maximum,
    Minimum,
    StandardDeviation,
    Percentile(u8),
}

/// Detection result
#[derive(Debug, Clone)]
pub struct DetectionResult {
    pub detected: bool,
    pub threat_type: Option<ThreatType>,
    pub confidence: f32,
    pub signatures_matched: Vec<String>,
    pub anomaly_score: f32,
}

/// Anomaly detector for statistical analysis
pub struct AnomalyDetector {
    baseline_models: HashMap<String, BaselineModel>,
    anomaly_algorithms: Vec<Box<dyn AnomalyAlgorithm + Send + Sync>>,
    detection_threshold: f64,
}

/// Baseline model for normal behavior
#[derive(Debug, Clone)]
pub struct BaselineModel {
    pub metric_name: String,
    pub mean: f64,
    pub std_deviation: f64,
    pub min_value: f64,
    pub max_value: f64,
    pub sample_count: u64,
    pub last_updated: Instant,
}

/// Trait for anomaly detection algorithms
pub trait AnomalyAlgorithm: Send + Sync {
    fn detect(&self, data: &[f64], baseline: &BaselineModel) -> f64;
    fn name(&self) -> &str;
}

/// Policy enforcement engine
pub struct PolicyEngine {
    policies: Vec<SecurityPolicy>,
    policy_cache: Arc<RwLock<HashMap<String, PolicyDecision>>>,
}

/// Security policy definition
#[derive(Debug, Clone)]
pub struct SecurityPolicy {
    pub id: String,
    pub name: String,
    pub rules: Vec<PolicyRule>,
    pub action: PolicyAction,
    pub priority: u32,
    pub enabled: bool,
}

/// Policy rule condition
#[derive(Debug, Clone)]
pub struct PolicyRule {
    pub field: String,
    pub operator: ComparisonOperator,
    pub value: String,
    pub negate: bool,
}

/// Policy enforcement actions
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PolicyAction {
    Allow,
    Block,
    Monitor,
    Quarantine,
    Alert,
    Redirect(String),
}

/// Policy decision result
#[derive(Debug, Clone)]
pub struct PolicyDecision {
    pub allowed: bool,
    pub action: PolicyAction,
    pub policy_id: String,
    pub reason: String,
}

/// Threat intelligence feeds
pub struct ThreatIntelligence {
    pub malicious_ips: HashMap<std::net::IpAddr, ThreatInfo>,
    pub malicious_domains: HashMap<String, ThreatInfo>,
    pub malicious_urls: HashMap<String, ThreatInfo>,
    pub file_hashes: HashMap<String, ThreatInfo>,
    pub last_updated: Instant,
}

/// Threat information from intelligence feeds
#[derive(Debug, Clone)]
pub struct ThreatInfo {
    pub threat_type: ThreatType,
    pub confidence: f32,
    pub first_seen: Instant,
    pub last_seen: Instant,
    pub source: String,
    pub description: String,
    pub tags: Vec<String>,
}

/// Security rule for threat detection
#[derive(Debug, Clone)]
pub struct SecurityRule {
    pub id: String,
    pub name: String,
    pub description: String,
    pub pattern: String,
    pub threat_type: ThreatType,
    pub severity: ThreatSeverity,
    pub enabled: bool,
    pub false_positive_rate: f32,
}

/// Event correlator for linking related events
pub struct EventCorrelator {
    correlation_rules: Vec<CorrelationRule>,
    event_buffer: Arc<RwLock<Vec<SecurityEvent>>>,
    correlation_cache: Arc<RwLock<HashMap<String, Vec<String>>>>,
}

/// Correlation rule for event linking
#[derive(Debug, Clone)]
pub struct CorrelationRule {
    pub id: String,
    pub name: String,
    pub conditions: Vec<CorrelationCondition>,
    pub time_window: Duration,
    pub threshold: u32,
    pub output_event_type: ThreatType,
}

/// Correlation condition
#[derive(Debug, Clone)]
pub struct CorrelationCondition {
    pub field: String,
    pub operation: CorrelationOperation,
    pub value: String,
}

/// Correlation operations
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CorrelationOperation {
    Equals,
    Contains,
    SameSource,
    SameTarget,
    TimeProximity,
    Count,
}

/// Security analysis statistics
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct SecurityStats {
    pub total_packets_analyzed: u64,
    pub threats_detected: u64,
    pub anomalies_detected: u64,
    pub policy_violations: u64,
    pub false_positives: u64,
    pub events_correlated: u64,
    pub average_analysis_time_us: f64,
    pub threat_types_distribution: HashMap<String, u64>,
}

// Prometheus metrics
lazy_static::lazy_static! {
    static ref THREATS_DETECTED: Counter = register_counter!(
        "dpi_threats_detected_total",
        "Total number of threats detected"
    ).unwrap();
    
    static ref SECURITY_EVENTS: Counter = register_counter!(
        "dpi_security_events_total",
        "Total number of security events generated"
    ).unwrap();
    
    static ref ANOMALY_SCORE: Gauge = register_gauge!(
        "dpi_anomaly_score",
        "Current anomaly score"
    ).unwrap();
}

impl SecurityAnalyzer {
    /// Create a new security analyzer
    #[instrument(skip(config))]
    pub fn new(config: &crate::config::DpiConfig) -> Result<Self> {
        info!("Initializing Security Analyzer");
        
        let security_config = SecurityConfig::default();
        
        // Initialize threat detector
        let threat_detector = Arc::new(ThreatDetector::new()?);
        
        // Initialize anomaly detector
        let anomaly_detector = Arc::new(AnomalyDetector::new()?);
        
        // Initialize policy engine
        let policy_engine = Arc::new(PolicyEngine::new()?);
        
        // Initialize threat intelligence
        let intelligence_feeds = Arc::new(RwLock::new(ThreatIntelligence::new()));
        
        // Initialize event correlator
        let event_correlator = Arc::new(EventCorrelator::new()?);
        
        let analyzer = Self {
            config: security_config,
            threat_detector,
            anomaly_detector,
            policy_engine,
            intelligence_feeds,
            security_rules: Arc::new(RwLock::new(Vec::new())),
            statistics: Arc::new(RwLock::new(SecurityStats::default())),
            event_correlation: event_correlator,
        };
        
        info!("Security Analyzer initialized successfully");
        Ok(analyzer)
    }
    
    /// Analyze packet for security threats
    #[instrument(skip(self, packet_data, features))]
    pub async fn analyze_packet(
        &self,
        packet_data: &PacketData,
        features: &PacketFeatures,
    ) -> Result<Vec<SecurityFlag>> {
        let start_time = Instant::now();
        let mut security_flags = Vec::new();
        
        // Threat detection
        if self.config.enable_threat_detection {
            if let Ok(detection_result) = self.threat_detector.detect_threats(packet_data, features).await {
                if detection_result.detected && detection_result.confidence >= self.config.threat_confidence_threshold {
                    security_flags.push(SecurityFlag::Malicious);
                    
                    // Generate security event
                    let event = SecurityEvent {
                        event_id: format!("threat_{}", uuid::Uuid::new_v4()),
                        timestamp: packet_data.timestamp.elapsed().as_millis() as u64,
                        event_type: detection_result.threat_type.unwrap_or(ThreatType::Anomalous),
                        severity: ThreatSeverity::High,
                        confidence: detection_result.confidence,
                        source_ip: packet_data.src_ip,
                        target_ip: Some(packet_data.dst_ip),
                        source_port: Some(packet_data.src_port),
                        target_port: Some(packet_data.dst_port),
                        description: "Threat signature matched".to_string(),
                        indicators: Vec::new(),
                        mitre_attack_techniques: Vec::new(),
                        remediation_suggestions: Vec::new(),
                        false_positive_likelihood: 0.1,
                        related_events: Vec::new(),
                    };
                    
                    // Update statistics
                    THREATS_DETECTED.inc();
                    SECURITY_EVENTS.inc();
                }
            }
        }
        
        // Anomaly detection
        if self.config.enable_anomaly_detection {
            if let Ok(anomaly_score) = self.anomaly_detector.detect_anomalies(features).await {
                if anomaly_score > self.config.anomaly_threshold as f64 {
                    security_flags.push(SecurityFlag::Anomalous);
                    ANOMALY_SCORE.set(anomaly_score);
                }
            }
        }
        
        // Policy enforcement
        if self.config.enable_policy_enforcement {
            if let Ok(policy_decision) = self.policy_engine.evaluate_policies(packet_data, features).await {
                if !policy_decision.allowed {
                    security_flags.push(SecurityFlag::PolicyViolation);
                }
            }
        }
        
        // Check threat intelligence
        if self.config.enable_threat_intelligence {
            let intelligence = self.intelligence_feeds.read();
            if intelligence.malicious_ips.contains_key(&packet_data.src_ip) ||
               intelligence.malicious_ips.contains_key(&packet_data.dst_ip) {
                security_flags.push(SecurityFlag::Malicious);
            }
        }
        
        // Update statistics
        let analysis_time = start_time.elapsed().as_micros() as f64;
        let mut stats = self.statistics.write();
        stats.total_packets_analyzed += 1;
        stats.average_analysis_time_us = 
            (stats.average_analysis_time_us * (stats.total_packets_analyzed - 1) as f64 + analysis_time) /
            stats.total_packets_analyzed as f64;
        
        if !security_flags.is_empty() {
            stats.threats_detected += 1;
        }
        
        debug!("Security analysis completed in {:.2}Î¼s with {} flags", analysis_time, security_flags.len());
        Ok(security_flags)
    }
    
    /// Get security analysis statistics
    pub fn get_statistics(&self) -> SecurityStats {
        self.statistics.read().clone()
    }
    
    /// Update threat intelligence feeds
    pub async fn update_threat_intelligence(&self) -> Result<()> {
        info!("Updating threat intelligence feeds");
        
        // This would fetch from external threat intelligence sources
        // For now, just update the timestamp
        let mut intelligence = self.intelligence_feeds.write();
        intelligence.last_updated = Instant::now();
        
        info!("Threat intelligence updated successfully");
        Ok(())
    }
    
    /// Add custom security rule
    pub fn add_security_rule(&self, rule: SecurityRule) {
        let mut rules = self.security_rules.write();
        rules.push(rule);
        info!("Added new security rule: {}", rules.last().unwrap().name);
    }
}

impl ThreatDetector {
    fn new() -> Result<Self> {
        Ok(Self {
            malware_signatures: Self::load_malware_signatures(),
            network_signatures: Self::load_network_signatures(),
            behavioral_rules: Self::load_behavioral_rules(),
            detection_cache: Arc::new(RwLock::new(HashMap::new())),
        })
    }
    
    async fn detect_threats(&self, packet_data: &PacketData, features: &PacketFeatures) -> Result<DetectionResult> {
        // Check cache first
        let cache_key = self.calculate_cache_key(packet_data, features);
        if let Some(cached_result) = self.detection_cache.read().get(&cache_key) {
            return Ok(cached_result.clone());
        }
        
        let mut result = DetectionResult {
            detected: false,
            threat_type: None,
            confidence: 0.0,
            signatures_matched: Vec::new(),
            anomaly_score: 0.0,
        };
        
        // Check malware signatures
        for signature in &self.malware_signatures {
            if self.match_malware_signature(signature, &packet_data.data) {
                result.detected = true;
                result.threat_type = Some(ThreatType::Malware);
                result.confidence = signature.confidence;
                result.signatures_matched.push(signature.id.clone());
                break;
            }
        }
        
        // Cache the result
        self.detection_cache.write().insert(cache_key, result.clone());
        
        Ok(result)
    }
    
    fn calculate_cache_key(&self, packet_data: &PacketData, features: &PacketFeatures) -> u64 {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        packet_data.src_ip.hash(&mut hasher);
        packet_data.dst_ip.hash(&mut hasher);
        features.packet_size.hash(&mut hasher);
        hasher.finish()
    }
    
    fn match_malware_signature(&self, _signature: &MalwareSignature, _data: &bytes::Bytes) -> bool {
        // Simplified signature matching
        false
    }
    
    fn load_malware_signatures() -> Vec<MalwareSignature> {
        Vec::new() // Placeholder
    }
    
    fn load_network_signatures() -> Vec<NetworkSignature> {
        Vec::new() // Placeholder
    }
    
    fn load_behavioral_rules() -> Vec<BehavioralRule> {
        Vec::new() // Placeholder
    }
}

impl AnomalyDetector {
    fn new() -> Result<Self> {
        Ok(Self {
            baseline_models: HashMap::new(),
            anomaly_algorithms: Vec::new(),
            detection_threshold: 2.0,
        })
    }
    
    async fn detect_anomalies(&self, _features: &PacketFeatures) -> Result<f64> {
        // Simplified anomaly detection
        Ok(0.5)
    }
}

impl PolicyEngine {
    fn new() -> Result<Self> {
        Ok(Self {
            policies: Self::load_default_policies(),
            policy_cache: Arc::new(RwLock::new(HashMap::new())),
        })
    }
    
    async fn evaluate_policies(&self, _packet_data: &PacketData, _features: &PacketFeatures) -> Result<PolicyDecision> {
        // Simplified policy evaluation
        Ok(PolicyDecision {
            allowed: true,
            action: PolicyAction::Allow,
            policy_id: "default".to_string(),
            reason: "No matching policies".to_string(),
        })
    }
    
    fn load_default_policies() -> Vec<SecurityPolicy> {
        Vec::new() // Placeholder
    }
}

impl ThreatIntelligence {
    fn new() -> Self {
        Self {
            malicious_ips: HashMap::new(),
            malicious_domains: HashMap::new(),
            malicious_urls: HashMap::new(),
            file_hashes: HashMap::new(),
            last_updated: Instant::now(),
        }
    }
}

impl EventCorrelator {
    fn new() -> Result<Self> {
        Ok(Self {
            correlation_rules: Vec::new(),
            event_buffer: Arc::new(RwLock::new(Vec::new())),
            correlation_cache: Arc::new(RwLock::new(HashMap::new())),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::features::PacketFeatures;
    use std::net::{IpAddr, Ipv4Addr};
    use bytes::Bytes;
    
    #[test]
    fn test_security_analyzer_creation() {
        let config = crate::config::DpiConfig::default();
        let result = SecurityAnalyzer::new(&config);
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_threat_severity_ordering() {
        assert!(ThreatSeverity::Critical > ThreatSeverity::High);
        assert!(ThreatSeverity::High > ThreatSeverity::Medium);
        assert!(ThreatSeverity::Medium > ThreatSeverity::Low);
        assert!(ThreatSeverity::Low > ThreatSeverity::Info);
    }
    
    #[test]
    fn test_security_event_creation() {
        let event = SecurityEvent {
            event_id: "test_event".to_string(),
            timestamp: 1234567890,
            event_type: ThreatType::Malware,
            severity: ThreatSeverity::High,
            confidence: 0.9,
            source_ip: IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100)),
            target_ip: Some(IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1))),
            source_port: Some(12345),
            target_port: Some(80),
            description: "Test malware detected".to_string(),
            indicators: Vec::new(),
            mitre_attack_techniques: Vec::new(),
            remediation_suggestions: Vec::new(),
            false_positive_likelihood: 0.1,
            related_events: Vec::new(),
        };
        
        assert_eq!(event.event_type, ThreatType::Malware);
        assert_eq!(event.severity, ThreatSeverity::High);
        assert_eq!(event.confidence, 0.9);
    }
}
{
  "metadata": {
    "title": "IBM MQ Series Message Format Patterns",
    "version": "1.0.0",
    "description": "Comprehensive MQ message patterns with modern equivalents (RabbitMQ, Kafka, AWS SQS)",
    "total_patterns": 45
  },
  "mq_patterns": [
    {
      "id": "MQ001",
      "category": "basic_messaging",
      "name": "Point-to-Point Message Send",
      "description": "Basic MQPUT operation to send a message to a queue",
      "cobol_mq": "       WORKING-STORAGE SECTION.\n           COPY CMQV.\n       01  WS-HCONN           PIC S9(9) BINARY.\n       01  WS-HOBJ            PIC S9(9) BINARY.\n       01  WS-OPTIONS         PIC S9(9) BINARY.\n       01  WS-COMPCODE        PIC S9(9) BINARY.\n       01  WS-REASON          PIC S9(9) BINARY.\n       01  WS-MQOD.\n           COPY CMQODV.\n       01  WS-MQMD.\n           COPY CMQMDV.\n       01  WS-MQPMO.\n           COPY CMQPMOV.\n       01  WS-MSG-LEN         PIC S9(9) BINARY.\n       01  WS-MESSAGE         PIC X(1000).\n       \n       PROCEDURE DIVISION.\n           MOVE 'MYQUEUE' TO MQOD-OBJECTNAME\n           MOVE MQOO-OUTPUT TO WS-OPTIONS\n           \n           CALL 'MQOPEN' USING WS-HCONN\n                               WS-MQOD\n                               WS-OPTIONS\n                               WS-HOBJ\n                               WS-COMPCODE\n                               WS-REASON\n           \n           IF WS-COMPCODE = MQCC-OK\n               MOVE MQMT-DATAGRAM TO MQMD-MSGTYPE\n               MOVE MQPMO-NEW-MSG-ID TO MQPMO-OPTIONS\n               MOVE 1000 TO WS-MSG-LEN\n               MOVE 'Hello MQ World' TO WS-MESSAGE\n               \n               CALL 'MQPUT' USING WS-HCONN\n                                  WS-HOBJ\n                                  WS-MQMD\n                                  WS-MQPMO\n                                  WS-MSG-LEN\n                                  WS-MESSAGE\n                                  WS-COMPCODE\n                                  WS-REASON\n           END-IF\n           \n           CALL 'MQCLOSE' USING WS-HCONN\n                                WS-HOBJ\n                                MQCO-NONE\n                                WS-COMPCODE\n                                WS-REASON.",
      "java_jms": "import javax.jms.*;\nimport com.ibm.mq.jms.*;\n\npublic class MQSender {\n    private MQQueueConnectionFactory factory;\n    \n    public void sendMessage(String queueName, String messageText) \n            throws JMSException {\n        \n        try (QueueConnection connection = factory.createQueueConnection();\n             QueueSession session = connection.createQueueSession(\n                 false, Session.AUTO_ACKNOWLEDGE)) {\n            \n            Queue queue = session.createQueue(queueName);\n            QueueSender sender = session.createSender(queue);\n            \n            TextMessage message = session.createTextMessage(messageText);\n            message.setJMSDeliveryMode(DeliveryMode.PERSISTENT);\n            \n            sender.send(message);\n        }\n    }\n}",
      "python_pika": "import pika\nfrom typing import Optional\n\nclass MessageSender:\n    def __init__(self, host: str = 'localhost'):\n        self.connection = pika.BlockingConnection(\n            pika.ConnectionParameters(host=host)\n        )\n        self.channel = self.connection.channel()\n    \n    def send_message(self, queue_name: str, message: str) -> None:\n        self.channel.queue_declare(queue=queue_name, durable=True)\n        \n        self.channel.basic_publish(\n            exchange='',\n            routing_key=queue_name,\n            body=message,\n            properties=pika.BasicProperties(\n                delivery_mode=2  # Persistent\n            )\n        )\n    \n    def close(self) -> None:\n        self.connection.close()",
      "spring_amqp": "@Service\npublic class MessageSender {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n    \n    public void sendMessage(String queueName, String message) {\n        rabbitTemplate.convertAndSend(queueName, message);\n    }\n}"
    },
    {
      "id": "MQ002",
      "category": "basic_messaging",
      "name": "Point-to-Point Message Receive",
      "description": "Basic MQGET operation to receive a message from a queue",
      "cobol_mq": "       WORKING-STORAGE SECTION.\n       01  WS-MQGMO.\n           COPY CMQGMOV.\n       01  WS-BUFFER          PIC X(10000).\n       01  WS-BUFFER-LEN      PIC S9(9) BINARY VALUE 10000.\n       01  WS-DATA-LEN        PIC S9(9) BINARY.\n       \n       PROCEDURE DIVISION.\n       RECEIVE-MESSAGE.\n           MOVE MQGMO-WAIT TO MQGMO-OPTIONS\n           ADD MQGMO-ACCEPT-TRUNCATED-MSG TO MQGMO-OPTIONS\n           MOVE 30000 TO MQGMO-WAITINTERVAL\n           \n           CALL 'MQGET' USING WS-HCONN\n                              WS-HOBJ\n                              WS-MQMD\n                              WS-MQGMO\n                              WS-BUFFER-LEN\n                              WS-BUFFER\n                              WS-DATA-LEN\n                              WS-COMPCODE\n                              WS-REASON\n           \n           EVALUATE TRUE\n               WHEN WS-COMPCODE = MQCC-OK\n                   PERFORM PROCESS-MESSAGE\n               WHEN WS-REASON = MQRC-NO-MSG-AVAILABLE\n                   DISPLAY 'No message available'\n               WHEN OTHER\n                   DISPLAY 'MQ Error: ' WS-REASON\n           END-EVALUATE.",
      "java_jms": "import javax.jms.*;\n\npublic class MQReceiver {\n    \n    public String receiveMessage(String queueName, long timeoutMs) \n            throws JMSException {\n        \n        try (QueueConnection connection = factory.createQueueConnection();\n             QueueSession session = connection.createQueueSession(\n                 false, Session.AUTO_ACKNOWLEDGE)) {\n            \n            connection.start();\n            Queue queue = session.createQueue(queueName);\n            QueueReceiver receiver = session.createReceiver(queue);\n            \n            Message message = receiver.receive(timeoutMs);\n            \n            if (message == null) {\n                return null;  // Timeout, no message\n            }\n            \n            if (message instanceof TextMessage) {\n                return ((TextMessage) message).getText();\n            }\n            \n            return message.toString();\n        }\n    }\n    \n    // Async message listener\n    public void startListener(String queueName, MessageListener listener) \n            throws JMSException {\n        \n        QueueConnection connection = factory.createQueueConnection();\n        QueueSession session = connection.createQueueSession(\n            false, Session.AUTO_ACKNOWLEDGE);\n        \n        Queue queue = session.createQueue(queueName);\n        QueueReceiver receiver = session.createReceiver(queue);\n        receiver.setMessageListener(listener);\n        \n        connection.start();\n    }\n}",
      "python_pika": "import pika\nfrom typing import Callable, Optional\n\nclass MessageReceiver:\n    def __init__(self, host: str = 'localhost'):\n        self.connection = pika.BlockingConnection(\n            pika.ConnectionParameters(host=host)\n        )\n        self.channel = self.connection.channel()\n    \n    def receive_message(\n        self, \n        queue_name: str, \n        timeout_sec: int = 30\n    ) -> Optional[str]:\n        \"\"\"Receive a single message with timeout.\"\"\"\n        self.channel.queue_declare(queue=queue_name, durable=True)\n        \n        method, properties, body = self.channel.basic_get(\n            queue=queue_name,\n            auto_ack=True\n        )\n        \n        if method:\n            return body.decode('utf-8')\n        return None\n    \n    def start_consumer(\n        self,\n        queue_name: str,\n        callback: Callable[[str], None]\n    ) -> None:\n        \"\"\"Start async consumer.\"\"\"\n        self.channel.queue_declare(queue=queue_name, durable=True)\n        \n        def on_message(ch, method, properties, body):\n            callback(body.decode('utf-8'))\n            ch.basic_ack(delivery_tag=method.delivery_tag)\n        \n        self.channel.basic_consume(\n            queue=queue_name,\n            on_message_callback=on_message\n        )\n        \n        self.channel.start_consuming()",
      "spring_amqp": "@Component\npublic class MessageReceiver {\n    \n    @RabbitListener(queues = \"${queue.name}\")\n    public void receiveMessage(String message) {\n        processMessage(message);\n    }\n    \n    private void processMessage(String message) {\n        // Process the message\n    }\n}"
    },
    {
      "id": "MQ003",
      "category": "request_reply",
      "name": "Request-Reply Pattern",
      "description": "Synchronous request-reply messaging pattern",
      "cobol_mq": "       WORKING-STORAGE SECTION.\n       01  WS-REPLY-QUEUE     PIC X(48) VALUE 'REPLY.QUEUE'.\n       01  WS-CORREL-ID       PIC X(24).\n       \n       PROCEDURE DIVISION.\n       SEND-REQUEST.\n           MOVE MQMT-REQUEST TO MQMD-MSGTYPE\n           MOVE WS-REPLY-QUEUE TO MQMD-REPLYTOQ\n           MOVE MQPMO-NEW-MSG-ID TO MQPMO-OPTIONS\n           \n           CALL 'MQPUT' USING WS-HCONN\n                              WS-HOBJ-REQUEST\n                              WS-MQMD\n                              WS-MQPMO\n                              WS-MSG-LEN\n                              WS-REQUEST-MSG\n                              WS-COMPCODE\n                              WS-REASON\n           \n           IF WS-COMPCODE = MQCC-OK\n               MOVE MQMD-MSGID TO WS-CORREL-ID\n               PERFORM RECEIVE-REPLY\n           END-IF.\n       \n       RECEIVE-REPLY.\n           MOVE MQMO-MATCH-CORREL-ID TO MQGMO-MATCHOPTIONS\n           MOVE WS-CORREL-ID TO MQMD-CORRELID\n           MOVE MQGMO-WAIT TO MQGMO-OPTIONS\n           MOVE 60000 TO MQGMO-WAITINTERVAL\n           \n           CALL 'MQGET' USING WS-HCONN\n                              WS-HOBJ-REPLY\n                              WS-MQMD\n                              WS-MQGMO\n                              WS-BUFFER-LEN\n                              WS-REPLY-MSG\n                              WS-DATA-LEN\n                              WS-COMPCODE\n                              WS-REASON.",
      "java_jms": "import javax.jms.*;\nimport java.util.UUID;\n\npublic class RequestReplyClient {\n    \n    public String sendRequest(String requestQueue, String replyQueue, \n            String request, long timeoutMs) throws JMSException {\n        \n        try (QueueConnection connection = factory.createQueueConnection();\n             QueueSession session = connection.createQueueSession(\n                 false, Session.AUTO_ACKNOWLEDGE)) {\n            \n            connection.start();\n            \n            // Create request message\n            Queue reqQueue = session.createQueue(requestQueue);\n            Queue repQueue = session.createQueue(replyQueue);\n            \n            TextMessage requestMsg = session.createTextMessage(request);\n            String correlId = UUID.randomUUID().toString();\n            requestMsg.setJMSCorrelationID(correlId);\n            requestMsg.setJMSReplyTo(repQueue);\n            \n            // Send request\n            QueueSender sender = session.createSender(reqQueue);\n            sender.send(requestMsg);\n            \n            // Wait for reply with matching correlation ID\n            String selector = \"JMSCorrelationID = '\" + correlId + \"'\";\n            QueueReceiver receiver = session.createReceiver(repQueue, selector);\n            \n            Message reply = receiver.receive(timeoutMs);\n            \n            if (reply instanceof TextMessage) {\n                return ((TextMessage) reply).getText();\n            }\n            \n            throw new JMSException(\"Timeout waiting for reply\");\n        }\n    }\n}",
      "python_pika": "import pika\nimport uuid\nfrom typing import Optional\n\nclass RequestReplyClient:\n    def __init__(self, host: str = 'localhost'):\n        self.connection = pika.BlockingConnection(\n            pika.ConnectionParameters(host=host)\n        )\n        self.channel = self.connection.channel()\n        \n        # Create exclusive reply queue\n        result = self.channel.queue_declare(queue='', exclusive=True)\n        self.reply_queue = result.method.queue\n        \n        self.response: Optional[str] = None\n        self.corr_id: Optional[str] = None\n        \n        self.channel.basic_consume(\n            queue=self.reply_queue,\n            on_message_callback=self._on_response,\n            auto_ack=True\n        )\n    \n    def _on_response(self, ch, method, props, body):\n        if self.corr_id == props.correlation_id:\n            self.response = body.decode('utf-8')\n    \n    def send_request(\n        self, \n        request_queue: str, \n        message: str,\n        timeout_sec: int = 60\n    ) -> Optional[str]:\n        self.response = None\n        self.corr_id = str(uuid.uuid4())\n        \n        self.channel.basic_publish(\n            exchange='',\n            routing_key=request_queue,\n            properties=pika.BasicProperties(\n                reply_to=self.reply_queue,\n                correlation_id=self.corr_id\n            ),\n            body=message\n        )\n        \n        # Wait for response\n        start_time = time.time()\n        while self.response is None:\n            self.connection.process_data_events(time_limit=1)\n            if time.time() - start_time > timeout_sec:\n                raise TimeoutError('Request timed out')\n        \n        return self.response",
      "spring_amqp": "@Service\npublic class RequestReplyService {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n    \n    public String sendAndReceive(String requestQueue, String message) {\n        // Synchronous request-reply\n        Object response = rabbitTemplate.convertSendAndReceive(\n            requestQueue, \n            message\n        );\n        return response != null ? response.toString() : null;\n    }\n}\n\n// Request handler\n@Component\npublic class RequestHandler {\n    @RabbitListener(queues = \"${request.queue}\")\n    public String handleRequest(String request) {\n        // Process request and return reply\n        return processRequest(request);\n    }\n}"
    },
    {
      "id": "MQ004",
      "category": "publish_subscribe",
      "name": "Publish-Subscribe Pattern",
      "description": "Topic-based publish-subscribe messaging",
      "cobol_mq": "       WORKING-STORAGE SECTION.\n       01  WS-MQSD.\n           COPY CMQSDV.\n       01  WS-TOPIC-STR       PIC X(100) VALUE 'orders/new'.\n       \n       PROCEDURE DIVISION.\n       PUBLISH-MESSAGE.\n           MOVE MQSO-CREATE TO MQSD-OPTIONS\n           ADD MQSO-FAIL-IF-QUIESCING TO MQSD-OPTIONS\n           MOVE WS-TOPIC-STR TO MQSD-OBJECTSTRING-VSPTR\n           MOVE LENGTH(WS-TOPIC-STR) TO MQSD-OBJECTSTRING-VSLENGTH\n           \n           CALL 'MQSUB' USING WS-HCONN\n                              WS-MQSD\n                              WS-HOBJ\n                              WS-HSUB\n                              WS-COMPCODE\n                              WS-REASON\n           \n           IF WS-COMPCODE = MQCC-OK\n               CALL 'MQPUT' USING WS-HCONN\n                                  WS-HOBJ\n                                  WS-MQMD\n                                  WS-MQPMO\n                                  WS-MSG-LEN\n                                  WS-MESSAGE\n                                  WS-COMPCODE\n                                  WS-REASON\n           END-IF.",
      "java_jms": "import javax.jms.*;\n\npublic class TopicPublisher {\n    private TopicConnectionFactory factory;\n    \n    public void publish(String topicName, String message) \n            throws JMSException {\n        \n        try (TopicConnection connection = factory.createTopicConnection();\n             TopicSession session = connection.createTopicSession(\n                 false, Session.AUTO_ACKNOWLEDGE)) {\n            \n            Topic topic = session.createTopic(topicName);\n            TopicPublisher publisher = session.createPublisher(topic);\n            \n            TextMessage textMsg = session.createTextMessage(message);\n            publisher.publish(textMsg);\n        }\n    }\n}\n\npublic class TopicSubscriber {\n    \n    public void subscribe(String topicName, MessageListener listener) \n            throws JMSException {\n        \n        TopicConnection connection = factory.createTopicConnection();\n        TopicSession session = connection.createTopicSession(\n            false, Session.AUTO_ACKNOWLEDGE);\n        \n        Topic topic = session.createTopic(topicName);\n        TopicSubscriber subscriber = session.createSubscriber(topic);\n        subscriber.setMessageListener(listener);\n        \n        connection.start();\n    }\n    \n    // Durable subscription\n    public void subscribeDurable(\n            String topicName, \n            String subscriptionName,\n            MessageListener listener) throws JMSException {\n        \n        TopicConnection connection = factory.createTopicConnection();\n        connection.setClientID(\"myClientId\");\n        \n        TopicSession session = connection.createTopicSession(\n            false, Session.AUTO_ACKNOWLEDGE);\n        \n        Topic topic = session.createTopic(topicName);\n        TopicSubscriber subscriber = session.createDurableSubscriber(\n            topic, subscriptionName);\n        subscriber.setMessageListener(listener);\n        \n        connection.start();\n    }\n}",
      "python_pika": "import pika\nfrom typing import Callable\n\nclass TopicPublisher:\n    def __init__(self, host: str = 'localhost'):\n        self.connection = pika.BlockingConnection(\n            pika.ConnectionParameters(host=host)\n        )\n        self.channel = self.connection.channel()\n        self.channel.exchange_declare(\n            exchange='topics',\n            exchange_type='topic'\n        )\n    \n    def publish(self, routing_key: str, message: str) -> None:\n        self.channel.basic_publish(\n            exchange='topics',\n            routing_key=routing_key,\n            body=message\n        )\n\nclass TopicSubscriber:\n    def __init__(self, host: str = 'localhost'):\n        self.connection = pika.BlockingConnection(\n            pika.ConnectionParameters(host=host)\n        )\n        self.channel = self.connection.channel()\n        self.channel.exchange_declare(\n            exchange='topics',\n            exchange_type='topic'\n        )\n    \n    def subscribe(\n        self,\n        binding_keys: list[str],\n        callback: Callable[[str, str], None]\n    ) -> None:\n        result = self.channel.queue_declare(queue='', exclusive=True)\n        queue_name = result.method.queue\n        \n        for key in binding_keys:\n            self.channel.queue_bind(\n                exchange='topics',\n                queue=queue_name,\n                routing_key=key\n            )\n        \n        def on_message(ch, method, properties, body):\n            callback(method.routing_key, body.decode('utf-8'))\n        \n        self.channel.basic_consume(\n            queue=queue_name,\n            on_message_callback=on_message,\n            auto_ack=True\n        )\n        \n        self.channel.start_consuming()",
      "spring_amqp": "@Configuration\npublic class TopicConfig {\n    @Bean\n    public TopicExchange topicExchange() {\n        return new TopicExchange(\"topics\");\n    }\n    \n    @Bean\n    public Queue ordersQueue() {\n        return new Queue(\"orders-queue\");\n    }\n    \n    @Bean\n    public Binding binding(Queue ordersQueue, TopicExchange exchange) {\n        return BindingBuilder\n            .bind(ordersQueue)\n            .to(exchange)\n            .with(\"orders.*\");\n    }\n}\n\n@Service\npublic class TopicService {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n    \n    public void publish(String routingKey, String message) {\n        rabbitTemplate.convertAndSend(\"topics\", routingKey, message);\n    }\n    \n    @RabbitListener(queues = \"orders-queue\")\n    public void handleOrderMessage(String message) {\n        // Process message\n    }\n}"
    },
    {
      "id": "MQ005",
      "category": "transactions",
      "name": "Transactional Messaging",
      "description": "MQ operations within transactions",
      "cobol_mq": "       WORKING-STORAGE SECTION.\n       01  WS-MQCMIT-OPTIONS  PIC S9(9) BINARY.\n       \n       PROCEDURE DIVISION.\n       TRANSACTIONAL-PUT.\n           MOVE MQPMO-SYNCPOINT TO MQPMO-OPTIONS\n           \n           CALL 'MQPUT' USING WS-HCONN\n                              WS-HOBJ-1\n                              WS-MQMD\n                              WS-MQPMO\n                              WS-MSG-LEN-1\n                              WS-MESSAGE-1\n                              WS-COMPCODE\n                              WS-REASON\n           \n           IF WS-COMPCODE = MQCC-OK\n               CALL 'MQPUT' USING WS-HCONN\n                                  WS-HOBJ-2\n                                  WS-MQMD\n                                  WS-MQPMO\n                                  WS-MSG-LEN-2\n                                  WS-MESSAGE-2\n                                  WS-COMPCODE\n                                  WS-REASON\n           END-IF\n           \n           IF WS-COMPCODE = MQCC-OK\n               CALL 'MQCMIT' USING WS-HCONN\n                                   WS-COMPCODE\n                                   WS-REASON\n           ELSE\n               CALL 'MQBACK' USING WS-HCONN\n                                   WS-COMPCODE\n                                   WS-REASON\n           END-IF.",
      "java_jms": "import javax.jms.*;\n\npublic class TransactionalMessaging {\n    \n    public void sendTransactional(\n            String queue1, String msg1,\n            String queue2, String msg2) throws JMSException {\n        \n        QueueConnection connection = factory.createQueueConnection();\n        // Create transacted session\n        QueueSession session = connection.createQueueSession(\n            true,  // transacted\n            Session.SESSION_TRANSACTED\n        );\n        \n        try {\n            Queue q1 = session.createQueue(queue1);\n            Queue q2 = session.createQueue(queue2);\n            \n            QueueSender sender1 = session.createSender(q1);\n            QueueSender sender2 = session.createSender(q2);\n            \n            sender1.send(session.createTextMessage(msg1));\n            sender2.send(session.createTextMessage(msg2));\n            \n            // Commit both messages\n            session.commit();\n            \n        } catch (JMSException e) {\n            // Rollback on error\n            session.rollback();\n            throw e;\n        } finally {\n            connection.close();\n        }\n    }\n}\n\n// Using Spring JMS with transactions\n@Service\npublic class TransactionalService {\n    @Autowired\n    private JmsTemplate jmsTemplate;\n    \n    @Transactional\n    public void sendBothMessages(String msg1, String msg2) {\n        jmsTemplate.convertAndSend(\"queue1\", msg1);\n        jmsTemplate.convertAndSend(\"queue2\", msg2);\n        // Both committed together\n    }\n}",
      "python_pika": "import pika\nfrom contextlib import contextmanager\n\nclass TransactionalMessaging:\n    def __init__(self, host: str = 'localhost'):\n        self.connection = pika.BlockingConnection(\n            pika.ConnectionParameters(host=host)\n        )\n        self.channel = self.connection.channel()\n    \n    @contextmanager\n    def transaction(self):\n        \"\"\"Context manager for transactional messaging.\"\"\"\n        self.channel.tx_select()\n        try:\n            yield self.channel\n            self.channel.tx_commit()\n        except Exception:\n            self.channel.tx_rollback()\n            raise\n    \n    def send_transactional(\n        self,\n        queue1: str, msg1: str,\n        queue2: str, msg2: str\n    ) -> None:\n        with self.transaction():\n            self.channel.queue_declare(queue=queue1, durable=True)\n            self.channel.queue_declare(queue=queue2, durable=True)\n            \n            self.channel.basic_publish(\n                exchange='',\n                routing_key=queue1,\n                body=msg1\n            )\n            self.channel.basic_publish(\n                exchange='',\n                routing_key=queue2,\n                body=msg2\n            )\n            # Both committed together",
      "kafka": "import org.apache.kafka.clients.producer.*;\nimport java.util.Properties;\n\npublic class TransactionalKafkaProducer {\n    private final KafkaProducer<String, String> producer;\n    \n    public TransactionalKafkaProducer(Properties props) {\n        props.put(\"transactional.id\", \"my-transactional-id\");\n        this.producer = new KafkaProducer<>(props);\n        producer.initTransactions();\n    }\n    \n    public void sendTransactional(\n            String topic1, String msg1,\n            String topic2, String msg2) {\n        \n        try {\n            producer.beginTransaction();\n            \n            producer.send(new ProducerRecord<>(topic1, msg1));\n            producer.send(new ProducerRecord<>(topic2, msg2));\n            \n            producer.commitTransaction();\n        } catch (Exception e) {\n            producer.abortTransaction();\n            throw e;\n        }\n    }\n}"
    },
    {
      "id": "MQ006",
      "category": "message_formats",
      "name": "Structured Message Format",
      "description": "Complex message with header and multiple segments",
      "message_layout": {
        "header": {
          "msg_type": "CHAR(8)",
          "msg_version": "CHAR(4)",
          "timestamp": "CHAR(26)",
          "correlation_id": "CHAR(24)",
          "source_system": "CHAR(8)",
          "target_system": "CHAR(8)",
          "segment_count": "NUMERIC(4)"
        },
        "segments": [
          {
            "segment_type": "CHAR(4)",
            "segment_length": "NUMERIC(6)",
            "segment_data": "VARIABLE"
          }
        ]
      },
      "cobol_copybook": "       01  MQ-MESSAGE.\n           05  MQ-HEADER.\n               10  MQ-MSG-TYPE       PIC X(8).\n               10  MQ-MSG-VERSION    PIC X(4).\n               10  MQ-TIMESTAMP      PIC X(26).\n               10  MQ-CORREL-ID      PIC X(24).\n               10  MQ-SOURCE-SYS     PIC X(8).\n               10  MQ-TARGET-SYS     PIC X(8).\n               10  MQ-SEGMENT-CNT    PIC 9(4).\n           05  MQ-SEGMENTS OCCURS 1 TO 99 TIMES\n                           DEPENDING ON MQ-SEGMENT-CNT.\n               10  MQ-SEG-TYPE       PIC X(4).\n               10  MQ-SEG-LEN        PIC 9(6).\n               10  MQ-SEG-DATA       PIC X(1000).",
      "java_class": "import java.time.Instant;\nimport java.util.List;\nimport java.util.ArrayList;\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\npublic class MQMessage {\n    private Header header;\n    private List<Segment> segments;\n    \n    public static class Header {\n        private String msgType;\n        private String msgVersion;\n        private Instant timestamp;\n        private String correlationId;\n        private String sourceSystem;\n        private String targetSystem;\n        \n        // Getters and setters\n    }\n    \n    public static class Segment {\n        private String segmentType;\n        private int segmentLength;\n        private byte[] segmentData;\n        \n        // Getters and setters\n    }\n    \n    // Builder pattern\n    public static class Builder {\n        private final MQMessage message = new MQMessage();\n        \n        public Builder msgType(String type) {\n            message.getHeader().setMsgType(type);\n            return this;\n        }\n        \n        public Builder addSegment(String type, byte[] data) {\n            Segment seg = new Segment();\n            seg.setSegmentType(type);\n            seg.setSegmentData(data);\n            seg.setSegmentLength(data.length);\n            message.getSegments().add(seg);\n            return this;\n        }\n        \n        public MQMessage build() {\n            return message;\n        }\n    }\n}",
      "python_class": "from dataclasses import dataclass, field\nfrom datetime import datetime\nfrom typing import List, Optional\nimport json\n\n@dataclass\nclass Header:\n    msg_type: str\n    msg_version: str\n    timestamp: datetime\n    correlation_id: str\n    source_system: str\n    target_system: str\n    \n    def to_dict(self) -> dict:\n        return {\n            'msgType': self.msg_type,\n            'msgVersion': self.msg_version,\n            'timestamp': self.timestamp.isoformat(),\n            'correlationId': self.correlation_id,\n            'sourceSystem': self.source_system,\n            'targetSystem': self.target_system\n        }\n\n@dataclass\nclass Segment:\n    segment_type: str\n    segment_data: bytes\n    \n    @property\n    def segment_length(self) -> int:\n        return len(self.segment_data)\n    \n    def to_dict(self) -> dict:\n        return {\n            'segmentType': self.segment_type,\n            'segmentLength': self.segment_length,\n            'segmentData': self.segment_data.decode('utf-8')\n        }\n\n@dataclass\nclass MQMessage:\n    header: Header\n    segments: List[Segment] = field(default_factory=list)\n    \n    def to_json(self) -> str:\n        return json.dumps({\n            'header': self.header.to_dict(),\n            'segments': [s.to_dict() for s in self.segments]\n        })\n    \n    @classmethod\n    def from_json(cls, json_str: str) -> 'MQMessage':\n        data = json.loads(json_str)\n        header = Header(\n            msg_type=data['header']['msgType'],\n            msg_version=data['header']['msgVersion'],\n            timestamp=datetime.fromisoformat(data['header']['timestamp']),\n            correlation_id=data['header']['correlationId'],\n            source_system=data['header']['sourceSystem'],\n            target_system=data['header']['targetSystem']\n        )\n        segments = [\n            Segment(\n                segment_type=s['segmentType'],\n                segment_data=s['segmentData'].encode('utf-8')\n            )\n            for s in data['segments']\n        ]\n        return cls(header=header, segments=segments)"
    },
    {
      "id": "MQ007",
      "category": "dead_letter",
      "name": "Dead Letter Queue Handling",
      "description": "Processing messages from dead letter queue",
      "cobol_mq": "       WORKING-STORAGE SECTION.\n       01  WS-MQDLH.\n           COPY CMQDLHV.\n       01  WS-DLQ-MSG         PIC X(10000).\n       01  WS-ORIG-MSG        PIC X(9000).\n       01  WS-DLH-LEN         PIC S9(9) BINARY.\n       \n       PROCEDURE DIVISION.\n       PROCESS-DLQ.\n           MOVE MQGMO-WAIT TO MQGMO-OPTIONS\n           \n           CALL 'MQGET' USING WS-HCONN\n                              WS-HOBJ-DLQ\n                              WS-MQMD\n                              WS-MQGMO\n                              WS-BUFFER-LEN\n                              WS-DLQ-MSG\n                              WS-DATA-LEN\n                              WS-COMPCODE\n                              WS-REASON\n           \n           IF WS-COMPCODE = MQCC-OK\n               IF MQMD-FORMAT = MQDLH-STRUC-ID\n                   MOVE WS-DLQ-MSG(1:LENGTH OF MQDLH)\n                       TO WS-MQDLH\n                   COMPUTE WS-DLH-LEN = LENGTH OF MQDLH\n                   MOVE WS-DLQ-MSG(WS-DLH-LEN + 1:)\n                       TO WS-ORIG-MSG\n                   \n                   EVALUATE MQDLH-REASON\n                       WHEN MQRC-MSG-TOO-BIG-FOR-Q\n                           PERFORM HANDLE-OVERSIZE\n                       WHEN MQRC-Q-FULL\n                           PERFORM RETRY-MESSAGE\n                       WHEN OTHER\n                           PERFORM LOG-AND-DISCARD\n                   END-EVALUATE\n               END-IF\n           END-IF.",
      "java_jms": "import javax.jms.*;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class DeadLetterProcessor {\n    \n    public void processDLQ(String dlqName) throws JMSException {\n        try (QueueConnection connection = factory.createQueueConnection();\n             QueueSession session = connection.createQueueSession(\n                 false, Session.CLIENT_ACKNOWLEDGE)) {\n            \n            connection.start();\n            Queue dlq = session.createQueue(dlqName);\n            QueueReceiver receiver = session.createReceiver(dlq);\n            \n            while (true) {\n                Message message = receiver.receive(5000);\n                if (message == null) break;\n                \n                // Get DLQ headers\n                String failedQueue = message.getStringProperty(\n                    \"JMS_IBM_DLQ_Destination\");\n                int reason = message.getIntProperty(\n                    \"JMS_IBM_DLQ_Reason\");\n                int retryCount = message.getIntProperty(\n                    \"JMSXDeliveryCount\");\n                \n                try {\n                    handleDLQMessage(message, reason, retryCount);\n                    message.acknowledge();\n                } catch (Exception e) {\n                    // Log and leave in DLQ\n                    log.error(\"Failed to process DLQ message\", e);\n                }\n            }\n        }\n    }\n    \n    private void handleDLQMessage(Message message, int reason, \n            int retryCount) throws JMSException {\n        \n        switch (reason) {\n            case 2053:  // MQRC_Q_FULL\n                if (retryCount < 3) {\n                    retryMessage(message);\n                } else {\n                    logAndDiscard(message);\n                }\n                break;\n            case 2030:  // MQRC_MSG_TOO_BIG_FOR_Q\n                handleOversizeMessage(message);\n                break;\n            default:\n                logAndDiscard(message);\n        }\n    }\n}",
      "spring_amqp": "@Configuration\npublic class DLQConfig {\n    @Bean\n    public Queue mainQueue() {\n        return QueueBuilder.durable(\"main-queue\")\n            .withArgument(\"x-dead-letter-exchange\", \"dlx\")\n            .withArgument(\"x-dead-letter-routing-key\", \"dlq\")\n            .build();\n    }\n    \n    @Bean\n    public DirectExchange dlx() {\n        return new DirectExchange(\"dlx\");\n    }\n    \n    @Bean\n    public Queue dlq() {\n        return new Queue(\"dlq\");\n    }\n    \n    @Bean\n    public Binding dlqBinding() {\n        return BindingBuilder.bind(dlq()).to(dlx()).with(\"dlq\");\n    }\n}\n\n@Component\npublic class DLQProcessor {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n    \n    @RabbitListener(queues = \"dlq\")\n    public void processDLQ(Message message) {\n        Map<String, Object> headers = message.getMessageProperties().getHeaders();\n        \n        List<Map<String, Object>> xDeath = \n            (List<Map<String, Object>>) headers.get(\"x-death\");\n        \n        if (xDeath != null && !xDeath.isEmpty()) {\n            String reason = (String) xDeath.get(0).get(\"reason\");\n            Long count = (Long) xDeath.get(0).get(\"count\");\n            String originalQueue = (String) xDeath.get(0).get(\"queue\");\n            \n            if (\"rejected\".equals(reason) && count < 3) {\n                // Retry\n                rabbitTemplate.send(originalQueue, message);\n            } else {\n                // Log and discard or move to parking lot\n                logFailedMessage(message, reason);\n            }\n        }\n    }\n}"
    },
    {
      "id": "MQ008",
      "category": "clustering",
      "name": "Queue Manager Clustering",
      "description": "Working with clustered queue managers",
      "mq_commands": "* Define cluster receiver channel\nDEFINE CHANNEL(TO.QM1) CHLTYPE(CLUSRCVR) +\n       TRPTYPE(TCP) CONNAME('server1(1414)') +\n       CLUSTER(MYCLUSTER)\n\n* Define cluster sender channel  \nDEFINE CHANNEL(TO.QM2) CHLTYPE(CLUSSDR) +\n       TRPTYPE(TCP) CONNAME('server2(1414)') +\n       CLUSTER(MYCLUSTER)\n\n* Define cluster queue\nDEFINE QLOCAL(CLUSTER.QUEUE) +\n       CLUSTER(MYCLUSTER) +\n       DEFBIND(NOTFIXED)",
      "java_ccdt": "// Using CCDT (Client Channel Definition Table)\nimport com.ibm.mq.jms.MQQueueConnectionFactory;\nimport java.net.URL;\n\npublic class ClusterClient {\n    \n    public MQQueueConnectionFactory createClusterFactory() \n            throws Exception {\n        \n        MQQueueConnectionFactory factory = new MQQueueConnectionFactory();\n        \n        // Use CCDT for cluster connection\n        URL ccdtUrl = new URL(\"file:///path/to/AMQCLCHL.TAB\");\n        factory.setCCDTURL(ccdtUrl);\n        factory.setQueueManager(\"*MYCLUSTER\");  // Connect to any in cluster\n        \n        return factory;\n    }\n    \n    // Or use connection name list\n    public MQQueueConnectionFactory createWithConnList() throws Exception {\n        MQQueueConnectionFactory factory = new MQQueueConnectionFactory();\n        \n        factory.setConnectionNameList(\n            \"server1(1414),server2(1414),server3(1414)\");\n        factory.setQueueManager(\"QM1\");\n        factory.setChannel(\"CLIENT.CHANNEL\");\n        \n        return factory;\n    }\n}",
      "spring_config": "spring:\n  rabbitmq:\n    addresses: server1:5672,server2:5672,server3:5672\n    username: guest\n    password: guest\n    virtual-host: /\n    connection-timeout: 10000\n    \n    # Cluster-aware configuration\n    listener:\n      simple:\n        acknowledge-mode: manual\n        prefetch: 10\n        concurrency: 3\n        max-concurrency: 10\n        \n    template:\n      retry:\n        enabled: true\n        initial-interval: 1000\n        max-attempts: 3"
    }
  ],
  "message_property_mapping": {
    "MQMD-MSGID": {"jms": "JMSMessageID", "amqp": "message_id"},
    "MQMD-CORRELID": {"jms": "JMSCorrelationID", "amqp": "correlation_id"},
    "MQMD-REPLYTOQ": {"jms": "JMSReplyTo", "amqp": "reply_to"},
    "MQMD-EXPIRY": {"jms": "JMSExpiration", "amqp": "expiration"},
    "MQMD-PRIORITY": {"jms": "JMSPriority", "amqp": "priority"},
    "MQMD-PERSISTENCE": {"jms": "JMSDeliveryMode", "amqp": "delivery_mode"},
    "MQMD-MSGTYPE": {"jms": "JMSType", "amqp": "type"},
    "MQMD-FORMAT": {"jms": "JMS_IBM_Format", "amqp": "content_type"},
    "MQMD-PUTAPPLNAME": {"jms": "JMS_IBM_PutApplName", "amqp": "app_id"},
    "MQMD-PUTDATE": {"jms": "JMSTimestamp", "amqp": "timestamp"}
  },
  "reason_code_mapping": {
    "MQRC_NONE": {"code": 0, "description": "No error"},
    "MQRC_NO_MSG_AVAILABLE": {"code": 2033, "description": "No message available"},
    "MQRC_Q_FULL": {"code": 2053, "description": "Queue is full"},
    "MQRC_MSG_TOO_BIG_FOR_Q": {"code": 2030, "description": "Message too large for queue"},
    "MQRC_CONNECTION_BROKEN": {"code": 2009, "description": "Connection to queue manager lost"},
    "MQRC_NOT_AUTHORIZED": {"code": 2035, "description": "Not authorized"},
    "MQRC_UNKNOWN_OBJECT_NAME": {"code": 2085, "description": "Queue does not exist"}
  }
}

{
  "metadata": {
    "title": "SWIFT and ISO 20022 Financial Messaging Patterns",
    "version": "1.0.0",
    "description": "SWIFT MT messages and ISO 20022 XML formats with parsing and generation patterns",
    "standards": ["SWIFT MT", "ISO 20022", "SEPA", "TARGET2"],
    "total_patterns": 35
  },
  "swift_mt_messages": [
    {
      "id": "MT103",
      "name": "Single Customer Credit Transfer",
      "description": "Standard SWIFT payment message for customer transfers",
      "category": "Customer Payments",
      "sample": "{1:F01BANKBEBBAXXX0000000000}{2:O1031200231215BANKFRPPAXXX00000000002312151200N}{3:{108:MT103REF001}}{4:\n:20:REFERENCE001\n:23B:CRED\n:32A:231215EUR100000,00\n:33B:EUR100000,00\n:50K:/DE89370400440532013000\nJOHN DOE\n123 MAIN STREET\nFRANKFURT\n:52A:DEUTDEFF\n:53A:COBADEFF\n:57A:BNPAFRPP\n:59:/FR7630004000031234567890143\nJANE SMITH\n456 RUE DE PARIS\nPARIS\n:70:INVOICE 12345\n:71A:SHA\n-}",
      "blocks": {
        "block1": "Basic Header - Application ID, Service ID, LT Address",
        "block2": "Application Header - Input/Output, Message Type, Priority",
        "block3": "User Header - Reference, Validation flags",
        "block4": "Text Block - Message content",
        "block5": "Trailer - Checksum, authentication"
      },
      "fields": {
        "20": {"name": "Sender's Reference", "mandatory": true, "format": "16x"},
        "23B": {"name": "Bank Operation Code", "mandatory": true, "format": "4!c"},
        "32A": {"name": "Value Date/Currency/Amount", "mandatory": true, "format": "6!n3!a15d"},
        "33B": {"name": "Currency/Instructed Amount", "mandatory": false, "format": "3!a15d"},
        "50K": {"name": "Ordering Customer", "mandatory": true, "format": "Account + Name and Address"},
        "52A": {"name": "Ordering Institution", "mandatory": false, "format": "BIC"},
        "53A": {"name": "Sender's Correspondent", "mandatory": false, "format": "BIC"},
        "57A": {"name": "Account With Institution", "mandatory": false, "format": "BIC"},
        "59": {"name": "Beneficiary Customer", "mandatory": true, "format": "Account + Name and Address"},
        "70": {"name": "Remittance Information", "mandatory": false, "format": "4*35x"},
        "71A": {"name": "Details of Charges", "mandatory": true, "format": "3!a"}
      },
      "cobol_structure": "       01  MT103-MESSAGE.\n           05  MT103-HEADER.\n               10  MT103-BASIC-HEADER    PIC X(25).\n               10  MT103-APP-HEADER      PIC X(56).\n               10  MT103-USER-HEADER     PIC X(100).\n           05  MT103-BODY.\n               10  MT103-SENDERS-REF     PIC X(16).\n               10  MT103-BANK-OP-CODE    PIC X(4).\n               10  MT103-VALUE-DATE      PIC 9(6).\n               10  MT103-CURRENCY        PIC X(3).\n               10  MT103-AMOUNT          PIC 9(13)V99.\n               10  MT103-ORDERING-CUST.\n                   15  MT103-ORD-ACCT    PIC X(34).\n                   15  MT103-ORD-NAME    PIC X(35).\n                   15  MT103-ORD-ADDR1   PIC X(35).\n                   15  MT103-ORD-ADDR2   PIC X(35).\n               10  MT103-ORDERING-INST   PIC X(11).\n               10  MT103-SENDERS-CORR    PIC X(11).\n               10  MT103-ACCT-WITH-INST  PIC X(11).\n               10  MT103-BENEFICIARY.\n                   15  MT103-BEN-ACCT    PIC X(34).\n                   15  MT103-BEN-NAME    PIC X(35).\n                   15  MT103-BEN-ADDR1   PIC X(35).\n                   15  MT103-BEN-ADDR2   PIC X(35).\n               10  MT103-REMIT-INFO      PIC X(140).\n               10  MT103-CHARGES         PIC X(3).",
      "java_model": "import java.math.BigDecimal;\nimport java.time.LocalDate;\nimport java.util.Currency;\n\npublic class MT103Message {\n    // Block 1 - Basic Header\n    private String applicationId;\n    private String serviceId;\n    private String logicalTerminal;\n    private String sessionNumber;\n    private String sequenceNumber;\n    \n    // Block 2 - Application Header\n    private boolean isInput;\n    private String messageType;\n    private String receiverAddress;\n    private String messagePriority;\n    private LocalDate senderInputTime;\n    \n    // Block 4 - Message Body\n    private String sendersReference;        // :20:\n    private String bankOperationCode;       // :23B:\n    private LocalDate valueDate;            // :32A: date part\n    private Currency currency;              // :32A: currency\n    private BigDecimal amount;              // :32A: amount\n    private BigDecimal instructedAmount;    // :33B:\n    private OrderingCustomer orderingCustomer;  // :50K:\n    private String orderingInstitution;     // :52A:\n    private String sendersCorrespondent;    // :53A:\n    private String accountWithInstitution;  // :57A:\n    private Beneficiary beneficiary;        // :59:\n    private String remittanceInfo;          // :70:\n    private ChargeType chargeDetails;       // :71A:\n    \n    public enum ChargeType {\n        BEN,  // Beneficiary pays\n        OUR,  // Ordering customer pays\n        SHA   // Shared\n    }\n    \n    public static class OrderingCustomer {\n        private String account;\n        private String name;\n        private String addressLine1;\n        private String addressLine2;\n        private String city;\n        private String country;\n    }\n    \n    public static class Beneficiary {\n        private String account;\n        private String name;\n        private String addressLine1;\n        private String addressLine2;\n    }\n    \n    // Parse from SWIFT message\n    public static MT103Message parse(String swiftMessage) {\n        MT103Message msg = new MT103Message();\n        // Parse block 1\n        msg.parseBasicHeader(swiftMessage);\n        // Parse block 4 fields\n        msg.parseField20(extractField(swiftMessage, \"20\"));\n        msg.parseField32A(extractField(swiftMessage, \"32A\"));\n        // ... continue for all fields\n        return msg;\n    }\n}",
      "python_model": "from dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom datetime import date\nfrom enum import Enum\nfrom typing import Optional, List\nimport re\n\nclass ChargeType(Enum):\n    BEN = 'BEN'  # Beneficiary pays\n    OUR = 'OUR'  # Ordering customer pays\n    SHA = 'SHA'  # Shared\n\n@dataclass\nclass Party:\n    account: str\n    name: str\n    address_line1: str = ''\n    address_line2: str = ''\n    city: str = ''\n    country: str = ''\n\n@dataclass\nclass MT103Message:\n    # Basic Header (Block 1)\n    application_id: str = 'F'\n    service_id: str = '01'\n    logical_terminal: str = ''\n    \n    # Application Header (Block 2)\n    message_type: str = '103'\n    receiver_address: str = ''\n    priority: str = 'N'\n    \n    # Message Body (Block 4)\n    senders_reference: str = ''           # :20:\n    bank_operation_code: str = 'CRED'     # :23B:\n    value_date: date = field(default_factory=date.today)  # :32A:\n    currency: str = 'EUR'                 # :32A:\n    amount: Decimal = Decimal('0')        # :32A:\n    instructed_amount: Optional[Decimal] = None  # :33B:\n    ordering_customer: Optional[Party] = None    # :50K:\n    ordering_institution: str = ''        # :52A:\n    senders_correspondent: str = ''       # :53A:\n    account_with_institution: str = ''    # :57A:\n    beneficiary: Optional[Party] = None   # :59:\n    remittance_info: str = ''             # :70:\n    charge_details: ChargeType = ChargeType.SHA  # :71A:\n    \n    @classmethod\n    def parse(cls, swift_message: str) -> 'MT103Message':\n        msg = cls()\n        \n        # Parse blocks\n        block1_match = re.search(r'\\{1:(.+?)\\}', swift_message)\n        block4_match = re.search(r'\\{4:\\n(.+?)\\n-\\}', swift_message, re.DOTALL)\n        \n        if block1_match:\n            msg._parse_block1(block1_match.group(1))\n        \n        if block4_match:\n            msg._parse_block4(block4_match.group(1))\n        \n        return msg\n    \n    def _parse_block4(self, block4: str) -> None:\n        lines = block4.strip().split('\\n')\n        current_field = None\n        field_data = []\n        \n        for line in lines:\n            if line.startswith(':'):\n                if current_field:\n                    self._set_field(current_field, field_data)\n                # Extract field tag\n                match = re.match(r':([0-9A-Z]+):', line)\n                if match:\n                    current_field = match.group(1)\n                    field_data = [line[len(match.group(0)):]]\n            else:\n                field_data.append(line)\n        \n        if current_field:\n            self._set_field(current_field, field_data)\n    \n    def _set_field(self, tag: str, data: List[str]) -> None:\n        value = '\\n'.join(data)\n        \n        if tag == '20':\n            self.senders_reference = value\n        elif tag == '23B':\n            self.bank_operation_code = value\n        elif tag == '32A':\n            self.value_date = date(\n                2000 + int(value[0:2]),\n                int(value[2:4]),\n                int(value[4:6])\n            )\n            self.currency = value[6:9]\n            self.amount = Decimal(value[9:].replace(',', '.'))\n    \n    def to_swift(self) -> str:\n        \"\"\"Generate SWIFT MT103 message format\"\"\"\n        lines = [\n            f':20:{self.senders_reference}',\n            f':23B:{self.bank_operation_code}',\n            f':32A:{self.value_date.strftime(\"%y%m%d\")}{self.currency}'\n            f'{str(self.amount).replace(\".\", \",\")}',\n        ]\n        \n        if self.ordering_customer:\n            lines.append(f':50K:/{self.ordering_customer.account}')\n            lines.append(self.ordering_customer.name)\n            if self.ordering_customer.address_line1:\n                lines.append(self.ordering_customer.address_line1)\n        \n        # Continue for all fields...\n        \n        return '\\n'.join(lines)"
    },
    {
      "id": "MT202",
      "name": "General Financial Institution Transfer",
      "description": "Bank-to-bank transfer message",
      "category": "Financial Institution Transfers",
      "sample": "{1:F01BANKBEBBAXXX0000000000}{2:O2021200231215BANKFRPPAXXX00000000002312151200N}{4:\n:20:TRF202312150001\n:21:RELREF001\n:32A:231215EUR500000,00\n:52A:DEUTDEFF\n:53A:COBADEFF\n:57A:BNPAFRPP\n:58A:SOLOXXXX\n:72:/ACC/ACCOUNT CREDIT\n-}",
      "fields": {
        "20": "Transaction Reference Number",
        "21": "Related Reference",
        "32A": "Value Date/Currency/Amount",
        "52A": "Ordering Institution",
        "53A": "Sender's Correspondent",
        "57A": "Account With Institution",
        "58A": "Beneficiary Institution",
        "72": "Sender to Receiver Information"
      }
    },
    {
      "id": "MT940",
      "name": "Customer Statement Message",
      "description": "Account statement with transaction details",
      "category": "Cash Management",
      "sample": "{1:F01BANKBEBBAXXX0000000000}{2:O9400730231215BANKFRPPAXXX00000000002312150730N}{4:\n:20:STMT231215001\n:25:BE68539007547034\n:28C:235/1\n:60F:C231214EUR125000,00\n:61:2312150101C10000,00NTRFREF001//ACCTSVCS\n:86:PAYMENT FROM CUSTOMER ABC\n:61:2312150201D5000,00NTRFREF002//ACCTSVCS\n:86:PAYMENT TO SUPPLIER XYZ\n:62F:C231215EUR130000,00\n:64:C231215EUR130000,00\n-}",
      "fields": {
        "20": "Transaction Reference Number",
        "25": "Account Identification",
        "28C": "Statement Number/Sequence Number",
        "60F": "Opening Balance",
        "61": "Statement Line",
        "86": "Information to Account Owner",
        "62F": "Closing Balance",
        "64": "Closing Available Balance"
      },
      "transaction_type_codes": {
        "NTRN": "Transfer",
        "NCHK": "Cheque",
        "NDIV": "Dividend",
        "NINT": "Interest",
        "NRTI": "Returned Item"
      }
    }
  ],
  "iso20022_messages": [
    {
      "id": "pain.001",
      "name": "CustomerCreditTransferInitiationV09",
      "description": "Customer Credit Transfer Initiation - ISO 20022 equivalent of MT101",
      "namespace": "urn:iso:std:iso:20022:tech:xsd:pain.001.001.09",
      "sample_xml": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Document xmlns=\"urn:iso:std:iso:20022:tech:xsd:pain.001.001.09\">\n  <CstmrCdtTrfInitn>\n    <GrpHdr>\n      <MsgId>MSG-2023121500001</MsgId>\n      <CreDtTm>2023-12-15T09:00:00</CreDtTm>\n      <NbOfTxs>1</NbOfTxs>\n      <CtrlSum>100000.00</CtrlSum>\n      <InitgPty>\n        <Nm>ACME Corporation</Nm>\n        <Id>\n          <OrgId>\n            <Othr>\n              <Id>123456789</Id>\n            </Othr>\n          </OrgId>\n        </Id>\n      </InitgPty>\n    </GrpHdr>\n    <PmtInf>\n      <PmtInfId>PMT-001</PmtInfId>\n      <PmtMtd>TRF</PmtMtd>\n      <NbOfTxs>1</NbOfTxs>\n      <CtrlSum>100000.00</CtrlSum>\n      <ReqdExctnDt>\n        <Dt>2023-12-15</Dt>\n      </ReqdExctnDt>\n      <Dbtr>\n        <Nm>ACME Corporation</Nm>\n        <PstlAdr>\n          <StrtNm>123 Main Street</StrtNm>\n          <TwnNm>Frankfurt</TwnNm>\n          <Ctry>DE</Ctry>\n        </PstlAdr>\n      </Dbtr>\n      <DbtrAcct>\n        <Id>\n          <IBAN>DE89370400440532013000</IBAN>\n        </Id>\n      </DbtrAcct>\n      <DbtrAgt>\n        <FinInstnId>\n          <BICFI>DEUTDEFF</BICFI>\n        </FinInstnId>\n      </DbtrAgt>\n      <CdtTrfTxInf>\n        <PmtId>\n          <EndToEndId>E2E-REF-001</EndToEndId>\n        </PmtId>\n        <Amt>\n          <InstdAmt Ccy=\"EUR\">100000.00</InstdAmt>\n        </Amt>\n        <CdtrAgt>\n          <FinInstnId>\n            <BICFI>BNPAFRPP</BICFI>\n          </FinInstnId>\n        </CdtrAgt>\n        <Cdtr>\n          <Nm>Jane Smith</Nm>\n          <PstlAdr>\n            <StrtNm>456 Rue de Paris</StrtNm>\n            <TwnNm>Paris</TwnNm>\n            <Ctry>FR</Ctry>\n          </PstlAdr>\n        </Cdtr>\n        <CdtrAcct>\n          <Id>\n            <IBAN>FR7630004000031234567890143</IBAN>\n          </Id>\n        </CdtrAcct>\n        <RmtInf>\n          <Ustrd>Invoice 12345</Ustrd>\n        </RmtInf>\n      </CdtTrfTxInf>\n    </PmtInf>\n  </CstmrCdtTrfInitn>\n</Document>",
      "java_jaxb": "import javax.xml.bind.annotation.*;\nimport java.math.BigDecimal;\nimport java.time.LocalDateTime;\nimport java.time.LocalDate;\nimport java.util.List;\n\n@XmlRootElement(name = \"Document\")\n@XmlAccessorType(XmlAccessType.FIELD)\npublic class Pain001Document {\n    @XmlElement(name = \"CstmrCdtTrfInitn\")\n    private CustomerCreditTransferInitiation customerCreditTransferInitiation;\n}\n\npublic class CustomerCreditTransferInitiation {\n    @XmlElement(name = \"GrpHdr\")\n    private GroupHeader groupHeader;\n    \n    @XmlElement(name = \"PmtInf\")\n    private List<PaymentInformation> paymentInformation;\n}\n\npublic class GroupHeader {\n    @XmlElement(name = \"MsgId\")\n    private String messageId;\n    \n    @XmlElement(name = \"CreDtTm\")\n    private LocalDateTime creationDateTime;\n    \n    @XmlElement(name = \"NbOfTxs\")\n    private int numberOfTransactions;\n    \n    @XmlElement(name = \"CtrlSum\")\n    private BigDecimal controlSum;\n    \n    @XmlElement(name = \"InitgPty\")\n    private PartyIdentification initiatingParty;\n}\n\npublic class PaymentInformation {\n    @XmlElement(name = \"PmtInfId\")\n    private String paymentInformationId;\n    \n    @XmlElement(name = \"PmtMtd\")\n    private String paymentMethod;\n    \n    @XmlElement(name = \"Dbtr\")\n    private PartyIdentification debtor;\n    \n    @XmlElement(name = \"DbtrAcct\")\n    private CashAccount debtorAccount;\n    \n    @XmlElement(name = \"DbtrAgt\")\n    private BranchAndFinancialInstitution debtorAgent;\n    \n    @XmlElement(name = \"CdtTrfTxInf\")\n    private List<CreditTransferTransaction> creditTransferTransactions;\n}\n\npublic class CreditTransferTransaction {\n    @XmlElement(name = \"PmtId\")\n    private PaymentIdentification paymentId;\n    \n    @XmlElement(name = \"Amt\")\n    private Amount amount;\n    \n    @XmlElement(name = \"Cdtr\")\n    private PartyIdentification creditor;\n    \n    @XmlElement(name = \"CdtrAcct\")\n    private CashAccount creditorAccount;\n    \n    @XmlElement(name = \"RmtInf\")\n    private RemittanceInformation remittanceInformation;\n}",
      "python_dataclass": "from dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom datetime import datetime, date\nfrom typing import List, Optional\nimport xml.etree.ElementTree as ET\n\n@dataclass\nclass PostalAddress:\n    street_name: str = ''\n    town_name: str = ''\n    country: str = ''\n    post_code: str = ''\n\n@dataclass\nclass PartyIdentification:\n    name: str\n    postal_address: Optional[PostalAddress] = None\n    org_id: str = ''\n\n@dataclass\nclass CashAccount:\n    iban: str\n\n@dataclass\nclass FinancialInstitution:\n    bic: str\n\n@dataclass\nclass Amount:\n    currency: str\n    value: Decimal\n\n@dataclass\nclass PaymentIdentification:\n    end_to_end_id: str\n    instruction_id: str = ''\n\n@dataclass\nclass CreditTransferTransaction:\n    payment_id: PaymentIdentification\n    amount: Amount\n    creditor: PartyIdentification\n    creditor_account: CashAccount\n    creditor_agent: FinancialInstitution\n    remittance_info: str = ''\n\n@dataclass\nclass PaymentInformation:\n    payment_info_id: str\n    payment_method: str\n    debtor: PartyIdentification\n    debtor_account: CashAccount\n    debtor_agent: FinancialInstitution\n    requested_execution_date: date\n    credit_transfers: List[CreditTransferTransaction] = field(default_factory=list)\n\n@dataclass\nclass GroupHeader:\n    message_id: str\n    creation_date_time: datetime\n    number_of_transactions: int\n    control_sum: Decimal\n    initiating_party: PartyIdentification\n\n@dataclass\nclass Pain001Message:\n    group_header: GroupHeader\n    payment_information: List[PaymentInformation] = field(default_factory=list)\n    \n    def to_xml(self) -> str:\n        ns = 'urn:iso:std:iso:20022:tech:xsd:pain.001.001.09'\n        root = ET.Element('Document', xmlns=ns)\n        \n        cstmr = ET.SubElement(root, 'CstmrCdtTrfInitn')\n        \n        # Group Header\n        grp_hdr = ET.SubElement(cstmr, 'GrpHdr')\n        ET.SubElement(grp_hdr, 'MsgId').text = self.group_header.message_id\n        ET.SubElement(grp_hdr, 'CreDtTm').text = \\\n            self.group_header.creation_date_time.isoformat()\n        ET.SubElement(grp_hdr, 'NbOfTxs').text = \\\n            str(self.group_header.number_of_transactions)\n        ET.SubElement(grp_hdr, 'CtrlSum').text = \\\n            str(self.group_header.control_sum)\n        \n        # ... continue building XML\n        \n        return ET.tostring(root, encoding='unicode')\n    \n    @classmethod\n    def from_xml(cls, xml_string: str) -> 'Pain001Message':\n        root = ET.fromstring(xml_string)\n        ns = {'ns': 'urn:iso:std:iso:20022:tech:xsd:pain.001.001.09'}\n        \n        grp_hdr_elem = root.find('.//ns:GrpHdr', ns)\n        \n        group_header = GroupHeader(\n            message_id=grp_hdr_elem.find('ns:MsgId', ns).text,\n            creation_date_time=datetime.fromisoformat(\n                grp_hdr_elem.find('ns:CreDtTm', ns).text\n            ),\n            number_of_transactions=int(\n                grp_hdr_elem.find('ns:NbOfTxs', ns).text\n            ),\n            control_sum=Decimal(\n                grp_hdr_elem.find('ns:CtrlSum', ns).text\n            ),\n            initiating_party=cls._parse_party(\n                grp_hdr_elem.find('ns:InitgPty', ns), ns\n            )\n        )\n        \n        return cls(group_header=group_header)"
    },
    {
      "id": "pacs.008",
      "name": "FIToFICustomerCreditTransfer",
      "description": "FI to FI Customer Credit Transfer - Interbank message",
      "namespace": "urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08",
      "key_elements": {
        "GrpHdr": "Group Header with message identification",
        "CdtTrfTxInf": "Credit Transfer Transaction Information",
        "IntrBkSttlmAmt": "Interbank Settlement Amount",
        "IntrBkSttlmDt": "Interbank Settlement Date",
        "InstgAgt": "Instructing Agent",
        "InstdAgt": "Instructed Agent",
        "Dbtr": "Debtor",
        "DbtrAcct": "Debtor Account",
        "Cdtr": "Creditor",
        "CdtrAcct": "Creditor Account"
      }
    },
    {
      "id": "camt.053",
      "name": "BankToCustomerStatement",
      "description": "Bank to Customer Statement - ISO 20022 equivalent of MT940",
      "namespace": "urn:iso:std:iso:20022:tech:xsd:camt.053.001.08",
      "sample_xml": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Document xmlns=\"urn:iso:std:iso:20022:tech:xsd:camt.053.001.08\">\n  <BkToCstmrStmt>\n    <GrpHdr>\n      <MsgId>STMT-2023121500001</MsgId>\n      <CreDtTm>2023-12-15T07:30:00</CreDtTm>\n    </GrpHdr>\n    <Stmt>\n      <Id>STMT001</Id>\n      <ElctrncSeqNb>235</ElctrncSeqNb>\n      <LglSeqNb>1</LglSeqNb>\n      <CreDtTm>2023-12-15T07:30:00</CreDtTm>\n      <Acct>\n        <Id>\n          <IBAN>BE68539007547034</IBAN>\n        </Id>\n        <Ccy>EUR</Ccy>\n      </Acct>\n      <Bal>\n        <Tp>\n          <CdOrPrtry>\n            <Cd>OPBD</Cd>\n          </CdOrPrtry>\n        </Tp>\n        <Amt Ccy=\"EUR\">125000.00</Amt>\n        <CdtDbtInd>CRDT</CdtDbtInd>\n        <Dt>\n          <Dt>2023-12-14</Dt>\n        </Dt>\n      </Bal>\n      <Ntry>\n        <Amt Ccy=\"EUR\">10000.00</Amt>\n        <CdtDbtInd>CRDT</CdtDbtInd>\n        <Sts>BOOK</Sts>\n        <BookgDt>\n          <Dt>2023-12-15</Dt>\n        </BookgDt>\n        <ValDt>\n          <Dt>2023-12-15</Dt>\n        </ValDt>\n        <NtryDtls>\n          <TxDtls>\n            <Refs>\n              <EndToEndId>REF001</EndToEndId>\n            </Refs>\n            <RmtInf>\n              <Ustrd>PAYMENT FROM CUSTOMER ABC</Ustrd>\n            </RmtInf>\n          </TxDtls>\n        </NtryDtls>\n      </Ntry>\n    </Stmt>\n  </BkToCstmrStmt>\n</Document>"
    }
  ],
  "mt_to_iso20022_mapping": {
    "MT103": "pain.001 / pacs.008",
    "MT101": "pain.001",
    "MT102": "pain.001",
    "MT103+": "pacs.008",
    "MT202": "pacs.009",
    "MT202COV": "pacs.009",
    "MT940": "camt.053",
    "MT942": "camt.052",
    "MT950": "camt.053",
    "MT199": "camt.998",
    "MT299": "camt.998"
  },
  "validation_patterns": [
    {
      "id": "BIC_VALIDATION",
      "description": "Validate BIC/SWIFT code format",
      "pattern": "^[A-Z]{4}[A-Z]{2}[A-Z0-9]{2}([A-Z0-9]{3})?$",
      "java": "public boolean isValidBIC(String bic) {\n    return bic.matches(\"^[A-Z]{4}[A-Z]{2}[A-Z0-9]{2}([A-Z0-9]{3})?$\");\n}",
      "python": "import re\n\ndef is_valid_bic(bic: str) -> bool:\n    pattern = r'^[A-Z]{4}[A-Z]{2}[A-Z0-9]{2}([A-Z0-9]{3})?$'\n    return bool(re.match(pattern, bic))"
    },
    {
      "id": "IBAN_VALIDATION",
      "description": "Validate IBAN with check digit verification",
      "java": "public boolean isValidIBAN(String iban) {\n    String normalized = iban.replaceAll(\"\\\\s\", \"\").toUpperCase();\n    \n    if (normalized.length() < 15 || normalized.length() > 34) {\n        return false;\n    }\n    \n    // Move first 4 chars to end\n    String rearranged = normalized.substring(4) + normalized.substring(0, 4);\n    \n    // Convert letters to numbers (A=10, B=11, etc.)\n    StringBuilder numericIBAN = new StringBuilder();\n    for (char c : rearranged.toCharArray()) {\n        if (Character.isLetter(c)) {\n            numericIBAN.append(Character.getNumericValue(c));\n        } else {\n            numericIBAN.append(c);\n        }\n    }\n    \n    // Mod 97 check\n    BigInteger ibanNum = new BigInteger(numericIBAN.toString());\n    return ibanNum.mod(BigInteger.valueOf(97)).intValue() == 1;\n}",
      "python": "def is_valid_iban(iban: str) -> bool:\n    normalized = iban.replace(' ', '').upper()\n    \n    if len(normalized) < 15 or len(normalized) > 34:\n        return False\n    \n    # Move first 4 chars to end\n    rearranged = normalized[4:] + normalized[:4]\n    \n    # Convert letters to numbers\n    numeric_iban = ''\n    for char in rearranged:\n        if char.isalpha():\n            numeric_iban += str(ord(char) - ord('A') + 10)\n        else:\n            numeric_iban += char\n    \n    # Mod 97 check\n    return int(numeric_iban) % 97 == 1"
    }
  ],
  "currency_codes": {
    "EUR": "Euro",
    "USD": "US Dollar",
    "GBP": "British Pound",
    "JPY": "Japanese Yen",
    "CHF": "Swiss Franc",
    "CAD": "Canadian Dollar",
    "AUD": "Australian Dollar"
  },
  "country_codes": {
    "DE": "Germany",
    "FR": "France",
    "GB": "United Kingdom",
    "US": "United States",
    "CH": "Switzerland",
    "BE": "Belgium",
    "NL": "Netherlands"
  }
}

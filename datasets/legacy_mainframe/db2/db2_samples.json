{
  "metadata": {
    "title": "DB2 DDL and Stored Procedures for Legacy Modernization",
    "version": "1.0.0",
    "description": "Comprehensive DB2 DDL, stored procedures, and triggers with modern equivalents",
    "total_samples": 80,
    "categories": ["ddl", "stored_procedures", "triggers", "indexes", "views"]
  },
  "ddl_samples": [
    {
      "id": "DDL001",
      "name": "Customer Table with Full Constraints",
      "description": "Production-grade customer table definition",
      "db2_ddl": "CREATE TABLE PROD.CUSTOMER (\n    CUST_ID          CHAR(10) NOT NULL,\n    CUST_NAME        VARCHAR(50) NOT NULL,\n    CUST_TYPE        CHAR(1) NOT NULL WITH DEFAULT 'R',\n    CUST_STATUS      CHAR(1) NOT NULL WITH DEFAULT 'A',\n    CUST_SSN         CHAR(9),\n    CUST_DOB         DATE,\n    CUST_BALANCE     DECIMAL(13,2) NOT NULL WITH DEFAULT 0,\n    CUST_CREDIT_LIM  DECIMAL(11,2) NOT NULL WITH DEFAULT 0,\n    CUST_ADDR_LINE1  VARCHAR(100),\n    CUST_ADDR_LINE2  VARCHAR(100),\n    CUST_CITY        CHAR(30),\n    CUST_STATE       CHAR(2),\n    CUST_ZIP         CHAR(10),\n    CUST_COUNTRY     CHAR(3) WITH DEFAULT 'USA',\n    CUST_PHONE       CHAR(15),\n    CUST_EMAIL       VARCHAR(100),\n    CUST_OPEN_DATE   DATE NOT NULL WITH DEFAULT CURRENT DATE,\n    CUST_LAST_ACTIVITY TIMESTAMP,\n    CUST_BRANCH_ID   CHAR(6),\n    CREATED_BY       CHAR(8),\n    CREATED_TS       TIMESTAMP NOT NULL WITH DEFAULT CURRENT TIMESTAMP,\n    UPDATED_BY       CHAR(8),\n    UPDATED_TS       TIMESTAMP,\n    CONSTRAINT CUSTOMER_PK PRIMARY KEY (CUST_ID),\n    CONSTRAINT CUST_TYPE_CHK CHECK (CUST_TYPE IN ('R', 'C', 'P')),\n    CONSTRAINT CUST_STATUS_CHK CHECK (CUST_STATUS IN ('A', 'I', 'C', 'S'))\n) IN DATABASE CUSTDB\n  TABLESPACE CUSTTBS\n  AUDIT CHANGES\n  DATA CAPTURE CHANGES;",
      "modern_postgresql": "CREATE TABLE customer (\n    cust_id          VARCHAR(10) NOT NULL,\n    cust_name        VARCHAR(50) NOT NULL,\n    cust_type        CHAR(1) NOT NULL DEFAULT 'R',\n    cust_status      CHAR(1) NOT NULL DEFAULT 'A',\n    cust_ssn         VARCHAR(9),\n    cust_dob         DATE,\n    cust_balance     NUMERIC(13,2) NOT NULL DEFAULT 0,\n    cust_credit_lim  NUMERIC(11,2) NOT NULL DEFAULT 0,\n    cust_addr_line1  VARCHAR(100),\n    cust_addr_line2  VARCHAR(100),\n    cust_city        VARCHAR(30),\n    cust_state       CHAR(2),\n    cust_zip         VARCHAR(10),\n    cust_country     CHAR(3) DEFAULT 'USA',\n    cust_phone       VARCHAR(15),\n    cust_email       VARCHAR(100),\n    cust_open_date   DATE NOT NULL DEFAULT CURRENT_DATE,\n    cust_last_activity TIMESTAMP,\n    cust_branch_id   VARCHAR(6),\n    created_by       VARCHAR(8),\n    created_ts       TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    updated_by       VARCHAR(8),\n    updated_ts       TIMESTAMP,\n    CONSTRAINT customer_pk PRIMARY KEY (cust_id),\n    CONSTRAINT cust_type_chk CHECK (cust_type IN ('R', 'C', 'P')),\n    CONSTRAINT cust_status_chk CHECK (cust_status IN ('A', 'I', 'C', 'S'))\n);\n\n-- Add audit trigger for DATA CAPTURE CHANGES equivalent\nCREATE TABLE customer_audit (\n    audit_id SERIAL PRIMARY KEY,\n    operation CHAR(1),\n    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    changed_by VARCHAR(50),\n    old_data JSONB,\n    new_data JSONB\n);\n\nCREATE OR REPLACE FUNCTION customer_audit_trigger()\nRETURNS TRIGGER AS $$\nBEGIN\n    IF TG_OP = 'DELETE' THEN\n        INSERT INTO customer_audit (operation, changed_by, old_data)\n        VALUES ('D', current_user, row_to_json(OLD));\n    ELSIF TG_OP = 'UPDATE' THEN\n        INSERT INTO customer_audit (operation, changed_by, old_data, new_data)\n        VALUES ('U', current_user, row_to_json(OLD), row_to_json(NEW));\n    ELSIF TG_OP = 'INSERT' THEN\n        INSERT INTO customer_audit (operation, changed_by, new_data)\n        VALUES ('I', current_user, row_to_json(NEW));\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER customer_audit_trg\nAFTER INSERT OR UPDATE OR DELETE ON customer\nFOR EACH ROW EXECUTE FUNCTION customer_audit_trigger();",
      "jpa_entity": "@Entity\n@Table(name = \"customer\")\n@EntityListeners(AuditingEntityListener.class)\npublic class Customer {\n    @Id\n    @Column(name = \"cust_id\", length = 10)\n    private String custId;\n\n    @Column(name = \"cust_name\", length = 50, nullable = false)\n    private String custName;\n\n    @Column(name = \"cust_type\", length = 1, nullable = false)\n    private Character custType = 'R';\n\n    @Column(name = \"cust_status\", length = 1, nullable = false)\n    private Character custStatus = 'A';\n\n    @Column(name = \"cust_ssn\", length = 9)\n    @Convert(converter = EncryptedStringConverter.class) // For PII protection\n    private String custSsn;\n\n    @Column(name = \"cust_dob\")\n    private LocalDate custDob;\n\n    @Column(name = \"cust_balance\", precision = 13, scale = 2, nullable = false)\n    private BigDecimal custBalance = BigDecimal.ZERO;\n\n    @Column(name = \"cust_credit_lim\", precision = 11, scale = 2, nullable = false)\n    private BigDecimal custCreditLim = BigDecimal.ZERO;\n\n    @Embedded\n    private Address address;\n\n    @Column(name = \"cust_open_date\", nullable = false)\n    private LocalDate custOpenDate = LocalDate.now();\n\n    @Column(name = \"cust_last_activity\")\n    private LocalDateTime custLastActivity;\n\n    @CreatedBy\n    @Column(name = \"created_by\", length = 8)\n    private String createdBy;\n\n    @CreatedDate\n    @Column(name = \"created_ts\", nullable = false)\n    private LocalDateTime createdTs;\n\n    @LastModifiedBy\n    @Column(name = \"updated_by\", length = 8)\n    private String updatedBy;\n\n    @LastModifiedDate\n    @Column(name = \"updated_ts\")\n    private LocalDateTime updatedTs;\n}"
    },
    {
      "id": "DDL002",
      "name": "Account Table with Foreign Key",
      "description": "Account table with customer relationship",
      "db2_ddl": "CREATE TABLE PROD.ACCOUNT (\n    ACCT_ID          CHAR(12) NOT NULL,\n    ACCT_CUST_ID     CHAR(10) NOT NULL,\n    ACCT_TYPE        CHAR(2) NOT NULL,\n    ACCT_STATUS      CHAR(1) NOT NULL WITH DEFAULT 'A',\n    ACCT_BALANCE     DECIMAL(15,2) NOT NULL WITH DEFAULT 0,\n    ACCT_AVAILABLE   DECIMAL(15,2) NOT NULL WITH DEFAULT 0,\n    ACCT_HOLD_AMT    DECIMAL(13,2) NOT NULL WITH DEFAULT 0,\n    ACCT_INT_RATE    DECIMAL(5,4),\n    ACCT_OVERDRAFT_LIM DECIMAL(11,2) WITH DEFAULT 0,\n    ACCT_OPEN_DATE   DATE NOT NULL WITH DEFAULT CURRENT DATE,\n    ACCT_CLOSE_DATE  DATE,\n    ACCT_LAST_INT_DATE DATE,\n    ACCT_LAST_STMT_DATE DATE,\n    ACCT_BRANCH_ID   CHAR(6),\n    ACCT_PRODUCT_CD  CHAR(8),\n    CREATED_TS       TIMESTAMP NOT NULL WITH DEFAULT CURRENT TIMESTAMP,\n    UPDATED_TS       TIMESTAMP,\n    CONSTRAINT ACCOUNT_PK PRIMARY KEY (ACCT_ID),\n    CONSTRAINT ACCT_CUST_FK FOREIGN KEY (ACCT_CUST_ID)\n        REFERENCES PROD.CUSTOMER (CUST_ID)\n        ON DELETE RESTRICT,\n    CONSTRAINT ACCT_TYPE_CHK CHECK (ACCT_TYPE IN ('CK', 'SV', 'MM', 'CD', 'LN', 'CC')),\n    CONSTRAINT ACCT_STATUS_CHK CHECK (ACCT_STATUS IN ('A', 'C', 'F', 'D'))\n) IN DATABASE ACCTDB\n  PARTITION BY RANGE (ACCT_OPEN_DATE)\n  (PARTITION P2020 ENDING ('2020-12-31'),\n   PARTITION P2021 ENDING ('2021-12-31'),\n   PARTITION P2022 ENDING ('2022-12-31'),\n   PARTITION P2023 ENDING ('2023-12-31'),\n   PARTITION PMAX ENDING (MAXVALUE));"
    },
    {
      "id": "DDL003",
      "name": "Transaction Table with Partitioning",
      "description": "High-volume transaction table with date partitioning",
      "db2_ddl": "CREATE TABLE PROD.TRANSACTION (\n    TRANS_ID         CHAR(20) NOT NULL,\n    TRANS_ACCT_ID    CHAR(12) NOT NULL,\n    TRANS_TYPE       CHAR(2) NOT NULL,\n    TRANS_SUBTYPE    CHAR(4),\n    TRANS_AMOUNT     DECIMAL(13,2) NOT NULL,\n    TRANS_DATE       DATE NOT NULL,\n    TRANS_TIME       TIME NOT NULL,\n    TRANS_TIMESTAMP  TIMESTAMP NOT NULL,\n    TRANS_DESC       VARCHAR(100),\n    TRANS_REF_NUM    CHAR(23),\n    TRANS_CHANNEL    CHAR(3) NOT NULL,\n    TRANS_STATUS     CHAR(1) NOT NULL WITH DEFAULT 'P',\n    TRANS_BATCH_ID   CHAR(15),\n    TRANS_TELLER_ID  CHAR(8),\n    TRANS_BRANCH_ID  CHAR(6),\n    TRANS_TERMINAL_ID CHAR(16),\n    TRANS_MERCHANT_ID CHAR(15),\n    TRANS_AUTH_CODE  CHAR(6),\n    TRANS_BALANCE_BEFORE DECIMAL(15,2),\n    TRANS_BALANCE_AFTER DECIMAL(15,2),\n    TRANS_FEE_AMT    DECIMAL(9,2) WITH DEFAULT 0,\n    TRANS_REVERSAL_ID CHAR(20),\n    CREATED_TS       TIMESTAMP NOT NULL WITH DEFAULT CURRENT TIMESTAMP,\n    CONSTRAINT TRANSACTION_PK PRIMARY KEY (TRANS_ID, TRANS_DATE),\n    CONSTRAINT TRANS_ACCT_FK FOREIGN KEY (TRANS_ACCT_ID)\n        REFERENCES PROD.ACCOUNT (ACCT_ID),\n    CONSTRAINT TRANS_TYPE_CHK CHECK (TRANS_TYPE IN ('DP', 'WD', 'TR', 'PY', 'FE', 'IN', 'AJ', 'RV'))\n) IN DATABASE TRANSDB\n  PARTITION BY RANGE (TRANS_DATE)\n  (PARTITION P202301 ENDING ('2023-01-31'),\n   PARTITION P202302 ENDING ('2023-02-28'),\n   PARTITION P202303 ENDING ('2023-03-31'),\n   -- ... additional months\n   PARTITION PMAX ENDING (MAXVALUE))\n  ORGANIZE BY ROW;\n\nCREATE INDEX PROD.TRANS_ACCT_DATE_IX\n    ON PROD.TRANSACTION (TRANS_ACCT_ID, TRANS_DATE DESC)\n    INCLUDE (TRANS_TYPE, TRANS_AMOUNT, TRANS_BALANCE_AFTER);\n\nCREATE INDEX PROD.TRANS_REF_IX\n    ON PROD.TRANSACTION (TRANS_REF_NUM)\n    WHERE TRANS_REF_NUM IS NOT NULL;"
    }
  ],
  "stored_procedures": [
    {
      "id": "SP001",
      "name": "Get Customer with Accounts",
      "description": "Retrieve customer with all accounts and balances",
      "db2_procedure": "CREATE PROCEDURE PROD.GET_CUSTOMER_ACCOUNTS (\n    IN P_CUST_ID CHAR(10),\n    OUT P_CUST_NAME VARCHAR(50),\n    OUT P_CUST_STATUS CHAR(1),\n    OUT P_TOTAL_BALANCE DECIMAL(15,2),\n    OUT P_ACCT_COUNT INTEGER,\n    OUT P_SQLCODE INTEGER,\n    OUT P_SQLSTATE CHAR(5)\n)\nLANGUAGE SQL\nDYNAMIC RESULT SETS 1\nBEGIN\n    DECLARE SQLCODE INTEGER DEFAULT 0;\n    DECLARE SQLSTATE CHAR(5) DEFAULT '00000';\n    DECLARE v_cursor CURSOR WITH RETURN FOR\n        SELECT A.ACCT_ID, A.ACCT_TYPE, A.ACCT_STATUS,\n               A.ACCT_BALANCE, A.ACCT_AVAILABLE,\n               A.ACCT_OPEN_DATE, A.ACCT_LAST_INT_DATE\n        FROM PROD.ACCOUNT A\n        WHERE A.ACCT_CUST_ID = P_CUST_ID\n          AND A.ACCT_STATUS <> 'C'\n        ORDER BY A.ACCT_TYPE, A.ACCT_OPEN_DATE;\n\n    -- Get customer info\n    SELECT CUST_NAME, CUST_STATUS\n    INTO P_CUST_NAME, P_CUST_STATUS\n    FROM PROD.CUSTOMER\n    WHERE CUST_ID = P_CUST_ID;\n\n    -- Get account summary\n    SELECT COALESCE(SUM(ACCT_BALANCE), 0), COUNT(*)\n    INTO P_TOTAL_BALANCE, P_ACCT_COUNT\n    FROM PROD.ACCOUNT\n    WHERE ACCT_CUST_ID = P_CUST_ID\n      AND ACCT_STATUS <> 'C';\n\n    SET P_SQLCODE = SQLCODE;\n    SET P_SQLSTATE = SQLSTATE;\n\n    OPEN v_cursor;\nEND;",
      "modern_equivalent": {
        "spring_data_jpa": "@Repository\npublic interface CustomerRepository extends JpaRepository<Customer, String> {\n    \n    @Query(\"\"\"\n        SELECT new com.bank.dto.CustomerAccountSummary(\n            c.custId, c.custName, c.custStatus,\n            COALESCE(SUM(a.acctBalance), 0), COUNT(a))\n        FROM Customer c\n        LEFT JOIN Account a ON a.customer = c AND a.acctStatus <> 'C'\n        WHERE c.custId = :custId\n        GROUP BY c.custId, c.custName, c.custStatus\n    \"\"\")\n    Optional<CustomerAccountSummary> findCustomerWithAccountSummary(\n        @Param(\"custId\") String custId);\n    \n    @Query(\"\"\"\n        SELECT a FROM Account a\n        WHERE a.customer.custId = :custId\n          AND a.acctStatus <> 'C'\n        ORDER BY a.acctType, a.acctOpenDate\n    \"\"\")\n    List<Account> findActiveAccountsByCustomerId(@Param(\"custId\") String custId);\n}",
        "service_layer": "@Service\n@Transactional(readOnly = true)\npublic class CustomerAccountService {\n    \n    @Autowired\n    private CustomerRepository customerRepository;\n    \n    public CustomerAccountsDTO getCustomerWithAccounts(String custId) {\n        CustomerAccountSummary summary = customerRepository\n            .findCustomerWithAccountSummary(custId)\n            .orElseThrow(() -> new CustomerNotFoundException(custId));\n        \n        List<Account> accounts = customerRepository\n            .findActiveAccountsByCustomerId(custId);\n        \n        return new CustomerAccountsDTO(summary, accounts);\n    }\n}"
      }
    },
    {
      "id": "SP002",
      "name": "Transfer Funds",
      "description": "Transfer funds between accounts with validation",
      "db2_procedure": "CREATE PROCEDURE PROD.TRANSFER_FUNDS (\n    IN P_FROM_ACCT CHAR(12),\n    IN P_TO_ACCT CHAR(12),\n    IN P_AMOUNT DECIMAL(13,2),\n    IN P_DESCRIPTION VARCHAR(100),\n    IN P_USER_ID CHAR(8),\n    OUT P_TRANS_ID CHAR(20),\n    OUT P_RESULT_CODE CHAR(4),\n    OUT P_RESULT_MSG VARCHAR(200)\n)\nLANGUAGE SQL\nBEGIN\n    DECLARE SQLCODE INTEGER DEFAULT 0;\n    DECLARE v_from_balance DECIMAL(15,2);\n    DECLARE v_from_available DECIMAL(15,2);\n    DECLARE v_from_status CHAR(1);\n    DECLARE v_to_status CHAR(1);\n    DECLARE v_from_new_balance DECIMAL(15,2);\n    DECLARE v_to_new_balance DECIMAL(15,2);\n    DECLARE v_timestamp TIMESTAMP;\n    DECLARE EXIT HANDLER FOR SQLEXCEPTION\n    BEGIN\n        SET P_RESULT_CODE = 'E999';\n        SET P_RESULT_MSG = 'Database error occurred';\n        ROLLBACK;\n    END;\n\n    SET v_timestamp = CURRENT TIMESTAMP;\n    SET P_TRANS_ID = 'TRF' || \n        SUBSTR(CHAR(v_timestamp, ISO), 1, 10) ||\n        RIGHT('000000' || CHAR(RAND() * 999999), 6);\n\n    -- Validate amount\n    IF P_AMOUNT <= 0 THEN\n        SET P_RESULT_CODE = 'E001';\n        SET P_RESULT_MSG = 'Invalid transfer amount';\n        RETURN;\n    END IF;\n\n    -- Lock and validate source account\n    SELECT ACCT_BALANCE, ACCT_AVAILABLE, ACCT_STATUS\n    INTO v_from_balance, v_from_available, v_from_status\n    FROM PROD.ACCOUNT\n    WHERE ACCT_ID = P_FROM_ACCT\n    FOR UPDATE;\n\n    IF SQLCODE = 100 THEN\n        SET P_RESULT_CODE = 'E002';\n        SET P_RESULT_MSG = 'Source account not found';\n        RETURN;\n    END IF;\n\n    IF v_from_status <> 'A' THEN\n        SET P_RESULT_CODE = 'E003';\n        SET P_RESULT_MSG = 'Source account is not active';\n        RETURN;\n    END IF;\n\n    IF v_from_available < P_AMOUNT THEN\n        SET P_RESULT_CODE = 'E004';\n        SET P_RESULT_MSG = 'Insufficient available balance';\n        RETURN;\n    END IF;\n\n    -- Validate destination account\n    SELECT ACCT_STATUS\n    INTO v_to_status\n    FROM PROD.ACCOUNT\n    WHERE ACCT_ID = P_TO_ACCT\n    FOR UPDATE;\n\n    IF SQLCODE = 100 THEN\n        SET P_RESULT_CODE = 'E005';\n        SET P_RESULT_MSG = 'Destination account not found';\n        RETURN;\n    END IF;\n\n    IF v_to_status <> 'A' THEN\n        SET P_RESULT_CODE = 'E006';\n        SET P_RESULT_MSG = 'Destination account is not active';\n        RETURN;\n    END IF;\n\n    -- Perform transfer\n    SET v_from_new_balance = v_from_balance - P_AMOUNT;\n    \n    UPDATE PROD.ACCOUNT\n    SET ACCT_BALANCE = ACCT_BALANCE - P_AMOUNT,\n        ACCT_AVAILABLE = ACCT_AVAILABLE - P_AMOUNT,\n        UPDATED_TS = v_timestamp\n    WHERE ACCT_ID = P_FROM_ACCT;\n\n    SELECT ACCT_BALANCE + P_AMOUNT\n    INTO v_to_new_balance\n    FROM PROD.ACCOUNT\n    WHERE ACCT_ID = P_TO_ACCT;\n\n    UPDATE PROD.ACCOUNT\n    SET ACCT_BALANCE = ACCT_BALANCE + P_AMOUNT,\n        ACCT_AVAILABLE = ACCT_AVAILABLE + P_AMOUNT,\n        UPDATED_TS = v_timestamp\n    WHERE ACCT_ID = P_TO_ACCT;\n\n    -- Record debit transaction\n    INSERT INTO PROD.TRANSACTION (\n        TRANS_ID, TRANS_ACCT_ID, TRANS_TYPE, TRANS_AMOUNT,\n        TRANS_DATE, TRANS_TIME, TRANS_TIMESTAMP,\n        TRANS_DESC, TRANS_REF_NUM, TRANS_CHANNEL, TRANS_STATUS,\n        TRANS_BALANCE_BEFORE, TRANS_BALANCE_AFTER\n    ) VALUES (\n        P_TRANS_ID || 'D', P_FROM_ACCT, 'TR', P_AMOUNT,\n        CURRENT DATE, CURRENT TIME, v_timestamp,\n        'TRANSFER TO ' || P_TO_ACCT || ' - ' || P_DESCRIPTION,\n        P_TRANS_ID, 'INT', 'P',\n        v_from_balance, v_from_new_balance\n    );\n\n    -- Record credit transaction\n    INSERT INTO PROD.TRANSACTION (\n        TRANS_ID, TRANS_ACCT_ID, TRANS_TYPE, TRANS_AMOUNT,\n        TRANS_DATE, TRANS_TIME, TRANS_TIMESTAMP,\n        TRANS_DESC, TRANS_REF_NUM, TRANS_CHANNEL, TRANS_STATUS,\n        TRANS_BALANCE_BEFORE, TRANS_BALANCE_AFTER\n    ) VALUES (\n        P_TRANS_ID || 'C', P_TO_ACCT, 'TR', P_AMOUNT,\n        CURRENT DATE, CURRENT TIME, v_timestamp,\n        'TRANSFER FROM ' || P_FROM_ACCT || ' - ' || P_DESCRIPTION,\n        P_TRANS_ID, 'INT', 'P',\n        v_to_new_balance - P_AMOUNT, v_to_new_balance\n    );\n\n    -- Update customer activity\n    UPDATE PROD.CUSTOMER\n    SET CUST_LAST_ACTIVITY = v_timestamp\n    WHERE CUST_ID IN (\n        SELECT ACCT_CUST_ID FROM PROD.ACCOUNT\n        WHERE ACCT_ID IN (P_FROM_ACCT, P_TO_ACCT)\n    );\n\n    SET P_RESULT_CODE = '0000';\n    SET P_RESULT_MSG = 'Transfer successful';\n    COMMIT;\nEND;",
      "modern_equivalent": {
        "spring_service": "@Service\n@Slf4j\npublic class FundTransferService {\n    \n    @Autowired\n    private AccountRepository accountRepository;\n    \n    @Autowired\n    private TransactionRepository transactionRepository;\n    \n    @Autowired\n    private CustomerRepository customerRepository;\n    \n    @Transactional(isolation = Isolation.SERIALIZABLE)\n    public TransferResult transferFunds(TransferRequest request) {\n        String transId = generateTransactionId();\n        LocalDateTime timestamp = LocalDateTime.now();\n        \n        // Validate amount\n        if (request.getAmount().compareTo(BigDecimal.ZERO) <= 0) {\n            return TransferResult.error(\"E001\", \"Invalid transfer amount\");\n        }\n        \n        // Lock and validate source account\n        Account fromAccount = accountRepository\n            .findByIdForUpdate(request.getFromAccount())\n            .orElseThrow(() -> new AccountNotFoundException(\n                \"E002\", \"Source account not found\"));\n        \n        if (!fromAccount.isActive()) {\n            return TransferResult.error(\"E003\", \"Source account is not active\");\n        }\n        \n        if (fromAccount.getAvailableBalance().compareTo(request.getAmount()) < 0) {\n            return TransferResult.error(\"E004\", \"Insufficient available balance\");\n        }\n        \n        // Validate destination account\n        Account toAccount = accountRepository\n            .findByIdForUpdate(request.getToAccount())\n            .orElseThrow(() -> new AccountNotFoundException(\n                \"E005\", \"Destination account not found\"));\n        \n        if (!toAccount.isActive()) {\n            return TransferResult.error(\"E006\", \"Destination account is not active\");\n        }\n        \n        // Perform transfer\n        BigDecimal fromBalanceBefore = fromAccount.getBalance();\n        BigDecimal toBalanceBefore = toAccount.getBalance();\n        \n        fromAccount.debit(request.getAmount());\n        toAccount.credit(request.getAmount());\n        \n        // Record transactions\n        Transaction debitTrans = Transaction.builder()\n            .transId(transId + \"D\")\n            .account(fromAccount)\n            .transType(TransactionType.TRANSFER)\n            .amount(request.getAmount().negate())\n            .timestamp(timestamp)\n            .description(\"TRANSFER TO \" + toAccount.getId())\n            .refNum(transId)\n            .balanceBefore(fromBalanceBefore)\n            .balanceAfter(fromAccount.getBalance())\n            .build();\n        \n        Transaction creditTrans = Transaction.builder()\n            .transId(transId + \"C\")\n            .account(toAccount)\n            .transType(TransactionType.TRANSFER)\n            .amount(request.getAmount())\n            .timestamp(timestamp)\n            .description(\"TRANSFER FROM \" + fromAccount.getId())\n            .refNum(transId)\n            .balanceBefore(toBalanceBefore)\n            .balanceAfter(toAccount.getBalance())\n            .build();\n        \n        transactionRepository.saveAll(List.of(debitTrans, creditTrans));\n        \n        // Update customer activity\n        Set<String> customerIds = Set.of(\n            fromAccount.getCustomerId(),\n            toAccount.getCustomerId()\n        );\n        customerRepository.updateLastActivity(customerIds, timestamp);\n        \n        log.info(\"Transfer completed: {} from {} to {} amount {}\",\n            transId, fromAccount.getId(), toAccount.getId(), request.getAmount());\n        \n        return TransferResult.success(transId, \"Transfer successful\");\n    }\n}"
      }
    },
    {
      "id": "SP003",
      "name": "Calculate Interest",
      "description": "Monthly interest calculation for savings accounts",
      "db2_procedure": "CREATE PROCEDURE PROD.CALCULATE_MONTHLY_INTEREST (\n    IN P_PROCESS_DATE DATE,\n    OUT P_ACCOUNTS_PROCESSED INTEGER,\n    OUT P_TOTAL_INTEREST DECIMAL(15,2),\n    OUT P_RESULT_CODE CHAR(4)\n)\nLANGUAGE SQL\nBEGIN\n    DECLARE SQLCODE INTEGER DEFAULT 0;\n    DECLARE v_acct_id CHAR(12);\n    DECLARE v_balance DECIMAL(15,2);\n    DECLARE v_rate DECIMAL(5,4);\n    DECLARE v_interest DECIMAL(13,2);\n    DECLARE v_days INTEGER;\n    DECLARE v_last_int_date DATE;\n    DECLARE v_done INTEGER DEFAULT 0;\n    DECLARE c_accounts CURSOR FOR\n        SELECT ACCT_ID, ACCT_BALANCE, ACCT_INT_RATE, ACCT_LAST_INT_DATE\n        FROM PROD.ACCOUNT\n        WHERE ACCT_TYPE IN ('SV', 'MM', 'CD')\n          AND ACCT_STATUS = 'A'\n          AND ACCT_BALANCE > 0\n          AND (ACCT_LAST_INT_DATE IS NULL\n               OR ACCT_LAST_INT_DATE < P_PROCESS_DATE);\n    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1;\n\n    SET P_ACCOUNTS_PROCESSED = 0;\n    SET P_TOTAL_INTEREST = 0;\n\n    OPEN c_accounts;\n    \n    fetch_loop: LOOP\n        FETCH c_accounts INTO v_acct_id, v_balance, v_rate, v_last_int_date;\n        IF v_done = 1 THEN\n            LEAVE fetch_loop;\n        END IF;\n\n        -- Calculate days since last interest\n        IF v_last_int_date IS NULL THEN\n            SET v_days = 30;  -- Default to 30 days for first calculation\n        ELSE\n            SET v_days = DAYS(P_PROCESS_DATE) - DAYS(v_last_int_date);\n        END IF;\n\n        -- Calculate interest (daily rate * days * balance)\n        SET v_interest = ROUND(v_balance * (v_rate / 365) * v_days, 2);\n\n        IF v_interest > 0 THEN\n            -- Credit interest to account\n            UPDATE PROD.ACCOUNT\n            SET ACCT_BALANCE = ACCT_BALANCE + v_interest,\n                ACCT_AVAILABLE = ACCT_AVAILABLE + v_interest,\n                ACCT_LAST_INT_DATE = P_PROCESS_DATE,\n                UPDATED_TS = CURRENT TIMESTAMP\n            WHERE ACCT_ID = v_acct_id;\n\n            -- Record interest transaction\n            INSERT INTO PROD.TRANSACTION (\n                TRANS_ID, TRANS_ACCT_ID, TRANS_TYPE, TRANS_AMOUNT,\n                TRANS_DATE, TRANS_TIME, TRANS_TIMESTAMP,\n                TRANS_DESC, TRANS_CHANNEL, TRANS_STATUS,\n                TRANS_BATCH_ID\n            ) VALUES (\n                'INT' || CHAR(P_PROCESS_DATE, ISO) || \n                    RIGHT('000000' || CHAR(P_ACCOUNTS_PROCESSED), 6),\n                v_acct_id, 'IN', v_interest,\n                P_PROCESS_DATE, CURRENT TIME, CURRENT TIMESTAMP,\n                'MONTHLY INTEREST - ' || CHAR(v_days) || ' DAYS @ ' ||\n                    CHAR(v_rate * 100) || '%',\n                'BAT', 'P',\n                'INTCALC' || CHAR(P_PROCESS_DATE, ISO)\n            );\n\n            SET P_ACCOUNTS_PROCESSED = P_ACCOUNTS_PROCESSED + 1;\n            SET P_TOTAL_INTEREST = P_TOTAL_INTEREST + v_interest;\n        END IF;\n    END LOOP;\n\n    CLOSE c_accounts;\n    SET P_RESULT_CODE = '0000';\n    COMMIT;\nEND;"
    },
    {
      "id": "SP004",
      "name": "End of Day Processing",
      "description": "Batch end-of-day account processing",
      "db2_procedure": "CREATE PROCEDURE PROD.EOD_PROCESSING (\n    IN P_BUSINESS_DATE DATE,\n    OUT P_RESULT_CODE CHAR(4),\n    OUT P_RESULT_MSG VARCHAR(500)\n)\nLANGUAGE SQL\nBEGIN\n    DECLARE SQLCODE INTEGER DEFAULT 0;\n    DECLARE v_step INTEGER DEFAULT 0;\n    DECLARE v_count INTEGER;\n    DECLARE EXIT HANDLER FOR SQLEXCEPTION\n    BEGIN\n        SET P_RESULT_CODE = 'E' || RIGHT('000' || CHAR(v_step), 3);\n        SET P_RESULT_MSG = 'Error at step ' || CHAR(v_step) || \n                          ': SQLCODE=' || CHAR(SQLCODE);\n        ROLLBACK;\n    END;\n\n    -- Step 1: Update account holds that have expired\n    SET v_step = 1;\n    UPDATE PROD.ACCOUNT\n    SET ACCT_HOLD_AMT = 0,\n        ACCT_AVAILABLE = ACCT_BALANCE,\n        UPDATED_TS = CURRENT TIMESTAMP\n    WHERE ACCT_HOLD_AMT > 0\n      AND EXISTS (\n          SELECT 1 FROM PROD.ACCOUNT_HOLD\n          WHERE HOLD_ACCT_ID = ACCT_ID\n            AND HOLD_EXPIRE_DATE <= P_BUSINESS_DATE\n      );\n    GET DIAGNOSTICS v_count = ROW_COUNT;\n    SET P_RESULT_MSG = 'Step 1: ' || CHAR(v_count) || ' holds released. ';\n\n    -- Step 2: Mark dormant accounts\n    SET v_step = 2;\n    UPDATE PROD.ACCOUNT\n    SET ACCT_STATUS = 'D',\n        UPDATED_TS = CURRENT TIMESTAMP\n    WHERE ACCT_STATUS = 'A'\n      AND ACCT_TYPE NOT IN ('LN', 'CC')\n      AND NOT EXISTS (\n          SELECT 1 FROM PROD.TRANSACTION\n          WHERE TRANS_ACCT_ID = ACCT_ID\n            AND TRANS_DATE > P_BUSINESS_DATE - 365 DAYS\n            AND TRANS_TYPE NOT IN ('FE', 'IN')\n      );\n    GET DIAGNOSTICS v_count = ROW_COUNT;\n    SET P_RESULT_MSG = P_RESULT_MSG || 'Step 2: ' || CHAR(v_count) || ' dormant. ';\n\n    -- Step 3: Calculate and post overdraft fees\n    SET v_step = 3;\n    INSERT INTO PROD.TRANSACTION (\n        TRANS_ID, TRANS_ACCT_ID, TRANS_TYPE, TRANS_AMOUNT,\n        TRANS_DATE, TRANS_TIME, TRANS_TIMESTAMP,\n        TRANS_DESC, TRANS_CHANNEL, TRANS_STATUS, TRANS_BATCH_ID\n    )\n    SELECT \n        'ODF' || CHAR(P_BUSINESS_DATE, ISO) || RIGHT('000000' || \n            CHAR(ROW_NUMBER() OVER (ORDER BY ACCT_ID)), 6),\n        ACCT_ID, 'FE', 35.00,\n        P_BUSINESS_DATE, CURRENT TIME, CURRENT TIMESTAMP,\n        'OVERDRAFT FEE', 'BAT', 'P',\n        'EODPROC' || CHAR(P_BUSINESS_DATE, ISO)\n    FROM PROD.ACCOUNT\n    WHERE ACCT_TYPE = 'CK'\n      AND ACCT_BALANCE < 0\n      AND ACCT_STATUS = 'A';\n    GET DIAGNOSTICS v_count = ROW_COUNT;\n    SET P_RESULT_MSG = P_RESULT_MSG || 'Step 3: ' || CHAR(v_count) || ' OD fees. ';\n\n    -- Step 4: Update balances for overdraft fees\n    SET v_step = 4;\n    UPDATE PROD.ACCOUNT A\n    SET ACCT_BALANCE = ACCT_BALANCE - 35.00,\n        UPDATED_TS = CURRENT TIMESTAMP\n    WHERE ACCT_TYPE = 'CK'\n      AND ACCT_BALANCE < 0\n      AND ACCT_STATUS = 'A';\n\n    -- Step 5: Archive old transactions\n    SET v_step = 5;\n    INSERT INTO PROD.TRANSACTION_ARCHIVE\n    SELECT * FROM PROD.TRANSACTION\n    WHERE TRANS_DATE < P_BUSINESS_DATE - 7 YEARS;\n    GET DIAGNOSTICS v_count = ROW_COUNT;\n    SET P_RESULT_MSG = P_RESULT_MSG || 'Step 5: ' || CHAR(v_count) || ' archived. ';\n\n    DELETE FROM PROD.TRANSACTION\n    WHERE TRANS_DATE < P_BUSINESS_DATE - 7 YEARS;\n\n    SET P_RESULT_CODE = '0000';\n    COMMIT;\nEND;"
    }
  ],
  "triggers": [
    {
      "id": "TRG001",
      "name": "Customer Audit Trigger",
      "description": "Audit trail for customer table changes",
      "db2_trigger": "CREATE TRIGGER PROD.CUSTOMER_AUDIT_TRG\nAFTER UPDATE ON PROD.CUSTOMER\nREFERENCING OLD AS O NEW AS N\nFOR EACH ROW\nMODE DB2SQL\nBEGIN ATOMIC\n    INSERT INTO PROD.CUSTOMER_AUDIT (\n        AUDIT_TIMESTAMP, AUDIT_TYPE, AUDIT_USER,\n        CUST_ID, FIELD_NAME, OLD_VALUE, NEW_VALUE\n    )\n    SELECT CURRENT TIMESTAMP, 'U', SESSION_USER,\n           O.CUST_ID, 'CUST_STATUS', O.CUST_STATUS, N.CUST_STATUS\n    FROM SYSIBM.SYSDUMMY1\n    WHERE O.CUST_STATUS <> N.CUST_STATUS\n    UNION ALL\n    SELECT CURRENT TIMESTAMP, 'U', SESSION_USER,\n           O.CUST_ID, 'CUST_BALANCE', CHAR(O.CUST_BALANCE), CHAR(N.CUST_BALANCE)\n    FROM SYSIBM.SYSDUMMY1\n    WHERE O.CUST_BALANCE <> N.CUST_BALANCE\n    UNION ALL\n    SELECT CURRENT TIMESTAMP, 'U', SESSION_USER,\n           O.CUST_ID, 'CUST_CREDIT_LIM', CHAR(O.CUST_CREDIT_LIM), CHAR(N.CUST_CREDIT_LIM)\n    FROM SYSIBM.SYSDUMMY1\n    WHERE O.CUST_CREDIT_LIM <> N.CUST_CREDIT_LIM;\nEND;",
      "modern_jpa_equivalent": "@Entity\n@EntityListeners(AuditingEntityListener.class)\npublic class Customer {\n    // ... fields ...\n    \n    @PreUpdate\n    public void preUpdate() {\n        // JPA Auditing handles this\n    }\n}\n\n// Or use Hibernate Envers for full audit trail\n@Entity\n@Audited\npublic class Customer {\n    // All changes automatically tracked in _AUD table\n}"
    },
    {
      "id": "TRG002",
      "name": "Transaction Balance Update Trigger",
      "description": "Update account balance on transaction insert",
      "db2_trigger": "CREATE TRIGGER PROD.TRANS_BALANCE_TRG\nAFTER INSERT ON PROD.TRANSACTION\nREFERENCING NEW AS N\nFOR EACH ROW\nMODE DB2SQL\nWHEN (N.TRANS_STATUS = 'P' AND N.TRANS_TYPE NOT IN ('IN', 'FE'))\nBEGIN ATOMIC\n    UPDATE PROD.ACCOUNT\n    SET ACCT_BALANCE = CASE \n            WHEN N.TRANS_TYPE IN ('DP', 'TR') AND N.TRANS_AMOUNT > 0 \n                THEN ACCT_BALANCE + N.TRANS_AMOUNT\n            WHEN N.TRANS_TYPE IN ('WD', 'PY') OR N.TRANS_AMOUNT < 0\n                THEN ACCT_BALANCE - ABS(N.TRANS_AMOUNT)\n            ELSE ACCT_BALANCE\n        END,\n        ACCT_AVAILABLE = CASE \n            WHEN N.TRANS_TYPE IN ('DP', 'TR') AND N.TRANS_AMOUNT > 0 \n                THEN ACCT_AVAILABLE + N.TRANS_AMOUNT\n            WHEN N.TRANS_TYPE IN ('WD', 'PY') OR N.TRANS_AMOUNT < 0\n                THEN ACCT_AVAILABLE - ABS(N.TRANS_AMOUNT)\n            ELSE ACCT_AVAILABLE\n        END,\n        UPDATED_TS = CURRENT TIMESTAMP\n    WHERE ACCT_ID = N.TRANS_ACCT_ID;\nEND;"
    }
  ],
  "indexes": [
    {
      "id": "IDX001",
      "name": "Customer Search Indexes",
      "description": "Optimized indexes for customer lookup",
      "db2_indexes": "-- Primary key index (automatically created)\n-- CREATE UNIQUE INDEX PROD.CUSTOMER_PK_IX ON PROD.CUSTOMER (CUST_ID);\n\n-- Name search index\nCREATE INDEX PROD.CUSTOMER_NAME_IX\n    ON PROD.CUSTOMER (CUST_NAME)\n    INCLUDE (CUST_ID, CUST_STATUS, CUST_TYPE)\n    ALLOW REVERSE SCANS;\n\n-- SSN lookup (encrypted in production)\nCREATE UNIQUE INDEX PROD.CUSTOMER_SSN_IX\n    ON PROD.CUSTOMER (CUST_SSN)\n    WHERE CUST_SSN IS NOT NULL\n    EXCLUDE NULL KEYS;\n\n-- Status filtering\nCREATE INDEX PROD.CUSTOMER_STATUS_IX\n    ON PROD.CUSTOMER (CUST_STATUS, CUST_TYPE)\n    INCLUDE (CUST_ID, CUST_NAME)\n    CLUSTER;\n\n-- Branch lookup\nCREATE INDEX PROD.CUSTOMER_BRANCH_IX\n    ON PROD.CUSTOMER (CUST_BRANCH_ID, CUST_STATUS)\n    INCLUDE (CUST_ID, CUST_NAME, CUST_BALANCE);",
      "postgresql_equivalent": "-- Name search with trigram for fuzzy matching\nCREATE EXTENSION IF NOT EXISTS pg_trgm;\n\nCREATE INDEX customer_name_ix ON customer (cust_name);\nCREATE INDEX customer_name_trgm_ix ON customer \n    USING gin (cust_name gin_trgm_ops);\n\n-- SSN lookup\nCREATE UNIQUE INDEX customer_ssn_ix ON customer (cust_ssn)\n    WHERE cust_ssn IS NOT NULL;\n\n-- Status filtering\nCREATE INDEX customer_status_ix ON customer (cust_status, cust_type)\n    INCLUDE (cust_id, cust_name);\n\n-- Branch lookup\nCREATE INDEX customer_branch_ix ON customer (cust_branch_id, cust_status)\n    INCLUDE (cust_id, cust_name, cust_balance);"
    }
  ],
  "views": [
    {
      "id": "VW001",
      "name": "Customer Summary View",
      "description": "Aggregated customer view with account totals",
      "db2_view": "CREATE VIEW PROD.V_CUSTOMER_SUMMARY AS\nSELECT \n    C.CUST_ID,\n    C.CUST_NAME,\n    C.CUST_TYPE,\n    C.CUST_STATUS,\n    C.CUST_OPEN_DATE,\n    C.CUST_BRANCH_ID,\n    COUNT(A.ACCT_ID) AS TOTAL_ACCOUNTS,\n    SUM(CASE WHEN A.ACCT_STATUS = 'A' THEN 1 ELSE 0 END) AS ACTIVE_ACCOUNTS,\n    COALESCE(SUM(CASE WHEN A.ACCT_TYPE IN ('CK', 'SV', 'MM') \n                      THEN A.ACCT_BALANCE ELSE 0 END), 0) AS DEPOSIT_BALANCE,\n    COALESCE(SUM(CASE WHEN A.ACCT_TYPE IN ('LN', 'CC') \n                      THEN A.ACCT_BALANCE ELSE 0 END), 0) AS LOAN_BALANCE,\n    COALESCE(SUM(A.ACCT_BALANCE), 0) AS TOTAL_BALANCE,\n    MAX(A.ACCT_OPEN_DATE) AS LAST_ACCOUNT_OPEN,\n    C.CUST_LAST_ACTIVITY\nFROM PROD.CUSTOMER C\nLEFT JOIN PROD.ACCOUNT A ON C.CUST_ID = A.ACCT_CUST_ID\nGROUP BY \n    C.CUST_ID, C.CUST_NAME, C.CUST_TYPE, C.CUST_STATUS,\n    C.CUST_OPEN_DATE, C.CUST_BRANCH_ID, C.CUST_LAST_ACTIVITY;",
      "jpa_projection": "public interface CustomerSummaryProjection {\n    String getCustId();\n    String getCustName();\n    Character getCustType();\n    Character getCustStatus();\n    LocalDate getCustOpenDate();\n    String getCustBranchId();\n    Long getTotalAccounts();\n    Long getActiveAccounts();\n    BigDecimal getDepositBalance();\n    BigDecimal getLoanBalance();\n    BigDecimal getTotalBalance();\n    LocalDate getLastAccountOpen();\n    LocalDateTime getCustLastActivity();\n}"
    }
  ]
}

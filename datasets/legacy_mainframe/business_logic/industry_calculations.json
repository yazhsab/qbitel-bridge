{
  "metadata": {
    "title": "Industry-Specific Business Logic Patterns",
    "version": "1.0.0",
    "description": "Banking, insurance, and financial calculation patterns with modern equivalents",
    "industries": ["Banking", "Insurance", "Finance", "Healthcare"],
    "total_patterns": 50
  },
  "banking_calculations": [
    {
      "id": "BANK001",
      "name": "Simple Interest Calculation",
      "description": "Calculate simple interest on principal",
      "formula": "Interest = Principal * Rate * Time",
      "cobol": "       WORKING-STORAGE SECTION.\n       01  WS-PRINCIPAL        PIC 9(11)V99.\n       01  WS-RATE             PIC 9(3)V9(6).\n       01  WS-TIME-YEARS       PIC 9(3)V99.\n       01  WS-INTEREST         PIC 9(13)V99.\n       \n       PROCEDURE DIVISION.\n           COMPUTE WS-INTEREST ROUNDED = \n               WS-PRINCIPAL * WS-RATE * WS-TIME-YEARS\n           END-COMPUTE.",
      "java": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class InterestCalculator {\n    public static BigDecimal simpleInterest(\n            BigDecimal principal,\n            BigDecimal annualRate,\n            BigDecimal years) {\n        return principal\n            .multiply(annualRate)\n            .multiply(years)\n            .setScale(2, RoundingMode.HALF_UP);\n    }\n}",
      "python": "from decimal import Decimal, ROUND_HALF_UP\n\ndef simple_interest(\n    principal: Decimal,\n    annual_rate: Decimal,\n    years: Decimal\n) -> Decimal:\n    interest = principal * annual_rate * years\n    return interest.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)"
    },
    {
      "id": "BANK002",
      "name": "Compound Interest Calculation",
      "description": "Calculate compound interest with periodic compounding",
      "formula": "A = P(1 + r/n)^(nt) where n = compounding frequency",
      "cobol": "       WORKING-STORAGE SECTION.\n       01  WS-PRINCIPAL        PIC 9(11)V99.\n       01  WS-RATE             PIC 9(3)V9(6).\n       01  WS-TIME-YEARS       PIC 9(3).\n       01  WS-COMPOUND-FREQ    PIC 9(3).    *> 12=monthly, 4=quarterly\n       01  WS-FINAL-AMOUNT     PIC 9(15)V99.\n       01  WS-RATE-PER-PERIOD  PIC 9(3)V9(8).\n       01  WS-TOTAL-PERIODS    PIC 9(6).\n       01  WS-GROWTH-FACTOR    PIC 9(5)V9(10).\n       \n       PROCEDURE DIVISION.\n           COMPUTE WS-RATE-PER-PERIOD = \n               WS-RATE / WS-COMPOUND-FREQ\n           END-COMPUTE\n           \n           COMPUTE WS-TOTAL-PERIODS = \n               WS-COMPOUND-FREQ * WS-TIME-YEARS\n           END-COMPUTE\n           \n           COMPUTE WS-GROWTH-FACTOR = \n               (1 + WS-RATE-PER-PERIOD) ** WS-TOTAL-PERIODS\n           END-COMPUTE\n           \n           COMPUTE WS-FINAL-AMOUNT ROUNDED = \n               WS-PRINCIPAL * WS-GROWTH-FACTOR\n           END-COMPUTE.",
      "java": "public static BigDecimal compoundInterest(\n        BigDecimal principal,\n        BigDecimal annualRate,\n        int years,\n        int compoundingFrequency) {\n    \n    BigDecimal ratePerPeriod = annualRate.divide(\n        BigDecimal.valueOf(compoundingFrequency),\n        10,\n        RoundingMode.HALF_UP\n    );\n    \n    int totalPeriods = compoundingFrequency * years;\n    \n    BigDecimal growthFactor = ratePerPeriod\n        .add(BigDecimal.ONE)\n        .pow(totalPeriods);\n    \n    return principal\n        .multiply(growthFactor)\n        .setScale(2, RoundingMode.HALF_UP);\n}",
      "python": "def compound_interest(\n    principal: Decimal,\n    annual_rate: Decimal,\n    years: int,\n    compounding_frequency: int = 12\n) -> Decimal:\n    rate_per_period = annual_rate / compounding_frequency\n    total_periods = compounding_frequency * years\n    growth_factor = (1 + rate_per_period) ** total_periods\n    return (principal * Decimal(str(growth_factor))).quantize(\n        Decimal('0.01'), rounding=ROUND_HALF_UP\n    )"
    },
    {
      "id": "BANK003",
      "name": "Loan Amortization",
      "description": "Calculate monthly payment and amortization schedule",
      "formula": "PMT = P * [r(1+r)^n] / [(1+r)^n - 1]",
      "cobol": "       WORKING-STORAGE SECTION.\n       01  WS-LOAN-AMOUNT      PIC 9(11)V99.\n       01  WS-ANNUAL-RATE      PIC 9(3)V9(6).\n       01  WS-TERM-MONTHS      PIC 9(4).\n       01  WS-MONTHLY-RATE     PIC 9(3)V9(8).\n       01  WS-MONTHLY-PAYMENT  PIC 9(9)V99.\n       01  WS-RATE-FACTOR      PIC 9(5)V9(10).\n       01  WS-AMORT-TABLE.\n           05  WS-AMORT-ENTRY OCCURS 360 TIMES.\n               10  WS-PAYMENT-NUM    PIC 9(4).\n               10  WS-PAYMENT-AMT    PIC 9(9)V99.\n               10  WS-PRINCIPAL-AMT  PIC 9(9)V99.\n               10  WS-INTEREST-AMT   PIC 9(9)V99.\n               10  WS-BALANCE        PIC 9(11)V99.\n       \n       PROCEDURE DIVISION.\n       CALCULATE-PAYMENT.\n           COMPUTE WS-MONTHLY-RATE = \n               WS-ANNUAL-RATE / 12\n           END-COMPUTE\n           \n           COMPUTE WS-RATE-FACTOR = \n               (1 + WS-MONTHLY-RATE) ** WS-TERM-MONTHS\n           END-COMPUTE\n           \n           COMPUTE WS-MONTHLY-PAYMENT ROUNDED = \n               WS-LOAN-AMOUNT * \n               (WS-MONTHLY-RATE * WS-RATE-FACTOR) /\n               (WS-RATE-FACTOR - 1)\n           END-COMPUTE.\n       \n       BUILD-AMORTIZATION.\n           MOVE WS-LOAN-AMOUNT TO WS-BALANCE(1)\n           PERFORM VARYING WS-IDX FROM 1 BY 1\n               UNTIL WS-IDX > WS-TERM-MONTHS\n               \n               MOVE WS-IDX TO WS-PAYMENT-NUM(WS-IDX)\n               MOVE WS-MONTHLY-PAYMENT TO WS-PAYMENT-AMT(WS-IDX)\n               \n               COMPUTE WS-INTEREST-AMT(WS-IDX) ROUNDED = \n                   WS-BALANCE(WS-IDX) * WS-MONTHLY-RATE\n               END-COMPUTE\n               \n               COMPUTE WS-PRINCIPAL-AMT(WS-IDX) = \n                   WS-MONTHLY-PAYMENT - WS-INTEREST-AMT(WS-IDX)\n               END-COMPUTE\n               \n               IF WS-IDX < WS-TERM-MONTHS\n                   COMPUTE WS-BALANCE(WS-IDX + 1) = \n                       WS-BALANCE(WS-IDX) - WS-PRINCIPAL-AMT(WS-IDX)\n                   END-COMPUTE\n               END-IF\n           END-PERFORM.",
      "java": "public class LoanAmortization {\n    \n    public record AmortizationEntry(\n        int paymentNumber,\n        BigDecimal payment,\n        BigDecimal principal,\n        BigDecimal interest,\n        BigDecimal balance\n    ) {}\n    \n    public static BigDecimal calculateMonthlyPayment(\n            BigDecimal loanAmount,\n            BigDecimal annualRate,\n            int termMonths) {\n        \n        BigDecimal monthlyRate = annualRate.divide(\n            BigDecimal.valueOf(12), 10, RoundingMode.HALF_UP);\n        \n        BigDecimal rateFactor = monthlyRate.add(BigDecimal.ONE)\n            .pow(termMonths);\n        \n        BigDecimal numerator = monthlyRate.multiply(rateFactor);\n        BigDecimal denominator = rateFactor.subtract(BigDecimal.ONE);\n        \n        return loanAmount\n            .multiply(numerator)\n            .divide(denominator, 2, RoundingMode.HALF_UP);\n    }\n    \n    public static List<AmortizationEntry> buildSchedule(\n            BigDecimal loanAmount,\n            BigDecimal annualRate,\n            int termMonths) {\n        \n        BigDecimal monthlyPayment = calculateMonthlyPayment(\n            loanAmount, annualRate, termMonths);\n        BigDecimal monthlyRate = annualRate.divide(\n            BigDecimal.valueOf(12), 10, RoundingMode.HALF_UP);\n        \n        List<AmortizationEntry> schedule = new ArrayList<>();\n        BigDecimal balance = loanAmount;\n        \n        for (int i = 1; i <= termMonths; i++) {\n            BigDecimal interest = balance.multiply(monthlyRate)\n                .setScale(2, RoundingMode.HALF_UP);\n            BigDecimal principal = monthlyPayment.subtract(interest);\n            balance = balance.subtract(principal);\n            \n            schedule.add(new AmortizationEntry(\n                i, monthlyPayment, principal, interest, balance));\n        }\n        \n        return schedule;\n    }\n}",
      "python": "from dataclasses import dataclass\nfrom decimal import Decimal, ROUND_HALF_UP\nfrom typing import List\n\n@dataclass\nclass AmortizationEntry:\n    payment_number: int\n    payment: Decimal\n    principal: Decimal\n    interest: Decimal\n    balance: Decimal\n\ndef calculate_monthly_payment(\n    loan_amount: Decimal,\n    annual_rate: Decimal,\n    term_months: int\n) -> Decimal:\n    monthly_rate = annual_rate / 12\n    rate_factor = (1 + monthly_rate) ** term_months\n    \n    numerator = monthly_rate * rate_factor\n    denominator = rate_factor - 1\n    \n    payment = loan_amount * (numerator / denominator)\n    return payment.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)\n\ndef build_amortization_schedule(\n    loan_amount: Decimal,\n    annual_rate: Decimal,\n    term_months: int\n) -> List[AmortizationEntry]:\n    monthly_payment = calculate_monthly_payment(\n        loan_amount, annual_rate, term_months)\n    monthly_rate = annual_rate / 12\n    \n    schedule = []\n    balance = loan_amount\n    \n    for i in range(1, term_months + 1):\n        interest = (balance * monthly_rate).quantize(\n            Decimal('0.01'), rounding=ROUND_HALF_UP)\n        principal = monthly_payment - interest\n        balance = balance - principal\n        \n        schedule.append(AmortizationEntry(\n            payment_number=i,\n            payment=monthly_payment,\n            principal=principal,\n            interest=interest,\n            balance=balance\n        ))\n    \n    return schedule"
    },
    {
      "id": "BANK004",
      "name": "APR Calculation",
      "description": "Calculate Annual Percentage Rate including fees",
      "cobol": "       WORKING-STORAGE SECTION.\n       01  WS-LOAN-AMOUNT      PIC 9(11)V99.\n       01  WS-ORIGINATION-FEE  PIC 9(7)V99.\n       01  WS-OTHER-FEES       PIC 9(7)V99.\n       01  WS-STATED-RATE      PIC 9(3)V9(6).\n       01  WS-TERM-MONTHS      PIC 9(4).\n       01  WS-NET-PROCEEDS     PIC 9(11)V99.\n       01  WS-APR              PIC 9(3)V9(6).\n       \n       PROCEDURE DIVISION.\n           COMPUTE WS-NET-PROCEEDS = \n               WS-LOAN-AMOUNT - WS-ORIGINATION-FEE - WS-OTHER-FEES\n           END-COMPUTE\n           \n           PERFORM CALCULATE-APR-ITERATIVE.",
      "python": "from scipy.optimize import brentq\n\ndef calculate_apr(\n    loan_amount: Decimal,\n    monthly_payment: Decimal,\n    term_months: int,\n    fees: Decimal\n) -> Decimal:\n    \"\"\"Calculate APR using iterative method.\"\"\"\n    net_proceeds = float(loan_amount - fees)\n    payment = float(monthly_payment)\n    \n    def npv_at_rate(annual_rate):\n        monthly_rate = annual_rate / 12\n        npv = -net_proceeds\n        for i in range(1, term_months + 1):\n            npv += payment / ((1 + monthly_rate) ** i)\n        return npv\n    \n    # Find rate where NPV = 0\n    apr = brentq(npv_at_rate, 0.001, 1.0)\n    return Decimal(str(apr)).quantize(Decimal('0.0001'))"
    }
  ],
  "insurance_calculations": [
    {
      "id": "INS001",
      "name": "Premium Calculation - Term Life",
      "description": "Calculate term life insurance premium",
      "cobol": "       WORKING-STORAGE SECTION.\n       01  WS-FACE-AMOUNT      PIC 9(9).\n       01  WS-AGE              PIC 99.\n       01  WS-GENDER           PIC X.\n           88  MALE            VALUE 'M'.\n           88  FEMALE          VALUE 'F'.\n       01  WS-SMOKER-STATUS    PIC X.\n           88  SMOKER          VALUE 'S'.\n           88  NON-SMOKER      VALUE 'N'.\n       01  WS-TERM-YEARS       PIC 99.\n       01  WS-ANNUAL-PREMIUM   PIC 9(7)V99.\n       01  WS-BASE-RATE        PIC 9(3)V9(6).\n       \n       01  MORTALITY-TABLE.\n           05  MT-ENTRY OCCURS 100 TIMES INDEXED BY MT-IDX.\n               10  MT-AGE          PIC 99.\n               10  MT-MALE-RATE    PIC 9V9(6).\n               10  MT-FEMALE-RATE  PIC 9V9(6).\n       \n       PROCEDURE DIVISION.\n       CALCULATE-PREMIUM.\n           SET MT-IDX TO WS-AGE\n           \n           IF MALE\n               MOVE MT-MALE-RATE(MT-IDX) TO WS-BASE-RATE\n           ELSE\n               MOVE MT-FEMALE-RATE(MT-IDX) TO WS-BASE-RATE\n           END-IF\n           \n           IF SMOKER\n               COMPUTE WS-BASE-RATE = WS-BASE-RATE * 2.5\n           END-IF\n           \n           COMPUTE WS-ANNUAL-PREMIUM ROUNDED = \n               (WS-FACE-AMOUNT / 1000) * WS-BASE-RATE * \n               (1 + (WS-TERM-YEARS * 0.02))\n           END-COMPUTE.",
      "java": "public class LifeInsurancePremium {\n    \n    private static final Map<Integer, MortalityRate> MORTALITY_TABLE = \n        loadMortalityTable();\n    \n    public record MortalityRate(double maleRate, double femaleRate) {}\n    \n    public enum Gender { MALE, FEMALE }\n    \n    public static BigDecimal calculatePremium(\n            BigDecimal faceAmount,\n            int age,\n            Gender gender,\n            boolean isSmoker,\n            int termYears) {\n        \n        MortalityRate rate = MORTALITY_TABLE.get(age);\n        \n        double baseRate = gender == Gender.MALE \n            ? rate.maleRate() \n            : rate.femaleRate();\n        \n        if (isSmoker) {\n            baseRate *= 2.5;\n        }\n        \n        // Term adjustment\n        double termFactor = 1 + (termYears * 0.02);\n        \n        BigDecimal unitsOfCoverage = faceAmount.divide(\n            BigDecimal.valueOf(1000), 0, RoundingMode.UP);\n        \n        return unitsOfCoverage\n            .multiply(BigDecimal.valueOf(baseRate))\n            .multiply(BigDecimal.valueOf(termFactor))\n            .setScale(2, RoundingMode.HALF_UP);\n    }\n}",
      "python": "from dataclasses import dataclass\nfrom enum import Enum\nfrom decimal import Decimal, ROUND_HALF_UP\nfrom typing import Dict\n\nclass Gender(Enum):\n    MALE = 'M'\n    FEMALE = 'F'\n\n@dataclass\nclass MortalityRate:\n    male_rate: Decimal\n    female_rate: Decimal\n\nMORTALITY_TABLE: Dict[int, MortalityRate] = {}  # Load from actuarial tables\n\ndef calculate_term_life_premium(\n    face_amount: Decimal,\n    age: int,\n    gender: Gender,\n    is_smoker: bool,\n    term_years: int\n) -> Decimal:\n    rate = MORTALITY_TABLE.get(age)\n    \n    base_rate = rate.male_rate if gender == Gender.MALE else rate.female_rate\n    \n    if is_smoker:\n        base_rate *= Decimal('2.5')\n    \n    # Term adjustment\n    term_factor = Decimal('1') + (Decimal(term_years) * Decimal('0.02'))\n    \n    units_of_coverage = (face_amount / 1000).quantize(\n        Decimal('1'), rounding=ROUND_HALF_UP)\n    \n    premium = units_of_coverage * base_rate * term_factor\n    return premium.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)"
    },
    {
      "id": "INS002",
      "name": "Auto Insurance Rating",
      "description": "Calculate auto insurance premium with risk factors",
      "cobol": "       WORKING-STORAGE SECTION.\n       01  WS-BASE-PREMIUM     PIC 9(5)V99.\n       01  WS-FINAL-PREMIUM    PIC 9(7)V99.\n       01  WS-DRIVER-AGE       PIC 99.\n       01  WS-YEARS-LICENSED   PIC 99.\n       01  WS-ACCIDENTS-3YR    PIC 9.\n       01  WS-VIOLATIONS-3YR   PIC 9.\n       01  WS-VEHICLE-YEAR     PIC 9(4).\n       01  WS-TERRITORY        PIC 999.\n       01  WS-COVERAGE-TYPE    PIC X.\n           88  LIABILITY-ONLY  VALUE 'L'.\n           88  FULL-COVERAGE   VALUE 'F'.\n       \n       01  WS-AGE-FACTOR       PIC 9V99.\n       01  WS-EXP-FACTOR       PIC 9V99.\n       01  WS-ACCIDENT-FACTOR  PIC 9V99.\n       01  WS-TERRITORY-FACTOR PIC 9V99.\n       \n       PROCEDURE DIVISION.\n       RATE-POLICY.\n           PERFORM CALCULATE-AGE-FACTOR\n           PERFORM CALCULATE-EXPERIENCE-FACTOR\n           PERFORM CALCULATE-ACCIDENT-FACTOR\n           PERFORM LOOKUP-TERRITORY-FACTOR\n           \n           COMPUTE WS-FINAL-PREMIUM ROUNDED = \n               WS-BASE-PREMIUM *\n               WS-AGE-FACTOR *\n               WS-EXP-FACTOR *\n               WS-ACCIDENT-FACTOR *\n               WS-TERRITORY-FACTOR\n           END-COMPUTE.\n       \n       CALCULATE-AGE-FACTOR.\n           EVALUATE TRUE\n               WHEN WS-DRIVER-AGE < 25\n                   MOVE 1.50 TO WS-AGE-FACTOR\n               WHEN WS-DRIVER-AGE >= 25 AND WS-DRIVER-AGE < 65\n                   MOVE 1.00 TO WS-AGE-FACTOR\n               WHEN WS-DRIVER-AGE >= 65\n                   MOVE 1.20 TO WS-AGE-FACTOR\n           END-EVALUATE.\n       \n       CALCULATE-ACCIDENT-FACTOR.\n           EVALUATE WS-ACCIDENTS-3YR\n               WHEN 0\n                   MOVE 1.00 TO WS-ACCIDENT-FACTOR\n               WHEN 1\n                   MOVE 1.25 TO WS-ACCIDENT-FACTOR\n               WHEN 2\n                   MOVE 1.50 TO WS-ACCIDENT-FACTOR\n               WHEN OTHER\n                   MOVE 2.00 TO WS-ACCIDENT-FACTOR\n           END-EVALUATE.",
      "java": "public class AutoInsuranceRating {\n    \n    public static BigDecimal calculatePremium(RatingFactors factors) {\n        BigDecimal ageFactor = getAgeFactor(factors.driverAge());\n        BigDecimal experienceFactor = getExperienceFactor(\n            factors.yearsLicensed());\n        BigDecimal accidentFactor = getAccidentFactor(\n            factors.accidentsLast3Years());\n        BigDecimal territoryFactor = getTerritoryFactor(\n            factors.territory());\n        \n        return factors.basePremium()\n            .multiply(ageFactor)\n            .multiply(experienceFactor)\n            .multiply(accidentFactor)\n            .multiply(territoryFactor)\n            .setScale(2, RoundingMode.HALF_UP);\n    }\n    \n    private static BigDecimal getAgeFactor(int age) {\n        if (age < 25) return new BigDecimal(\"1.50\");\n        if (age >= 65) return new BigDecimal(\"1.20\");\n        return BigDecimal.ONE;\n    }\n    \n    private static BigDecimal getAccidentFactor(int accidents) {\n        return switch (accidents) {\n            case 0 -> BigDecimal.ONE;\n            case 1 -> new BigDecimal(\"1.25\");\n            case 2 -> new BigDecimal(\"1.50\");\n            default -> new BigDecimal(\"2.00\");\n        };\n    }\n}",
      "python": "from dataclasses import dataclass\nfrom decimal import Decimal\n\n@dataclass\nclass RatingFactors:\n    base_premium: Decimal\n    driver_age: int\n    years_licensed: int\n    accidents_3yr: int\n    violations_3yr: int\n    territory: int\n\ndef calculate_auto_premium(factors: RatingFactors) -> Decimal:\n    age_factor = get_age_factor(factors.driver_age)\n    exp_factor = get_experience_factor(factors.years_licensed)\n    accident_factor = get_accident_factor(factors.accidents_3yr)\n    territory_factor = get_territory_factor(factors.territory)\n    \n    premium = (\n        factors.base_premium *\n        age_factor *\n        exp_factor *\n        accident_factor *\n        territory_factor\n    )\n    \n    return premium.quantize(Decimal('0.01'))\n\ndef get_age_factor(age: int) -> Decimal:\n    if age < 25:\n        return Decimal('1.50')\n    elif age >= 65:\n        return Decimal('1.20')\n    return Decimal('1.00')\n\ndef get_accident_factor(accidents: int) -> Decimal:\n    factors = {\n        0: Decimal('1.00'),\n        1: Decimal('1.25'),\n        2: Decimal('1.50')\n    }\n    return factors.get(accidents, Decimal('2.00'))"
    }
  ],
  "financial_calculations": [
    {
      "id": "FIN001",
      "name": "Present Value Calculation",
      "formula": "PV = FV / (1 + r)^n",
      "cobol": "       COMPUTE WS-PRESENT-VALUE ROUNDED = \n           WS-FUTURE-VALUE / \n           ((1 + WS-DISCOUNT-RATE) ** WS-PERIODS)\n       END-COMPUTE.",
      "java": "public static BigDecimal presentValue(\n        BigDecimal futureValue,\n        BigDecimal discountRate,\n        int periods) {\n    \n    BigDecimal discountFactor = discountRate.add(BigDecimal.ONE)\n        .pow(periods);\n    \n    return futureValue.divide(discountFactor, 2, RoundingMode.HALF_UP);\n}"
    },
    {
      "id": "FIN002",
      "name": "Net Present Value (NPV)",
      "description": "Calculate NPV of cash flows",
      "cobol": "       WORKING-STORAGE SECTION.\n       01  WS-CASH-FLOWS.\n           05  WS-FLOW OCCURS 50 TIMES PIC S9(11)V99.\n       01  WS-NUM-FLOWS        PIC 99.\n       01  WS-DISCOUNT-RATE    PIC 9V9(6).\n       01  WS-NPV              PIC S9(13)V99.\n       01  WS-PV-FACTOR        PIC 9V9(10).\n       \n       PROCEDURE DIVISION.\n           MOVE 0 TO WS-NPV\n           PERFORM VARYING WS-IDX FROM 1 BY 1\n               UNTIL WS-IDX > WS-NUM-FLOWS\n               \n               COMPUTE WS-PV-FACTOR = \n                   1 / ((1 + WS-DISCOUNT-RATE) ** WS-IDX)\n               END-COMPUTE\n               \n               COMPUTE WS-NPV = WS-NPV +\n                   (WS-FLOW(WS-IDX) * WS-PV-FACTOR)\n               END-COMPUTE\n           END-PERFORM.",
      "python": "from typing import List\n\ndef npv(\n    cash_flows: List[Decimal],\n    discount_rate: Decimal\n) -> Decimal:\n    total = Decimal('0')\n    \n    for i, flow in enumerate(cash_flows, 1):\n        pv_factor = Decimal('1') / ((1 + discount_rate) ** i)\n        total += flow * pv_factor\n    \n    return total.quantize(Decimal('0.01'))\n\ndef irr(cash_flows: List[Decimal]) -> Decimal:\n    \"\"\"Calculate Internal Rate of Return.\"\"\"\n    from scipy.optimize import brentq\n    \n    def npv_at_rate(rate):\n        return float(sum(\n            flow / (Decimal(str(1 + rate)) ** i)\n            for i, flow in enumerate(cash_flows)\n        ))\n    \n    rate = brentq(npv_at_rate, -0.99, 10.0)\n    return Decimal(str(rate)).quantize(Decimal('0.0001'))"
    }
  ],
  "date_calculations": [
    {
      "id": "DATE001",
      "name": "Business Day Calculation",
      "description": "Calculate next business day excluding holidays",
      "cobol": "       WORKING-STORAGE SECTION.\n       01  WS-INPUT-DATE       PIC 9(8).\n       01  WS-OUTPUT-DATE      PIC 9(8).\n       01  WS-DAY-OF-WEEK      PIC 9.\n       01  WS-JULIAN-DATE      PIC 9(7).\n       01  HOLIDAY-TABLE.\n           05  HOLIDAY-ENTRY OCCURS 20 TIMES.\n               10  HOL-DATE    PIC 9(8).\n       \n       PROCEDURE DIVISION.\n       CALC-NEXT-BUSINESS-DAY.\n           MOVE WS-INPUT-DATE TO WS-OUTPUT-DATE\n           ADD 1 TO WS-OUTPUT-DATE\n           \n           PERFORM UNTIL WS-DAY-OF-WEEK NOT = 6\n               AND WS-DAY-OF-WEEK NOT = 7\n               AND NOT HOLIDAY-FOUND\n               \n               COMPUTE WS-JULIAN-DATE = \n                   FUNCTION INTEGER-OF-DATE(WS-OUTPUT-DATE)\n               COMPUTE WS-DAY-OF-WEEK = \n                   FUNCTION MOD(WS-JULIAN-DATE, 7) + 1\n               \n               PERFORM CHECK-HOLIDAY\n               \n               IF WS-DAY-OF-WEEK = 6 OR = 7 OR HOLIDAY-FOUND\n                   ADD 1 TO WS-OUTPUT-DATE\n               END-IF\n           END-PERFORM.",
      "python": "from datetime import date, timedelta\nfrom typing import Set\nimport holidays\n\ndef next_business_day(\n    input_date: date,\n    holiday_calendar: Set[date] = None\n) -> date:\n    if holiday_calendar is None:\n        holiday_calendar = set(holidays.US(years=input_date.year).keys())\n    \n    next_day = input_date + timedelta(days=1)\n    \n    while next_day.weekday() >= 5 or next_day in holiday_calendar:\n        next_day += timedelta(days=1)\n        # Handle year boundary\n        if next_day.year != input_date.year:\n            holiday_calendar.update(\n                holidays.US(years=next_day.year).keys()\n            )\n    \n    return next_day\n\ndef add_business_days(start_date: date, num_days: int) -> date:\n    current = start_date\n    days_added = 0\n    \n    while days_added < num_days:\n        current = next_business_day(current)\n        days_added += 1\n    \n    return current"
    }
  ]
}

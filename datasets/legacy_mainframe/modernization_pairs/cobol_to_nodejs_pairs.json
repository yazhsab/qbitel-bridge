{
  "metadata": {
    "title": "COBOL to Node.js/TypeScript Modernization Pairs",
    "version": "1.0.0",
    "description": "Comprehensive conversion patterns from COBOL to Node.js and TypeScript",
    "target_framework": "Node.js 20+ with TypeScript 5.x",
    "total_pairs": 75
  },
  "conversion_pairs": [
    {
      "id": "NODE001",
      "category": "data_structures",
      "name": "Record Definition to Interface",
      "cobol": "       01  CUSTOMER-RECORD.\n           05  CUST-ID            PIC 9(10).\n           05  CUST-NAME          PIC X(50).\n           05  CUST-ADDRESS.\n               10  STREET         PIC X(30).\n               10  CITY           PIC X(20).\n               10  STATE          PIC XX.\n               10  ZIP            PIC 9(5).\n           05  CUST-BALANCE       PIC S9(9)V99 COMP-3.\n           05  CUST-STATUS        PIC X.\n               88  ACTIVE         VALUE 'A'.\n               88  INACTIVE       VALUE 'I'.\n               88  SUSPENDED      VALUE 'S'.",
      "typescript": "interface CustomerAddress {\n  street: string;\n  city: string;\n  state: string;\n  zip: string;\n}\n\nenum CustomerStatus {\n  Active = 'A',\n  Inactive = 'I',\n  Suspended = 'S'\n}\n\ninterface CustomerRecord {\n  custId: number;\n  custName: string;\n  custAddress: CustomerAddress;\n  custBalance: number;\n  custStatus: CustomerStatus;\n}\n\n// Zod schema for validation\nimport { z } from 'zod';\n\nconst CustomerSchema = z.object({\n  custId: z.number().int().min(0).max(9999999999),\n  custName: z.string().max(50),\n  custAddress: z.object({\n    street: z.string().max(30),\n    city: z.string().max(20),\n    state: z.string().length(2),\n    zip: z.string().regex(/^\\d{5}$/)\n  }),\n  custBalance: z.number(),\n  custStatus: z.nativeEnum(CustomerStatus)\n});"
    },
    {
      "id": "NODE002",
      "category": "data_structures",
      "name": "OCCURS Clause to Array",
      "cobol": "       01  ORDER-RECORD.\n           05  ORDER-ID           PIC 9(8).\n           05  ORDER-DATE         PIC 9(8).\n           05  LINE-ITEM-COUNT    PIC 99.\n           05  LINE-ITEMS OCCURS 50 TIMES\n                          DEPENDING ON LINE-ITEM-COUNT.\n               10  ITEM-SKU       PIC X(15).\n               10  ITEM-QTY       PIC 9(5).\n               10  ITEM-PRICE     PIC 9(7)V99.\n               10  ITEM-TOTAL     PIC 9(9)V99.",
      "typescript": "interface LineItem {\n  itemSku: string;\n  itemQty: number;\n  itemPrice: number;\n  itemTotal: number;\n}\n\ninterface OrderRecord {\n  orderId: number;\n  orderDate: Date;\n  lineItems: LineItem[];  // Max 50 items\n}\n\n// With class for business logic\nclass Order implements OrderRecord {\n  orderId: number;\n  orderDate: Date;\n  lineItems: LineItem[] = [];\n\n  addLineItem(sku: string, qty: number, price: number): void {\n    if (this.lineItems.length >= 50) {\n      throw new Error('Maximum line items exceeded');\n    }\n    this.lineItems.push({\n      itemSku: sku,\n      itemQty: qty,\n      itemPrice: price,\n      itemTotal: qty * price\n    });\n  }\n\n  get lineItemCount(): number {\n    return this.lineItems.length;\n  }\n}"
    },
    {
      "id": "NODE003",
      "category": "data_structures",
      "name": "REDEFINES to Union Types",
      "cobol": "       01  PAYMENT-RECORD.\n           05  PAY-TYPE           PIC X.\n               88  IS-CHECK       VALUE 'C'.\n               88  IS-CARD        VALUE 'D'.\n               88  IS-ACH         VALUE 'A'.\n           05  PAY-DETAILS.\n               10  CHECK-DATA REDEFINES PAY-DETAILS.\n                   15  CHECK-NUMBER    PIC 9(10).\n                   15  BANK-ROUTING    PIC 9(9).\n                   15  ACCOUNT-NUM     PIC X(17).\n               10  CARD-DATA REDEFINES PAY-DETAILS.\n                   15  CARD-NUMBER     PIC X(16).\n                   15  CARD-EXPIRY     PIC 9(4).\n                   15  CARD-CVV        PIC 9(3).\n                   15  FILLER          PIC X(13).\n               10  ACH-DATA REDEFINES PAY-DETAILS.\n                   15  ACH-ROUTING     PIC 9(9).\n                   15  ACH-ACCOUNT     PIC X(17).\n                   15  ACH-TYPE        PIC X.\n                   15  FILLER          PIC X(9).",
      "typescript": "type PaymentType = 'C' | 'D' | 'A';\n\ninterface CheckPayment {\n  type: 'C';\n  checkNumber: string;\n  bankRouting: string;\n  accountNum: string;\n}\n\ninterface CardPayment {\n  type: 'D';\n  cardNumber: string;\n  cardExpiry: string;\n  cardCvv: string;\n}\n\ninterface AchPayment {\n  type: 'A';\n  achRouting: string;\n  achAccount: string;\n  achType: 'C' | 'S';  // Checking or Savings\n}\n\ntype PaymentRecord = CheckPayment | CardPayment | AchPayment;\n\n// Type guard functions\nfunction isCheckPayment(p: PaymentRecord): p is CheckPayment {\n  return p.type === 'C';\n}\n\nfunction isCardPayment(p: PaymentRecord): p is CardPayment {\n  return p.type === 'D';\n}\n\nfunction isAchPayment(p: PaymentRecord): p is AchPayment {\n  return p.type === 'A';\n}"
    },
    {
      "id": "NODE004",
      "category": "arithmetic",
      "name": "COMPUTE with ROUNDED",
      "cobol": "           COMPUTE WS-TAX ROUNDED = \n               WS-SUBTOTAL * WS-TAX-RATE / 100\n           END-COMPUTE\n           \n           COMPUTE WS-TOTAL = \n               WS-SUBTOTAL + WS-TAX + WS-SHIPPING\n               - WS-DISCOUNT\n           END-COMPUTE\n           \n           COMPUTE WS-MONTHLY-PAYMENT ROUNDED =\n               WS-PRINCIPAL * \n               (WS-RATE * (1 + WS-RATE) ** WS-TERM) /\n               ((1 + WS-RATE) ** WS-TERM - 1)\n           END-COMPUTE",
      "typescript": "import Decimal from 'decimal.js';\n\n// Configure Decimal.js for financial precision\nDecimal.set({ precision: 20, rounding: Decimal.ROUND_HALF_UP });\n\nfunction calculateTax(subtotal: Decimal, taxRate: Decimal): Decimal {\n  return subtotal.times(taxRate).dividedBy(100).toDecimalPlaces(2);\n}\n\nfunction calculateTotal(\n  subtotal: Decimal,\n  tax: Decimal,\n  shipping: Decimal,\n  discount: Decimal\n): Decimal {\n  return subtotal.plus(tax).plus(shipping).minus(discount);\n}\n\nfunction calculateMonthlyPayment(\n  principal: Decimal,\n  annualRate: Decimal,\n  termMonths: number\n): Decimal {\n  const monthlyRate = annualRate.dividedBy(1200);\n  const factor = monthlyRate.plus(1).pow(termMonths);\n  return principal\n    .times(monthlyRate)\n    .times(factor)\n    .dividedBy(factor.minus(1))\n    .toDecimalPlaces(2);\n}"
    },
    {
      "id": "NODE005",
      "category": "arithmetic",
      "name": "ON SIZE ERROR Handling",
      "cobol": "           ADD WS-AMOUNT TO WS-TOTAL\n               ON SIZE ERROR\n                   MOVE 'Y' TO WS-OVERFLOW-FLAG\n                   MOVE 999999999.99 TO WS-TOTAL\n                   PERFORM ERROR-ROUTINE\n               NOT ON SIZE ERROR\n                   CONTINUE\n           END-ADD",
      "typescript": "import Decimal from 'decimal.js';\n\nconst MAX_VALUE = new Decimal('999999999.99');\nconst MIN_VALUE = new Decimal('-999999999.99');\n\nclass OverflowError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'OverflowError';\n  }\n}\n\nfunction safeAdd(current: Decimal, amount: Decimal): {\n  result: Decimal;\n  overflow: boolean;\n} {\n  const result = current.plus(amount);\n  \n  if (result.greaterThan(MAX_VALUE) || result.lessThan(MIN_VALUE)) {\n    return {\n      result: result.greaterThan(0) ? MAX_VALUE : MIN_VALUE,\n      overflow: true\n    };\n  }\n  \n  return { result, overflow: false };\n}\n\n// Usage with error handling\nasync function addAmount(total: Decimal, amount: Decimal): Promise<Decimal> {\n  const { result, overflow } = safeAdd(total, amount);\n  \n  if (overflow) {\n    await logError('Arithmetic overflow detected');\n    throw new OverflowError('Value exceeded maximum allowed');\n  }\n  \n  return result;\n}"
    },
    {
      "id": "NODE006",
      "category": "control_flow",
      "name": "PERFORM VARYING Loop",
      "cobol": "           PERFORM VARYING WS-IDX FROM 1 BY 1\n               UNTIL WS-IDX > WS-TABLE-COUNT\n               OR WS-FOUND = 'Y'\n               \n               IF TABLE-KEY(WS-IDX) = WS-SEARCH-KEY\n                   MOVE 'Y' TO WS-FOUND\n                   MOVE WS-IDX TO WS-FOUND-IDX\n                   MOVE TABLE-DATA(WS-IDX) TO WS-RESULT\n               END-IF\n           END-PERFORM",
      "typescript": "interface TableEntry {\n  key: string;\n  data: unknown;\n}\n\nfunction searchTable(table: TableEntry[], searchKey: string): {\n  found: boolean;\n  index: number;\n  data?: unknown;\n} {\n  for (let idx = 0; idx < table.length; idx++) {\n    if (table[idx].key === searchKey) {\n      return {\n        found: true,\n        index: idx,\n        data: table[idx].data\n      };\n    }\n  }\n  return { found: false, index: -1 };\n}\n\n// Using Array.find for more idiomatic approach\nfunction findInTable(table: TableEntry[], searchKey: string) {\n  const index = table.findIndex(entry => entry.key === searchKey);\n  if (index !== -1) {\n    return { found: true, index, data: table[index].data };\n  }\n  return { found: false, index: -1 };\n}"
    },
    {
      "id": "NODE007",
      "category": "control_flow",
      "name": "EVALUATE TRUE Statement",
      "cobol": "           EVALUATE TRUE\n               WHEN WS-SCORE >= 90\n                   MOVE 'A' TO WS-GRADE\n                   ADD 4.0 TO WS-GPA-POINTS\n               WHEN WS-SCORE >= 80\n                   MOVE 'B' TO WS-GRADE\n                   ADD 3.0 TO WS-GPA-POINTS\n               WHEN WS-SCORE >= 70\n                   MOVE 'C' TO WS-GRADE\n                   ADD 2.0 TO WS-GPA-POINTS\n               WHEN WS-SCORE >= 60\n                   MOVE 'D' TO WS-GRADE\n                   ADD 1.0 TO WS-GPA-POINTS\n               WHEN OTHER\n                   MOVE 'F' TO WS-GRADE\n                   ADD 0.0 TO WS-GPA-POINTS\n           END-EVALUATE",
      "typescript": "type Grade = 'A' | 'B' | 'C' | 'D' | 'F';\n\ninterface GradeResult {\n  grade: Grade;\n  gpaPoints: number;\n}\n\nfunction calculateGrade(score: number): GradeResult {\n  if (score >= 90) return { grade: 'A', gpaPoints: 4.0 };\n  if (score >= 80) return { grade: 'B', gpaPoints: 3.0 };\n  if (score >= 70) return { grade: 'C', gpaPoints: 2.0 };\n  if (score >= 60) return { grade: 'D', gpaPoints: 1.0 };\n  return { grade: 'F', gpaPoints: 0.0 };\n}\n\n// Alternative using a lookup table\nconst gradeScale: { minScore: number; grade: Grade; gpaPoints: number }[] = [\n  { minScore: 90, grade: 'A', gpaPoints: 4.0 },\n  { minScore: 80, grade: 'B', gpaPoints: 3.0 },\n  { minScore: 70, grade: 'C', gpaPoints: 2.0 },\n  { minScore: 60, grade: 'D', gpaPoints: 1.0 },\n  { minScore: 0, grade: 'F', gpaPoints: 0.0 }\n];\n\nfunction calculateGradeFromScale(score: number): GradeResult {\n  const result = gradeScale.find(g => score >= g.minScore)!;\n  return { grade: result.grade, gpaPoints: result.gpaPoints };\n}"
    },
    {
      "id": "NODE008",
      "category": "file_operations",
      "name": "Sequential File Processing",
      "cobol": "       FILE-CONTROL.\n           SELECT TRANS-FILE ASSIGN TO 'TRANSIN'\n               ORGANIZATION IS SEQUENTIAL\n               ACCESS MODE IS SEQUENTIAL\n               FILE STATUS IS WS-FILE-STATUS.\n       \n       PROCEDURE DIVISION.\n           OPEN INPUT TRANS-FILE\n           IF WS-FILE-STATUS NOT = '00'\n               DISPLAY 'FILE OPEN ERROR: ' WS-FILE-STATUS\n               STOP RUN\n           END-IF\n           \n           PERFORM UNTIL WS-EOF = 'Y'\n               READ TRANS-FILE INTO WS-TRANS-REC\n                   AT END\n                       MOVE 'Y' TO WS-EOF\n                   NOT AT END\n                       PERFORM PROCESS-TRANSACTION\n               END-READ\n           END-PERFORM\n           \n           CLOSE TRANS-FILE.",
      "typescript": "import { createReadStream, createWriteStream } from 'fs';\nimport { createInterface } from 'readline';\nimport { pipeline } from 'stream/promises';\n\ninterface TransactionRecord {\n  transId: string;\n  amount: number;\n  accountId: string;\n  transType: string;\n}\n\nasync function* parseTransactions(\n  filePath: string\n): AsyncGenerator<TransactionRecord> {\n  const fileStream = createReadStream(filePath, { encoding: 'utf-8' });\n  const rl = createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    // Parse fixed-width record (matching COBOL layout)\n    yield {\n      transId: line.substring(0, 10).trim(),\n      amount: parseFloat(line.substring(10, 23)) / 100,\n      accountId: line.substring(23, 33).trim(),\n      transType: line.substring(33, 35).trim()\n    };\n  }\n}\n\nasync function processTransactionFile(inputPath: string): Promise<void> {\n  try {\n    for await (const transaction of parseTransactions(inputPath)) {\n      await processTransaction(transaction);\n    }\n    console.log('File processing completed successfully');\n  } catch (error) {\n    if (error instanceof Error) {\n      console.error(`File error: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\nasync function processTransaction(trans: TransactionRecord): Promise<void> {\n  // Business logic here\n  console.log(`Processing: ${trans.transId}`);\n}"
    },
    {
      "id": "NODE009",
      "category": "file_operations",
      "name": "Indexed File (VSAM KSDS) Operations",
      "cobol": "       FILE-CONTROL.\n           SELECT CUSTOMER-FILE ASSIGN TO 'CUSTMAST'\n               ORGANIZATION IS INDEXED\n               ACCESS MODE IS DYNAMIC\n               RECORD KEY IS CUST-KEY\n               ALTERNATE KEY IS CUST-NAME WITH DUPLICATES\n               FILE STATUS IS WS-CUST-STATUS.\n       \n       PROCEDURE DIVISION.\n           MOVE WS-SEARCH-KEY TO CUST-KEY\n           READ CUSTOMER-FILE\n               INVALID KEY\n                   MOVE 'Y' TO WS-NOT-FOUND\n               NOT INVALID KEY\n                   PERFORM DISPLAY-CUSTOMER\n           END-READ\n           \n           START CUSTOMER-FILE KEY >= CUST-NAME\n               INVALID KEY\n                   MOVE 'Y' TO WS-NOT-FOUND\n           END-START\n           \n           PERFORM UNTIL WS-EOF = 'Y'\n               READ CUSTOMER-FILE NEXT\n                   AT END\n                       MOVE 'Y' TO WS-EOF\n               END-READ\n           END-PERFORM.",
      "typescript": "import { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\ninterface Customer {\n  custKey: string;\n  custName: string;\n  custAddress: string;\n  custBalance: number;\n  custStatus: string;\n}\n\nclass CustomerRepository {\n  // Direct key lookup (like READ with key)\n  async findByKey(key: string): Promise<Customer | null> {\n    return prisma.customer.findUnique({\n      where: { custKey: key }\n    });\n  }\n\n  // Alternate key lookup (with duplicates)\n  async findByName(name: string): Promise<Customer[]> {\n    return prisma.customer.findMany({\n      where: { custName: name },\n      orderBy: { custKey: 'asc' }\n    });\n  }\n\n  // START KEY >= (range scan)\n  async findByNameStarting(namePrefix: string): Promise<Customer[]> {\n    return prisma.customer.findMany({\n      where: {\n        custName: { gte: namePrefix }\n      },\n      orderBy: { custName: 'asc' }\n    });\n  }\n\n  // Sequential read (READ NEXT)\n  async *iterateAll(): AsyncGenerator<Customer> {\n    const batchSize = 100;\n    let cursor: string | undefined;\n\n    while (true) {\n      const batch = await prisma.customer.findMany({\n        take: batchSize,\n        skip: cursor ? 1 : 0,\n        cursor: cursor ? { custKey: cursor } : undefined,\n        orderBy: { custKey: 'asc' }\n      });\n\n      if (batch.length === 0) break;\n\n      for (const customer of batch) {\n        yield customer;\n      }\n\n      cursor = batch[batch.length - 1].custKey;\n    }\n  }\n\n  // WRITE (insert)\n  async insert(customer: Customer): Promise<Customer> {\n    return prisma.customer.create({ data: customer });\n  }\n\n  // REWRITE (update)\n  async update(key: string, data: Partial<Customer>): Promise<Customer> {\n    return prisma.customer.update({\n      where: { custKey: key },\n      data\n    });\n  }\n\n  // DELETE\n  async delete(key: string): Promise<void> {\n    await prisma.customer.delete({ where: { custKey: key } });\n  }\n}"
    },
    {
      "id": "NODE010",
      "category": "string_handling",
      "name": "STRING and UNSTRING",
      "cobol": "           STRING\n               WS-LAST-NAME DELIMITED BY SPACES\n               ', ' DELIMITED BY SIZE\n               WS-FIRST-NAME DELIMITED BY SPACES\n               ' ' DELIMITED BY SIZE\n               WS-MIDDLE-INIT DELIMITED BY SIZE\n               INTO WS-FULL-NAME\n               WITH POINTER WS-PTR\n               ON OVERFLOW\n                   MOVE 'Y' TO WS-OVERFLOW\n           END-STRING\n           \n           UNSTRING WS-ADDRESS-LINE\n               DELIMITED BY ', ' OR ','  \n               INTO WS-STREET\n                    WS-CITY\n                    WS-STATE-ZIP\n               TALLYING IN WS-FIELD-COUNT\n               ON OVERFLOW\n                   MOVE 'Y' TO WS-OVERFLOW\n           END-UNSTRING",
      "typescript": "interface NameParts {\n  firstName: string;\n  lastName: string;\n  middleInit?: string;\n}\n\ninterface AddressParts {\n  street: string;\n  city: string;\n  stateZip: string;\n}\n\nfunction buildFullName(parts: NameParts, maxLength: number = 100): {\n  fullName: string;\n  overflow: boolean;\n} {\n  const fullName = [\n    parts.lastName.trim(),\n    ', ',\n    parts.firstName.trim(),\n    parts.middleInit ? ` ${parts.middleInit}` : ''\n  ].join('');\n\n  if (fullName.length > maxLength) {\n    return {\n      fullName: fullName.substring(0, maxLength),\n      overflow: true\n    };\n  }\n\n  return { fullName, overflow: false };\n}\n\nfunction parseAddressLine(addressLine: string): {\n  parts: AddressParts;\n  fieldCount: number;\n  overflow: boolean;\n} {\n  // Split by comma with optional spaces\n  const segments = addressLine.split(/,\\s*/);\n\n  return {\n    parts: {\n      street: segments[0]?.trim() || '',\n      city: segments[1]?.trim() || '',\n      stateZip: segments[2]?.trim() || ''\n    },\n    fieldCount: segments.length,\n    overflow: segments.length > 3\n  };\n}\n\n// More sophisticated parsing with regex\nfunction parseAddress(address: string): AddressParts | null {\n  const match = address.match(/^(.+?),\\s*(.+?),\\s*([A-Z]{2}\\s+\\d{5}(?:-\\d{4})?)$/);\n  if (!match) return null;\n  \n  return {\n    street: match[1],\n    city: match[2],\n    stateZip: match[3]\n  };\n}"
    },
    {
      "id": "NODE011",
      "category": "string_handling",
      "name": "INSPECT REPLACING/TALLYING",
      "cobol": "           INSPECT WS-TEXT\n               TALLYING WS-SPACE-COUNT FOR ALL SPACES\n                        WS-ZERO-COUNT FOR ALL ZEROS\n           \n           INSPECT WS-PHONE-NUMBER\n               REPLACING ALL '-' BY SPACES\n                         ALL '(' BY SPACES\n                         ALL ')' BY SPACES\n           \n           INSPECT WS-SSN\n               CONVERTING '0123456789' TO 'XXXXXXXXXX'",
      "typescript": "function inspectAndTally(text: string): {\n  spaceCount: number;\n  zeroCount: number;\n} {\n  return {\n    spaceCount: (text.match(/ /g) || []).length,\n    zeroCount: (text.match(/0/g) || []).length\n  };\n}\n\nfunction cleanPhoneNumber(phone: string): string {\n  // Replace all formatting characters with spaces\n  return phone.replace(/[-()]/g, ' ');\n}\n\nfunction extractDigitsOnly(phone: string): string {\n  return phone.replace(/\\D/g, '');\n}\n\nfunction maskSSN(ssn: string): string {\n  // Convert all digits to X\n  return ssn.replace(/[0-9]/g, 'X');\n}\n\n// Generic CONVERTING equivalent\nfunction convertCharacters(\n  text: string,\n  fromChars: string,\n  toChars: string\n): string {\n  if (fromChars.length !== toChars.length) {\n    throw new Error('Character strings must be same length');\n  }\n\n  const charMap = new Map<string, string>();\n  for (let i = 0; i < fromChars.length; i++) {\n    charMap.set(fromChars[i], toChars[i]);\n  }\n\n  return text\n    .split('')\n    .map(ch => charMap.get(ch) ?? ch)\n    .join('');\n}"
    },
    {
      "id": "NODE012",
      "category": "database",
      "name": "Embedded SQL SELECT",
      "cobol": "           EXEC SQL\n               SELECT CUST_NAME, CUST_ADDR, CUST_BALANCE\n               INTO :WS-CUST-NAME, :WS-CUST-ADDR, :WS-CUST-BAL\n               FROM CUSTOMER\n               WHERE CUST_ID = :WS-CUST-ID\n           END-EXEC\n           \n           IF SQLCODE = 0\n               CONTINUE\n           ELSE IF SQLCODE = 100\n               MOVE 'N' TO WS-FOUND-FLAG\n           ELSE\n               MOVE SQLCODE TO WS-ERROR-CODE\n               PERFORM SQL-ERROR-ROUTINE\n           END-IF",
      "typescript": "import { Pool } from 'pg';\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL\n});\n\ninterface CustomerData {\n  custName: string;\n  custAddr: string;\n  custBalance: number;\n}\n\ninterface QueryResult<T> {\n  success: boolean;\n  data?: T;\n  notFound?: boolean;\n  errorCode?: string;\n}\n\nasync function getCustomer(custId: string): Promise<QueryResult<CustomerData>> {\n  try {\n    const result = await pool.query<CustomerData>(\n      `SELECT cust_name as \"custName\", \n              cust_addr as \"custAddr\", \n              cust_balance as \"custBalance\"\n       FROM customer\n       WHERE cust_id = $1`,\n      [custId]\n    );\n\n    if (result.rowCount === 0) {\n      return { success: true, notFound: true };\n    }\n\n    return { success: true, data: result.rows[0] };\n  } catch (error) {\n    const pgError = error as { code?: string };\n    await handleSqlError(pgError.code || 'UNKNOWN');\n    return { success: false, errorCode: pgError.code };\n  }\n}\n\n// Using Prisma ORM\nimport { PrismaClient, Prisma } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nasync function getCustomerPrisma(\n  custId: string\n): Promise<QueryResult<CustomerData>> {\n  try {\n    const customer = await prisma.customer.findUnique({\n      where: { custId },\n      select: {\n        custName: true,\n        custAddr: true,\n        custBalance: true\n      }\n    });\n\n    if (!customer) {\n      return { success: true, notFound: true };\n    }\n\n    return { success: true, data: customer };\n  } catch (error) {\n    if (error instanceof Prisma.PrismaClientKnownRequestError) {\n      return { success: false, errorCode: error.code };\n    }\n    throw error;\n  }\n}"
    },
    {
      "id": "NODE013",
      "category": "database",
      "name": "Cursor Processing",
      "cobol": "           EXEC SQL\n               DECLARE ACCT_CURSOR CURSOR FOR\n               SELECT ACCT_NUM, ACCT_BAL, ACCT_TYPE\n               FROM ACCOUNTS\n               WHERE CUST_ID = :WS-CUST-ID\n               ORDER BY ACCT_NUM\n           END-EXEC\n           \n           EXEC SQL OPEN ACCT_CURSOR END-EXEC\n           \n           PERFORM UNTIL SQLCODE NOT = 0\n               EXEC SQL\n                   FETCH ACCT_CURSOR\n                   INTO :WS-ACCT-NUM, :WS-ACCT-BAL, :WS-ACCT-TYPE\n               END-EXEC\n               \n               IF SQLCODE = 0\n                   PERFORM PROCESS-ACCOUNT\n               END-IF\n           END-PERFORM\n           \n           EXEC SQL CLOSE ACCT_CURSOR END-EXEC",
      "typescript": "import { Pool, PoolClient, QueryResult } from 'pg';\n\ninterface Account {\n  acctNum: string;\n  acctBal: number;\n  acctType: string;\n}\n\n// Streaming cursor implementation\nasync function* fetchAccountsCursor(\n  pool: Pool,\n  custId: string\n): AsyncGenerator<Account> {\n  const client = await pool.connect();\n  \n  try {\n    // Begin transaction for cursor\n    await client.query('BEGIN');\n    \n    // Declare cursor\n    await client.query(\n      `DECLARE acct_cursor CURSOR FOR\n       SELECT acct_num, acct_bal, acct_type\n       FROM accounts\n       WHERE cust_id = $1\n       ORDER BY acct_num`,\n      [custId]\n    );\n\n    // Fetch in batches\n    while (true) {\n      const result = await client.query<Account>(\n        'FETCH 100 FROM acct_cursor'\n      );\n\n      if (result.rows.length === 0) break;\n\n      for (const row of result.rows) {\n        yield {\n          acctNum: row.acct_num,\n          acctBal: row.acct_bal,\n          acctType: row.acct_type\n        };\n      }\n    }\n\n    await client.query('CLOSE acct_cursor');\n    await client.query('COMMIT');\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n}\n\n// Usage\nasync function processCustomerAccounts(\n  pool: Pool,\n  custId: string\n): Promise<void> {\n  for await (const account of fetchAccountsCursor(pool, custId)) {\n    await processAccount(account);\n  }\n}"
    },
    {
      "id": "NODE014",
      "category": "cics_conversion",
      "name": "CICS SEND MAP to Express.js API",
      "cobol": "           EXEC CICS SEND MAP('CUSTINQ')\n                     MAPSET('CUSTSET')\n                     FROM(CUSTINQ-MAP)\n                     ERASE\n                     CURSOR\n           END-EXEC\n           \n           EXEC CICS RETURN\n                     TRANSID('CINQ')\n                     COMMAREA(WS-COMMAREA)\n           END-EXEC",
      "typescript": "import express, { Request, Response, Router } from 'express';\nimport { z } from 'zod';\n\n// Define the request/response schemas (replacing COMMAREA)\nconst CustomerInquiryRequest = z.object({\n  customerId: z.string().length(10),\n  action: z.enum(['INQUIRY', 'UPDATE', 'DELETE'])\n});\n\nconst CustomerInquiryResponse = z.object({\n  customerId: z.string(),\n  customerName: z.string(),\n  customerAddress: z.string(),\n  customerBalance: z.number(),\n  status: z.enum(['SUCCESS', 'NOT_FOUND', 'ERROR']),\n  message: z.string().optional()\n});\n\ntype CustomerInquiry = z.infer<typeof CustomerInquiryResponse>;\n\nconst router = Router();\n\n// Equivalent to CICS SEND MAP - returning JSON response\nrouter.get('/customer/:id', async (req: Request, res: Response) => {\n  try {\n    const customerId = req.params.id;\n    \n    const customer = await customerService.findById(customerId);\n    \n    if (!customer) {\n      return res.status(404).json({\n        customerId,\n        status: 'NOT_FOUND',\n        message: 'Customer not found'\n      });\n    }\n\n    // SEND MAP equivalent - return response data\n    const response: CustomerInquiry = {\n      customerId: customer.custId,\n      customerName: customer.custName,\n      customerAddress: customer.custAddress,\n      customerBalance: customer.custBalance,\n      status: 'SUCCESS'\n    };\n\n    res.json(response);\n  } catch (error) {\n    res.status(500).json({\n      status: 'ERROR',\n      message: 'Internal server error'\n    });\n  }\n});\n\nexport default router;"
    },
    {
      "id": "NODE015",
      "category": "cics_conversion",
      "name": "CICS RECEIVE MAP to Request Parsing",
      "cobol": "           EXEC CICS RECEIVE MAP('CUSTUPD')\n                     MAPSET('CUSTSET')\n                     INTO(CUSTUPD-MAP)\n           END-EXEC\n           \n           IF EIBAID = DFHENTER\n               IF CUSTUPD-NAMEI NOT = LOW-VALUES\n                   MOVE CUSTUPD-NAMEI TO WS-CUST-NAME\n               END-IF\n               IF CUSTUPD-ADDRI NOT = LOW-VALUES\n                   MOVE CUSTUPD-ADDRI TO WS-CUST-ADDR\n               END-IF\n               PERFORM UPDATE-CUSTOMER\n           ELSE IF EIBAID = DFHPF3\n               PERFORM RETURN-TO-MENU\n           END-IF",
      "typescript": "import express, { Request, Response, Router } from 'express';\nimport { z } from 'zod';\n\n// Schema matching CICS map fields\nconst CustomerUpdateSchema = z.object({\n  customerId: z.string().length(10),\n  customerName: z.string().max(50).optional(),\n  customerAddress: z.string().max(100).optional(),\n  customerPhone: z.string().max(15).optional(),\n  action: z.enum(['SUBMIT', 'CANCEL'])\n});\n\nconst router = Router();\n\n// RECEIVE MAP equivalent - parse request body\nrouter.put('/customer/:id', async (req: Request, res: Response) => {\n  try {\n    // Validate input (equivalent to map field validation)\n    const parseResult = CustomerUpdateSchema.safeParse({\n      customerId: req.params.id,\n      ...req.body\n    });\n\n    if (!parseResult.success) {\n      return res.status(400).json({\n        status: 'ERROR',\n        errors: parseResult.error.errors\n      });\n    }\n\n    const input = parseResult.data;\n\n    // Check action (equivalent to EIBAID check)\n    if (input.action === 'CANCEL') {\n      return res.json({ status: 'CANCELLED' });\n    }\n\n    // Build update object only with provided fields\n    // (equivalent to checking for LOW-VALUES)\n    const updateData: Partial<Customer> = {};\n    \n    if (input.customerName !== undefined) {\n      updateData.custName = input.customerName;\n    }\n    if (input.customerAddress !== undefined) {\n      updateData.custAddr = input.customerAddress;\n    }\n\n    if (Object.keys(updateData).length === 0) {\n      return res.status(400).json({\n        status: 'ERROR',\n        message: 'No fields to update'\n      });\n    }\n\n    const updated = await customerService.update(\n      input.customerId,\n      updateData\n    );\n\n    res.json({\n      status: 'SUCCESS',\n      customer: updated\n    });\n  } catch (error) {\n    res.status(500).json({ status: 'ERROR' });\n  }\n});"
    },
    {
      "id": "NODE016",
      "category": "cics_conversion",
      "name": "CICS LINK to Function Call",
      "cobol": "           MOVE WS-ACCT-NUM TO LINK-ACCT-NUM\n           MOVE WS-TRANS-AMT TO LINK-TRANS-AMT\n           MOVE 'C' TO LINK-TRANS-TYPE\n           \n           EXEC CICS LINK PROGRAM('ACCTUPD')\n                     COMMAREA(LINK-COMMAREA)\n                     LENGTH(LINK-COMM-LEN)\n           END-EXEC\n           \n           IF LINK-RETURN-CODE = 0\n               MOVE LINK-NEW-BALANCE TO WS-NEW-BALANCE\n           ELSE\n               PERFORM HANDLE-LINK-ERROR\n           END-IF",
      "typescript": "// Shared interface (replaces COMMAREA copybook)\ninterface AccountUpdateRequest {\n  acctNum: string;\n  transAmt: number;\n  transType: 'C' | 'D';  // Credit or Debit\n}\n\ninterface AccountUpdateResponse {\n  returnCode: number;\n  newBalance?: number;\n  errorMessage?: string;\n}\n\n// The linked program as a service module\nclass AccountUpdateService {\n  async processTransaction(\n    request: AccountUpdateRequest\n  ): Promise<AccountUpdateResponse> {\n    try {\n      const account = await this.getAccount(request.acctNum);\n      \n      if (!account) {\n        return { returnCode: 4, errorMessage: 'Account not found' };\n      }\n\n      let newBalance: number;\n      if (request.transType === 'C') {\n        newBalance = account.balance + request.transAmt;\n      } else {\n        if (account.balance < request.transAmt) {\n          return { returnCode: 8, errorMessage: 'Insufficient funds' };\n        }\n        newBalance = account.balance - request.transAmt;\n      }\n\n      await this.updateBalance(request.acctNum, newBalance);\n\n      return { returnCode: 0, newBalance };\n    } catch (error) {\n      return { returnCode: 12, errorMessage: 'System error' };\n    }\n  }\n}\n\n// Calling code (replaces EXEC CICS LINK)\nconst accountService = new AccountUpdateService();\n\nasync function processCredit(\n  acctNum: string,\n  amount: number\n): Promise<number> {\n  const response = await accountService.processTransaction({\n    acctNum,\n    transAmt: amount,\n    transType: 'C'\n  });\n\n  if (response.returnCode !== 0) {\n    throw new Error(response.errorMessage);\n  }\n\n  return response.newBalance!;\n}"
    },
    {
      "id": "NODE017",
      "category": "batch_processing",
      "name": "Batch Job Structure",
      "cobol": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. DAILYBAT.\n      * DAILY BATCH PROCESSING\n       \n       PROCEDURE DIVISION.\n           PERFORM INITIALIZATION\n           PERFORM PROCESS-MAIN UNTIL WS-EOF = 'Y'\n           PERFORM WRAP-UP\n           STOP RUN.\n       \n       INITIALIZATION.\n           OPEN INPUT TRANS-FILE\n           OPEN OUTPUT REPORT-FILE\n           OPEN I-O MASTER-FILE\n           INITIALIZE WS-COUNTERS\n           ACCEPT WS-RUN-DATE FROM DATE.\n       \n       PROCESS-MAIN.\n           READ TRANS-FILE\n               AT END MOVE 'Y' TO WS-EOF\n               NOT AT END PERFORM PROCESS-TRANSACTION\n           END-READ.\n       \n       WRAP-UP.\n           PERFORM PRINT-SUMMARY\n           CLOSE TRANS-FILE\n           CLOSE REPORT-FILE\n           CLOSE MASTER-FILE.",
      "typescript": "import { createLogger, transports, format } from 'winston';\nimport { PrismaClient } from '@prisma/client';\n\ninterface BatchContext {\n  runDate: Date;\n  counters: {\n    read: number;\n    processed: number;\n    errors: number;\n    skipped: number;\n  };\n  startTime: Date;\n}\n\nconst logger = createLogger({\n  format: format.combine(format.timestamp(), format.json()),\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: 'batch.log' })\n  ]\n});\n\nconst prisma = new PrismaClient();\n\nasync function runDailyBatch(): Promise<void> {\n  const context: BatchContext = {\n    runDate: new Date(),\n    counters: { read: 0, processed: 0, errors: 0, skipped: 0 },\n    startTime: new Date()\n  };\n\n  try {\n    // INITIALIZATION\n    logger.info('Starting daily batch processing', {\n      runDate: context.runDate\n    });\n\n    // PROCESS-MAIN\n    for await (const transaction of readTransactions()) {\n      context.counters.read++;\n      \n      try {\n        await processTransaction(transaction, context);\n        context.counters.processed++;\n      } catch (error) {\n        context.counters.errors++;\n        logger.error('Transaction processing error', {\n          transId: transaction.id,\n          error: error instanceof Error ? error.message : 'Unknown'\n        });\n      }\n    }\n\n    // WRAP-UP\n    await printSummary(context);\n    \n    logger.info('Batch processing completed', {\n      duration: Date.now() - context.startTime.getTime(),\n      ...context.counters\n    });\n  } catch (error) {\n    logger.error('Batch failed', { error });\n    process.exit(1);\n  } finally {\n    await prisma.$disconnect();\n  }\n}\n\n// Entry point\nrunDailyBatch().catch(console.error);"
    },
    {
      "id": "NODE018",
      "category": "batch_processing",
      "name": "Control Break Processing",
      "cobol": "       PROCEDURE DIVISION.\n           PERFORM INITIALIZATION\n           READ TRANS-FILE AT END MOVE 'Y' TO WS-EOF\n           MOVE TRANS-DEPT TO WS-PREV-DEPT\n           MOVE TRANS-REGION TO WS-PREV-REGION\n           \n           PERFORM UNTIL WS-EOF = 'Y'\n               IF TRANS-REGION NOT = WS-PREV-REGION\n                   PERFORM REGION-BREAK\n               END-IF\n               IF TRANS-DEPT NOT = WS-PREV-DEPT\n                   PERFORM DEPT-BREAK\n               END-IF\n               \n               ADD TRANS-AMOUNT TO WS-DEPT-TOTAL\n               ADD 1 TO WS-DEPT-COUNT\n               \n               READ TRANS-FILE AT END MOVE 'Y' TO WS-EOF\n           END-PERFORM\n           \n           PERFORM DEPT-BREAK\n           PERFORM REGION-BREAK\n           PERFORM FINAL-TOTALS.\n       \n       DEPT-BREAK.\n           WRITE RPT-REC FROM DEPT-TOTAL-LINE\n           ADD WS-DEPT-TOTAL TO WS-REGION-TOTAL\n           INITIALIZE WS-DEPT-TOTAL WS-DEPT-COUNT\n           MOVE TRANS-DEPT TO WS-PREV-DEPT.\n       \n       REGION-BREAK.\n           PERFORM DEPT-BREAK\n           WRITE RPT-REC FROM REGION-TOTAL-LINE\n           ADD WS-REGION-TOTAL TO WS-GRAND-TOTAL\n           INITIALIZE WS-REGION-TOTAL\n           MOVE TRANS-REGION TO WS-PREV-REGION.",
      "typescript": "interface Transaction {\n  region: string;\n  dept: string;\n  amount: number;\n}\n\ninterface BreakTotals {\n  dept: string;\n  region: string;\n  deptTotal: number;\n  deptCount: number;\n  regionTotal: number;\n  grandTotal: number;\n}\n\ninterface ReportLine {\n  level: 'DETAIL' | 'DEPT' | 'REGION' | 'GRAND';\n  region?: string;\n  dept?: string;\n  total: number;\n  count?: number;\n}\n\nasync function* controlBreakProcess(\n  transactions: AsyncIterable<Transaction>\n): AsyncGenerator<ReportLine> {\n  const totals: BreakTotals = {\n    dept: '',\n    region: '',\n    deptTotal: 0,\n    deptCount: 0,\n    regionTotal: 0,\n    grandTotal: 0\n  };\n\n  let isFirst = true;\n\n  for await (const trans of transactions) {\n    if (isFirst) {\n      totals.region = trans.region;\n      totals.dept = trans.dept;\n      isFirst = false;\n    }\n\n    // Region break (major)\n    if (trans.region !== totals.region) {\n      // Dept break first\n      yield* deptBreak(totals);\n      yield* regionBreak(totals);\n      totals.region = trans.region;\n    }\n    // Dept break (minor)\n    else if (trans.dept !== totals.dept) {\n      yield* deptBreak(totals);\n    }\n\n    // Accumulate\n    totals.deptTotal += trans.amount;\n    totals.deptCount++;\n    totals.dept = trans.dept;\n  }\n\n  // Final breaks\n  if (!isFirst) {\n    yield* deptBreak(totals);\n    yield* regionBreak(totals);\n    yield {\n      level: 'GRAND',\n      total: totals.grandTotal\n    };\n  }\n}\n\nfunction* deptBreak(totals: BreakTotals): Generator<ReportLine> {\n  yield {\n    level: 'DEPT',\n    region: totals.region,\n    dept: totals.dept,\n    total: totals.deptTotal,\n    count: totals.deptCount\n  };\n  totals.regionTotal += totals.deptTotal;\n  totals.deptTotal = 0;\n  totals.deptCount = 0;\n}\n\nfunction* regionBreak(totals: BreakTotals): Generator<ReportLine> {\n  yield {\n    level: 'REGION',\n    region: totals.region,\n    total: totals.regionTotal\n  };\n  totals.grandTotal += totals.regionTotal;\n  totals.regionTotal = 0;\n}"
    },
    {
      "id": "NODE019",
      "category": "error_handling",
      "name": "Comprehensive Error Handling",
      "cobol": "       PROCEDURE DIVISION.\n           PERFORM WITH TEST AFTER UNTIL WS-SUCCESS = 'Y'\n                   OR WS-RETRY-COUNT > 3\n               PERFORM ATTEMPT-OPERATION\n           END-PERFORM\n           \n           IF WS-SUCCESS NOT = 'Y'\n               MOVE 'OPERATION FAILED AFTER RETRIES' \n                   TO WS-ERROR-MSG\n               PERFORM ABEND-ROUTINE\n           END-IF.\n       \n       ATTEMPT-OPERATION.\n           ADD 1 TO WS-RETRY-COUNT\n           \n           EXEC SQL\n               UPDATE ACCOUNTS SET ...\n           END-EXEC\n           \n           EVALUATE SQLCODE\n               WHEN 0\n                   MOVE 'Y' TO WS-SUCCESS\n               WHEN -911\n                   EXEC SQL ROLLBACK END-EXEC\n                   CALL 'DELAY' USING WS-RETRY-DELAY\n               WHEN -904\n                   MOVE 'RESOURCE UNAVAILABLE' TO WS-ERROR-MSG\n                   PERFORM LOG-ERROR\n               WHEN OTHER\n                   MOVE SQLCODE TO WS-SQL-ERROR\n                   PERFORM LOG-ERROR\n                   MOVE 'Y' TO WS-FATAL-ERROR\n           END-EVALUATE.\n       \n       ABEND-ROUTINE.\n           PERFORM LOG-ERROR\n           EXEC SQL ROLLBACK END-EXEC\n           CALL 'ABEND' USING WS-ABEND-CODE.",
      "typescript": "import { PrismaClient, Prisma } from '@prisma/client';\n\nclass RetryableError extends Error {\n  constructor(message: string, public readonly retryable: boolean = true) {\n    super(message);\n    this.name = 'RetryableError';\n  }\n}\n\ninterface RetryConfig {\n  maxRetries: number;\n  baseDelayMs: number;\n  maxDelayMs: number;\n}\n\nconst defaultRetryConfig: RetryConfig = {\n  maxRetries: 3,\n  baseDelayMs: 1000,\n  maxDelayMs: 10000\n};\n\nasync function withRetry<T>(\n  operation: () => Promise<T>,\n  config: RetryConfig = defaultRetryConfig\n): Promise<T> {\n  let lastError: Error | undefined;\n  \n  for (let attempt = 1; attempt <= config.maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error as Error;\n      \n      // Check if retryable\n      if (error instanceof Prisma.PrismaClientKnownRequestError) {\n        // Deadlock or timeout - retryable\n        if (['P2034', 'P2024'].includes(error.code)) {\n          const delay = Math.min(\n            config.baseDelayMs * Math.pow(2, attempt - 1),\n            config.maxDelayMs\n          );\n          \n          logger.warn(`Retrying after ${delay}ms`, {\n            attempt,\n            errorCode: error.code\n          });\n          \n          await sleep(delay);\n          continue;\n        }\n      }\n      \n      // Non-retryable error\n      throw error;\n    }\n  }\n  \n  // All retries exhausted\n  throw new Error(\n    `Operation failed after ${config.maxRetries} retries: ${lastError?.message}`\n  );\n}\n\nasync function updateAccountWithRetry(\n  prisma: PrismaClient,\n  accountId: string,\n  amount: number\n): Promise<void> {\n  await withRetry(async () => {\n    await prisma.$transaction(async (tx) => {\n      await tx.account.update({\n        where: { id: accountId },\n        data: { balance: { increment: amount } }\n      });\n    });\n  });\n}\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}"
    },
    {
      "id": "NODE020",
      "category": "data_validation",
      "name": "Field Validation with 88 Levels",
      "cobol": "       01  WS-INPUT-RECORD.\n           05  WS-TRANS-TYPE       PIC X.\n               88  VALID-TRANS-TYPE VALUE 'C' 'D' 'T' 'I'.\n               88  IS-CREDIT        VALUE 'C'.\n               88  IS-DEBIT         VALUE 'D'.\n               88  IS-TRANSFER      VALUE 'T'.\n               88  IS-INQUIRY       VALUE 'I'.\n           05  WS-AMOUNT           PIC 9(9)V99.\n           05  WS-ACCOUNT          PIC 9(10).\n           05  WS-DATE             PIC 9(8).\n       \n       PROCEDURE DIVISION.\n           IF NOT VALID-TRANS-TYPE\n               MOVE 'INVALID TRANSACTION TYPE' TO WS-ERROR\n               PERFORM REJECT-RECORD\n           END-IF\n           \n           IF WS-AMOUNT = ZEROS AND NOT IS-INQUIRY\n               MOVE 'ZERO AMOUNT NOT ALLOWED' TO WS-ERROR\n               PERFORM REJECT-RECORD\n           END-IF\n           \n           IF WS-ACCOUNT = ZEROS\n               MOVE 'INVALID ACCOUNT NUMBER' TO WS-ERROR\n               PERFORM REJECT-RECORD\n           END-IF.",
      "typescript": "import { z } from 'zod';\n\n// Transaction types as enum (replacing 88-levels)\nenum TransactionType {\n  Credit = 'C',\n  Debit = 'D',\n  Transfer = 'T',\n  Inquiry = 'I'\n}\n\n// Zod schema with custom validations\nconst InputRecordSchema = z.object({\n  transType: z.nativeEnum(TransactionType),\n  amount: z.number().min(0),\n  account: z.string().regex(/^\\d{10}$/),\n  date: z.string().regex(/^\\d{8}$/)\n}).refine(\n  (data) => {\n    // Zero amount only allowed for inquiry\n    if (data.amount === 0 && data.transType !== TransactionType.Inquiry) {\n      return false;\n    }\n    return true;\n  },\n  { message: 'Zero amount not allowed for this transaction type' }\n).refine(\n  (data) => data.account !== '0000000000',\n  { message: 'Invalid account number' }\n);\n\ntype InputRecord = z.infer<typeof InputRecordSchema>;\n\ninterface ValidationResult {\n  valid: boolean;\n  data?: InputRecord;\n  errors: string[];\n}\n\nfunction validateInputRecord(input: unknown): ValidationResult {\n  const result = InputRecordSchema.safeParse(input);\n  \n  if (result.success) {\n    return { valid: true, data: result.data, errors: [] };\n  }\n  \n  return {\n    valid: false,\n    errors: result.error.errors.map(e => e.message)\n  };\n}\n\n// Type guards (replacing 88-level conditions)\nfunction isCredit(type: TransactionType): boolean {\n  return type === TransactionType.Credit;\n}\n\nfunction isDebit(type: TransactionType): boolean {\n  return type === TransactionType.Debit;\n}\n\nfunction isTransfer(type: TransactionType): boolean {\n  return type === TransactionType.Transfer;\n}\n\nfunction isInquiry(type: TransactionType): boolean {\n  return type === TransactionType.Inquiry;\n}"
    },
    {
      "id": "NODE021",
      "category": "packed_decimal",
      "name": "Packed Decimal Handling",
      "cobol": "       01  WS-PACKED-FIELDS.\n           05  WS-AMOUNT-PD      PIC S9(13)V99 COMP-3.\n           05  WS-QUANTITY-PD    PIC S9(7) COMP-3.\n           05  WS-RATE-PD        PIC S9(3)V9(6) COMP-3.\n       \n       PROCEDURE DIVISION.\n           MOVE 12345.67 TO WS-AMOUNT-PD\n           COMPUTE WS-TOTAL-PD = WS-AMOUNT-PD * WS-QUANTITY-PD\n           \n           IF WS-AMOUNT-PD < ZEROS\n               MOVE 'NEGATIVE' TO WS-SIGN-IND\n           ELSE\n               MOVE 'POSITIVE' TO WS-SIGN-IND\n           END-IF.",
      "typescript": "import Decimal from 'decimal.js';\n\n// Configure for financial calculations\nDecimal.set({\n  precision: 20,\n  rounding: Decimal.ROUND_HALF_EVEN  // Banker's rounding\n});\n\n// Packed decimal field class with precision tracking\nclass PackedDecimal {\n  private value: Decimal;\n  private intDigits: number;\n  private decDigits: number;\n\n  constructor(intDigits: number, decDigits: number, value: number | string = 0) {\n    this.intDigits = intDigits;\n    this.decDigits = decDigits;\n    this.value = new Decimal(value).toDecimalPlaces(decDigits);\n    this.validate();\n  }\n\n  private validate(): void {\n    const maxValue = new Decimal(10).pow(this.intDigits).minus(1)\n      .plus(new Decimal(10).pow(-this.decDigits).times(\n        new Decimal(10).pow(this.decDigits).minus(1)\n      ));\n    \n    if (this.value.abs().greaterThan(maxValue)) {\n      throw new Error(`Value exceeds S9(${this.intDigits})V9(${this.decDigits})`);\n    }\n  }\n\n  get isNegative(): boolean {\n    return this.value.isNegative();\n  }\n\n  get isPositive(): boolean {\n    return this.value.isPositive();\n  }\n\n  multiply(other: PackedDecimal): PackedDecimal {\n    const result = this.value.times(other.value);\n    return new PackedDecimal(\n      this.intDigits + other.intDigits,\n      this.decDigits + other.decDigits,\n      result.toString()\n    );\n  }\n\n  add(other: PackedDecimal): PackedDecimal {\n    const result = this.value.plus(other.value);\n    return new PackedDecimal(\n      Math.max(this.intDigits, other.intDigits) + 1,\n      Math.max(this.decDigits, other.decDigits),\n      result.toString()\n    );\n  }\n\n  toNumber(): number {\n    return this.value.toNumber();\n  }\n\n  toString(): string {\n    return this.value.toFixed(this.decDigits);\n  }\n}\n\n// Usage\nconst amount = new PackedDecimal(13, 2, 12345.67);\nconst quantity = new PackedDecimal(7, 0, 100);\nconst total = amount.multiply(quantity);\n\nconst signInd = amount.isNegative ? 'NEGATIVE' : 'POSITIVE';"
    },
    {
      "id": "NODE022",
      "category": "date_handling",
      "name": "Date Conversions",
      "cobol": "       01  WS-DATE-FIELDS.\n           05  WS-CYMD-DATE       PIC 9(8).   *> CCYYMMDD\n           05  WS-CYMD-REDEF REDEFINES WS-CYMD-DATE.\n               10  WS-CYMD-CC     PIC 99.\n               10  WS-CYMD-YY     PIC 99.\n               10  WS-CYMD-MM     PIC 99.\n               10  WS-CYMD-DD     PIC 99.\n           05  WS-JULIAN-DATE    PIC 9(7).   *> CCYYDDD\n           05  WS-FORMATTED      PIC X(10).  *> MM/DD/CCYY\n       \n       PROCEDURE DIVISION.\n           ACCEPT WS-CYMD-DATE FROM DATE YYYYMMDD\n           \n           STRING WS-CYMD-MM '/' WS-CYMD-DD '/' \n                  WS-CYMD-CC WS-CYMD-YY\n               DELIMITED BY SIZE INTO WS-FORMATTED\n           END-STRING\n           \n           COMPUTE WS-JULIAN-DATE = \n               FUNCTION INTEGER-OF-DATE(WS-CYMD-DATE).",
      "typescript": "import { format, parse, isValid, differenceInDays, addDays } from 'date-fns';\n\ninterface DateFields {\n  century: string;\n  year: string;\n  month: string;\n  day: string;\n}\n\n// Parse CCYYMMDD format\nfunction parseCYMD(cymdDate: string): Date {\n  const parsed = parse(cymdDate, 'yyyyMMdd', new Date());\n  if (!isValid(parsed)) {\n    throw new Error(`Invalid date: ${cymdDate}`);\n  }\n  return parsed;\n}\n\n// Format to MM/DD/CCYY\nfunction formatMMDDCCYY(date: Date): string {\n  return format(date, 'MM/dd/yyyy');\n}\n\n// Extract date components (like REDEFINES)\nfunction extractDateFields(cymdDate: string): DateFields {\n  return {\n    century: cymdDate.substring(0, 2),\n    year: cymdDate.substring(2, 4),\n    month: cymdDate.substring(4, 6),\n    day: cymdDate.substring(6, 8)\n  };\n}\n\n// Convert to Julian date (CCYYDDD)\nfunction toJulianDate(date: Date): string {\n  const year = date.getFullYear();\n  const startOfYear = new Date(year, 0, 1);\n  const dayOfYear = differenceInDays(date, startOfYear) + 1;\n  return `${year}${String(dayOfYear).padStart(3, '0')}`;\n}\n\n// Parse Julian date\nfunction fromJulianDate(julian: string): Date {\n  const year = parseInt(julian.substring(0, 4));\n  const dayOfYear = parseInt(julian.substring(4, 7));\n  const startOfYear = new Date(year, 0, 1);\n  return addDays(startOfYear, dayOfYear - 1);\n}\n\n// Date arithmetic\nfunction addBusinessDays(date: Date, days: number): Date {\n  let result = date;\n  let added = 0;\n  \n  while (added < days) {\n    result = addDays(result, 1);\n    const dayOfWeek = result.getDay();\n    if (dayOfWeek !== 0 && dayOfWeek !== 6) {\n      added++;\n    }\n  }\n  \n  return result;\n}"
    },
    {
      "id": "NODE023",
      "category": "copybook",
      "name": "Copybook to Shared Module",
      "cobol": "      * CUSTOMER.CPY - Customer copybook\n       01  CUSTOMER-RECORD.\n           05  CUST-KEY.\n               10  CUST-ID          PIC 9(10).\n           05  CUST-DATA.\n               10  CUST-NAME        PIC X(50).\n               10  CUST-TYPE        PIC X.\n                   88  RETAIL       VALUE 'R'.\n                   88  COMMERCIAL   VALUE 'C'.\n                   88  GOVERNMENT   VALUE 'G'.\n               10  CUST-STATUS      PIC X.\n                   88  ACTIVE       VALUE 'A'.\n                   88  INACTIVE     VALUE 'I'.\n               10  CUST-BALANCE     PIC S9(11)V99 COMP-3.\n               10  CUST-CREDIT-LMT  PIC S9(11)V99 COMP-3.\n               10  CUST-LAST-ACT    PIC 9(8).\n               10  CUST-OPEN-DATE   PIC 9(8).",
      "typescript": "// customer.types.ts - Shared type definitions\n\nexport enum CustomerType {\n  Retail = 'R',\n  Commercial = 'C',\n  Government = 'G'\n}\n\nexport enum CustomerStatus {\n  Active = 'A',\n  Inactive = 'I'\n}\n\nexport interface CustomerKey {\n  custId: string;  // 10 digits\n}\n\nexport interface CustomerData {\n  custName: string;\n  custType: CustomerType;\n  custStatus: CustomerStatus;\n  custBalance: number;\n  custCreditLimit: number;\n  custLastActivity: Date;\n  custOpenDate: Date;\n}\n\nexport interface CustomerRecord extends CustomerKey, CustomerData {}\n\n// Type guards\nexport function isRetail(customer: CustomerRecord): boolean {\n  return customer.custType === CustomerType.Retail;\n}\n\nexport function isCommercial(customer: CustomerRecord): boolean {\n  return customer.custType === CustomerType.Commercial;\n}\n\nexport function isGovernment(customer: CustomerRecord): boolean {\n  return customer.custType === CustomerType.Government;\n}\n\nexport function isActive(customer: CustomerRecord): boolean {\n  return customer.custStatus === CustomerStatus.Active;\n}\n\n// Validation schema\nimport { z } from 'zod';\n\nexport const CustomerRecordSchema = z.object({\n  custId: z.string().regex(/^\\d{10}$/),\n  custName: z.string().max(50),\n  custType: z.nativeEnum(CustomerType),\n  custStatus: z.nativeEnum(CustomerStatus),\n  custBalance: z.number(),\n  custCreditLimit: z.number().min(0),\n  custLastActivity: z.date(),\n  custOpenDate: z.date()\n});\n\n// Factory function\nexport function createCustomer(\n  partial: Partial<CustomerRecord> & CustomerKey\n): CustomerRecord {\n  return {\n    ...partial,\n    custName: partial.custName || '',\n    custType: partial.custType || CustomerType.Retail,\n    custStatus: partial.custStatus || CustomerStatus.Active,\n    custBalance: partial.custBalance || 0,\n    custCreditLimit: partial.custCreditLimit || 0,\n    custLastActivity: partial.custLastActivity || new Date(),\n    custOpenDate: partial.custOpenDate || new Date()\n  };\n}"
    },
    {
      "id": "NODE024",
      "category": "mq_messaging",
      "name": "MQ Series to Message Queue",
      "cobol": "       WORKING-STORAGE SECTION.\n           COPY CMQV.\n       01  WS-MQMD.\n           COPY CMQMDV.\n       01  WS-MQPMO.\n           COPY CMQPMOV.\n       01  WS-MQGMO.\n           COPY CMQGMOV.\n       \n       PROCEDURE DIVISION.\n       SEND-MESSAGE.\n           MOVE MQMT-REQUEST TO MQMD-MSGTYPE\n           MOVE MQPMO-NEW-MSG-ID TO MQPMO-OPTIONS\n           \n           CALL 'MQPUT' USING WS-HCONN\n                              WS-HOBJ\n                              WS-MQMD\n                              WS-MQPMO\n                              WS-MSG-LEN\n                              WS-MESSAGE\n                              WS-COMPCODE\n                              WS-REASON\n           \n           IF WS-COMPCODE NOT = MQCC-OK\n               PERFORM HANDLE-MQ-ERROR\n           END-IF.\n       \n       RECEIVE-MESSAGE.\n           MOVE MQGMO-WAIT TO MQGMO-OPTIONS\n           MOVE 30000 TO MQGMO-WAITINTERVAL\n           \n           CALL 'MQGET' USING WS-HCONN\n                              WS-HOBJ\n                              WS-MQMD\n                              WS-MQGMO\n                              WS-BUFFER-LEN\n                              WS-BUFFER\n                              WS-DATA-LEN\n                              WS-COMPCODE\n                              WS-REASON.",
      "typescript": "import amqp, { Channel, Connection, ConsumeMessage } from 'amqplib';\n\ninterface MessageOptions {\n  correlationId?: string;\n  replyTo?: string;\n  persistent?: boolean;\n  expiration?: string;\n  headers?: Record<string, unknown>;\n}\n\ninterface QueueMessage<T> {\n  content: T;\n  properties: amqp.MessageProperties;\n}\n\nclass MessageQueueService {\n  private connection: Connection | null = null;\n  private channel: Channel | null = null;\n  private readonly url: string;\n\n  constructor(url: string) {\n    this.url = url;\n  }\n\n  async connect(): Promise<void> {\n    this.connection = await amqp.connect(this.url);\n    this.channel = await this.connection.createChannel();\n    \n    this.connection.on('error', (err) => {\n      console.error('MQ connection error:', err);\n    });\n  }\n\n  async sendMessage<T>(\n    queueName: string,\n    message: T,\n    options: MessageOptions = {}\n  ): Promise<boolean> {\n    if (!this.channel) {\n      throw new Error('Not connected to message queue');\n    }\n\n    await this.channel.assertQueue(queueName, { durable: true });\n\n    const content = Buffer.from(JSON.stringify(message));\n    \n    return this.channel.sendToQueue(queueName, content, {\n      persistent: options.persistent ?? true,\n      correlationId: options.correlationId,\n      replyTo: options.replyTo,\n      expiration: options.expiration,\n      headers: options.headers\n    });\n  }\n\n  async receiveMessage<T>(\n    queueName: string,\n    timeoutMs: number = 30000\n  ): Promise<QueueMessage<T> | null> {\n    if (!this.channel) {\n      throw new Error('Not connected to message queue');\n    }\n\n    await this.channel.assertQueue(queueName, { durable: true });\n\n    return new Promise((resolve) => {\n      const timeout = setTimeout(() => {\n        resolve(null);\n      }, timeoutMs);\n\n      this.channel!.consume(queueName, (msg) => {\n        clearTimeout(timeout);\n        \n        if (msg) {\n          this.channel!.ack(msg);\n          resolve({\n            content: JSON.parse(msg.content.toString()) as T,\n            properties: msg.properties\n          });\n        } else {\n          resolve(null);\n        }\n      }, { noAck: false });\n    });\n  }\n\n  async startConsumer<T>(\n    queueName: string,\n    handler: (message: QueueMessage<T>) => Promise<void>\n  ): Promise<void> {\n    if (!this.channel) {\n      throw new Error('Not connected to message queue');\n    }\n\n    await this.channel.assertQueue(queueName, { durable: true });\n    await this.channel.prefetch(1);\n\n    this.channel.consume(queueName, async (msg) => {\n      if (msg) {\n        try {\n          await handler({\n            content: JSON.parse(msg.content.toString()) as T,\n            properties: msg.properties\n          });\n          this.channel!.ack(msg);\n        } catch (error) {\n          // Negative acknowledgment - requeue\n          this.channel!.nack(msg, false, true);\n        }\n      }\n    });\n  }\n\n  async close(): Promise<void> {\n    if (this.channel) {\n      await this.channel.close();\n    }\n    if (this.connection) {\n      await this.connection.close();\n    }\n  }\n}"
    },
    {
      "id": "NODE025",
      "category": "report_generation",
      "name": "Report Writer to PDF/HTML",
      "cobol": "       WORKING-STORAGE SECTION.\n       01  WS-PAGE-CTR          PIC 9(4) VALUE ZEROS.\n       01  WS-LINE-CTR          PIC 99 VALUE ZEROS.\n       01  WS-LINES-PER-PAGE    PIC 99 VALUE 55.\n       \n       01  REPORT-HEADER.\n           05  FILLER            PIC X(30) VALUE SPACES.\n           05  FILLER            PIC X(25) \n               VALUE 'CUSTOMER ACTIVITY REPORT'.\n           05  FILLER            PIC X(15) VALUE SPACES.\n           05  HDR-DATE          PIC X(10).\n           05  FILLER            PIC X(5) VALUE SPACES.\n           05  FILLER            PIC X(5) VALUE 'PAGE '.\n           05  HDR-PAGE          PIC Z,ZZ9.\n       \n       01  DETAIL-LINE.\n           05  DET-CUST-ID       PIC X(10).\n           05  FILLER            PIC X(3) VALUE SPACES.\n           05  DET-CUST-NAME     PIC X(30).\n           05  FILLER            PIC X(3) VALUE SPACES.\n           05  DET-BALANCE       PIC $$$,$$$,$$9.99-.\n       \n       PROCEDURE DIVISION.\n           IF WS-LINE-CTR >= WS-LINES-PER-PAGE\n               PERFORM PRINT-HEADER\n           END-IF\n           \n           MOVE CUST-ID TO DET-CUST-ID\n           MOVE CUST-NAME TO DET-CUST-NAME\n           MOVE CUST-BALANCE TO DET-BALANCE\n           WRITE RPT-REC FROM DETAIL-LINE\n           ADD 1 TO WS-LINE-CTR.",
      "typescript": "import PDFDocument from 'pdfkit';\nimport { createWriteStream } from 'fs';\n\ninterface ReportConfig {\n  title: string;\n  date: Date;\n  linesPerPage: number;\n  margins: { top: number; bottom: number; left: number; right: number };\n}\n\ninterface CustomerDetailLine {\n  custId: string;\n  custName: string;\n  balance: number;\n}\n\nclass ReportWriter {\n  private doc: PDFKit.PDFDocument;\n  private pageNumber = 0;\n  private lineCount = 0;\n  private config: ReportConfig;\n  private yPosition = 0;\n  private lineHeight = 15;\n\n  constructor(outputPath: string, config: ReportConfig) {\n    this.config = config;\n    this.doc = new PDFDocument({\n      margins: config.margins,\n      size: 'LETTER'\n    });\n    this.doc.pipe(createWriteStream(outputPath));\n  }\n\n  private printHeader(): void {\n    this.pageNumber++;\n    this.lineCount = 0;\n    \n    if (this.pageNumber > 1) {\n      this.doc.addPage();\n    }\n\n    this.yPosition = this.config.margins.top;\n\n    // Header line\n    this.doc\n      .fontSize(14)\n      .font('Helvetica-Bold')\n      .text(this.config.title, this.config.margins.left, this.yPosition, {\n        align: 'center'\n      });\n\n    this.yPosition += 25;\n\n    // Date and page number\n    this.doc\n      .fontSize(10)\n      .font('Helvetica')\n      .text(\n        `Date: ${this.formatDate(this.config.date)}`,\n        this.config.margins.left,\n        this.yPosition\n      )\n      .text(\n        `Page ${this.pageNumber.toLocaleString()}`,\n        400,\n        this.yPosition,\n        { align: 'right' }\n      );\n\n    this.yPosition += 20;\n\n    // Column headers\n    this.doc\n      .font('Helvetica-Bold')\n      .text('Customer ID', 50, this.yPosition)\n      .text('Customer Name', 150, this.yPosition)\n      .text('Balance', 400, this.yPosition, { align: 'right' });\n\n    this.yPosition += 5;\n    this.doc\n      .moveTo(50, this.yPosition)\n      .lineTo(550, this.yPosition)\n      .stroke();\n\n    this.yPosition += 10;\n    this.lineCount = 5;\n  }\n\n  writeDetailLine(detail: CustomerDetailLine): void {\n    if (this.lineCount >= this.config.linesPerPage || this.pageNumber === 0) {\n      this.printHeader();\n    }\n\n    this.doc\n      .fontSize(10)\n      .font('Courier')\n      .text(detail.custId, 50, this.yPosition)\n      .text(detail.custName.substring(0, 30), 150, this.yPosition)\n      .text(this.formatCurrency(detail.balance), 400, this.yPosition, {\n        align: 'right'\n      });\n\n    this.yPosition += this.lineHeight;\n    this.lineCount++;\n  }\n\n  private formatCurrency(amount: number): string {\n    const absAmount = Math.abs(amount);\n    const formatted = absAmount.toLocaleString('en-US', {\n      style: 'currency',\n      currency: 'USD'\n    });\n    return amount < 0 ? `${formatted}-` : formatted;\n  }\n\n  private formatDate(date: Date): string {\n    return date.toLocaleDateString('en-US');\n  }\n\n  finalize(): void {\n    this.doc.end();\n  }\n}"
    }
  ],
  "express_patterns": [
    {
      "id": "EXPRESS001",
      "name": "CICS Transaction to Express Route",
      "description": "Converting CICS transaction structure to Express.js middleware",
      "cobol_pattern": "EXEC CICS RECEIVE -> PROCESS -> EXEC CICS SEND",
      "express_equivalent": "router.post('/path', middleware, handler)"
    },
    {
      "id": "EXPRESS002",
      "name": "COMMAREA to Request/Response",
      "description": "Converting CICS COMMAREA to typed request/response interfaces",
      "pattern": "Define interfaces, use Zod for validation, structure controller responses"
    }
  ],
  "prisma_patterns": [
    {
      "id": "PRISMA001",
      "name": "DB2 Table to Prisma Model",
      "db2_ddl": "CREATE TABLE CUSTOMER (\n  CUST_ID CHAR(10) NOT NULL PRIMARY KEY,\n  CUST_NAME VARCHAR(50),\n  CUST_STATUS CHAR(1) DEFAULT 'A'\n)",
      "prisma_schema": "model Customer {\n  custId     String @id @db.Char(10) @map(\"CUST_ID\")\n  custName   String? @db.VarChar(50) @map(\"CUST_NAME\")\n  custStatus String @default(\"A\") @db.Char(1) @map(\"CUST_STATUS\")\n\n  @@map(\"CUSTOMER\")\n}"
    }
  ],
  "testing_patterns": [
    {
      "id": "TEST001",
      "name": "Unit Test Pattern",
      "framework": "Jest + TypeScript",
      "example": "describe('CustomerService', () => {\n  it('should calculate balance correctly', () => {\n    const service = new CustomerService();\n    const result = service.calculateBalance(1000, 500);\n    expect(result).toBe(1500);\n  });\n});"
    }
  ]
}

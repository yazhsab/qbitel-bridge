{
  "metadata": {
    "title": "RPG/400 to Modern Language Modernization Pairs",
    "version": "1.0.0",
    "description": "Comprehensive conversion patterns from RPG II, RPG III, RPG IV, and ILE RPG to Java and Python",
    "platforms": ["AS/400", "iSeries", "IBM i"],
    "total_pairs": 55
  },
  "conversion_pairs": [
    {
      "id": "RPG001",
      "category": "data_structures",
      "name": "Data Structure Definition",
      "rpg_iv": "       dcl-ds CustomerDS qualified;\n         custId char(10);\n         custName char(50);\n         address;\n           street char(30);\n           city char(20);\n           state char(2);\n           zip char(10);\n         endds;\n         balance packed(11:2);\n         status char(1);\n       end-ds;",
      "rpg_iii": "     D CustomerDS      DS\n     D  CustId                       10A\n     D  CustName                     50A\n     D  Street                       30A\n     D  City                         20A\n     D  State                         2A\n     D  Zip                          10A\n     D  Balance                      11P 2\n     D  Status                        1A",
      "java": "public class CustomerDS {\n    private String custId;        // 10 chars\n    private String custName;      // 50 chars\n    private Address address;\n    private BigDecimal balance;   // 11,2 precision\n    private char status;\n    \n    public static class Address {\n        private String street;    // 30 chars\n        private String city;      // 20 chars\n        private String state;     // 2 chars\n        private String zip;       // 10 chars\n        \n        // Getters and setters\n    }\n    \n    // Getters, setters, constructors\n}",
      "python": "from dataclasses import dataclass\nfrom decimal import Decimal\n\n@dataclass\nclass Address:\n    street: str   # max 30\n    city: str     # max 20\n    state: str    # max 2\n    zip: str      # max 10\n\n@dataclass\nclass CustomerDS:\n    cust_id: str           # max 10\n    cust_name: str         # max 50\n    address: Address\n    balance: Decimal       # precision 11, scale 2\n    status: str            # single char"
    },
    {
      "id": "RPG002",
      "category": "data_structures",
      "name": "Array Declarations",
      "rpg_iv": "       // Static array\n       dcl-s Items char(20) dim(100);\n       \n       // Array data structure\n       dcl-ds OrderLines dim(50) qualified;\n         lineNum packed(3:0);\n         itemCode char(15);\n         qty packed(7:0);\n         price packed(9:2);\n         total packed(11:2);\n       end-ds;\n       \n       // Runtime array size\n       dcl-s dynamicArr char(50) dim(*auto:1000);",
      "rpg_iii": "     D Items           S             20A   DIM(100)\n     D OrderLines      DS                  DIM(50)\n     D  LineNum                       3P 0\n     D  ItemCode                     15A\n     D  Qty                           7P 0\n     D  Price                         9P 2\n     D  Total                        11P 2",
      "java": "import java.util.ArrayList;\nimport java.util.List;\nimport java.math.BigDecimal;\n\n// Static array\nString[] items = new String[100];\n\n// Array of structures\npublic class OrderLine {\n    private int lineNum;\n    private String itemCode;\n    private int qty;\n    private BigDecimal price;\n    private BigDecimal total;\n    \n    // Getters and setters\n}\n\n// Fixed size list\nList<OrderLine> orderLines = new ArrayList<>(50);\n\n// Dynamic array\nList<String> dynamicArr = new ArrayList<>();",
      "python": "from dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import List\n\n# Static array\nitems: List[str] = [''] * 100\n\n@dataclass\nclass OrderLine:\n    line_num: int\n    item_code: str\n    qty: int\n    price: Decimal\n    total: Decimal\n\n# List of structures\norder_lines: List[OrderLine] = []\n\n# Dynamic list\ndynamic_arr: List[str] = []"
    },
    {
      "id": "RPG003",
      "category": "data_structures",
      "name": "Externally Described Data Structure",
      "rpg_iv": "       // File-based data structure\n       dcl-ds CustomerRec extname('CUSTPF') qualified;\n       end-ds;\n       \n       // Specific fields from file\n       dcl-ds OrderRec extname('ORDERPF') qualified;\n         *all;\n       end-ds;\n       \n       // Prefix to avoid name conflicts\n       dcl-ds InvRec extname('INVPF') prefix(inv_);\n       end-ds;",
      "rpg_iii": "     D CustomerRec   E DS                  EXTNAME(CUSTPF)\n     D OrderRec      E DS                  EXTNAME(ORDERPF)\n     D                                     PREFIX(ORD_)\n     D InvRec        E DS                  EXTNAME(INVPF)\n     D                                     PREFIX(INV_)",
      "java": "import jakarta.persistence.*;\n\n// JPA Entity mapping to database table\n@Entity\n@Table(name = \"CUSTPF\")\npublic class CustomerRec {\n    @Id\n    @Column(name = \"CUSTID\")\n    private String custId;\n    \n    @Column(name = \"CUSTNAME\")\n    private String custName;\n    \n    @Column(name = \"BALANCE\")\n    private BigDecimal balance;\n    \n    // All fields mapped from table definition\n}\n\n// With prefix equivalent using @Column mappings\n@Entity\n@Table(name = \"INVPF\")\npublic class InvRec {\n    @Column(name = \"INVNUM\")\n    private String invInvNum;  // prefix applied\n    \n    @Column(name = \"INVDATE\")\n    private LocalDate invInvDate;\n}",
      "python": "from sqlalchemy import Column, String, Numeric, Date\nfrom sqlalchemy.orm import declarative_base\nfrom decimal import Decimal\n\nBase = declarative_base()\n\n# SQLAlchemy model from database table\nclass CustomerRec(Base):\n    __tablename__ = 'CUSTPF'\n    \n    cust_id = Column('CUSTID', String(10), primary_key=True)\n    cust_name = Column('CUSTNAME', String(50))\n    balance = Column('BALANCE', Numeric(11, 2))\n\n# With prefix in attribute names\nclass InvRec(Base):\n    __tablename__ = 'INVPF'\n    \n    inv_invnum = Column('INVNUM', String(10), primary_key=True)\n    inv_invdate = Column('INVDATE', Date)"
    },
    {
      "id": "RPG004",
      "category": "file_operations",
      "name": "Physical File Operations (CRUD)",
      "rpg_iv": "       dcl-f CUSTPF disk(*ext) usage(*update:*delete:*output)\n              keyed;\n       \n       // Read by key (CHAIN)\n       chain custKey CUSTPF;\n       if %found(CUSTPF);\n         // Record found\n         custName = newName;\n         update CUSTPF;\n       else;\n         // Insert new record\n         custId = custKey;\n         custName = newName;\n         write CUSTPF;\n       endif;\n       \n       // Delete\n       chain delKey CUSTPF;\n       if %found(CUSTPF);\n         delete CUSTPF;\n       endif;",
      "rpg_iii": "     FCUSTPF    UF   E           K DISK\n     C     CUSTKEY       CHAIN     CUSTPF\n     C                   IF        %FOUND(CUSTPF)\n     C                   EVAL      CUSTNAME = NEWNAME\n     C                   UPDATE    CUSTPF\n     C                   ELSE\n     C                   EVAL      CUSTID = CUSTKEY\n     C                   WRITE     CUSTPF\n     C                   ENDIF",
      "java": "import org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\nimport java.util.Optional;\n\n@Repository\npublic interface CustomerRepository extends JpaRepository<Customer, String> {\n}\n\n@Service\npublic class CustomerService {\n    private final CustomerRepository repo;\n    \n    // CHAIN equivalent - read by key\n    public Optional<Customer> findByKey(String custKey) {\n        return repo.findById(custKey);\n    }\n    \n    // CHAIN + UPDATE or WRITE\n    @Transactional\n    public Customer saveOrUpdate(String custKey, String newName) {\n        Optional<Customer> existing = repo.findById(custKey);\n        \n        if (existing.isPresent()) {\n            // UPDATE\n            Customer cust = existing.get();\n            cust.setCustName(newName);\n            return repo.save(cust);\n        } else {\n            // WRITE (insert)\n            Customer newCust = new Customer();\n            newCust.setCustId(custKey);\n            newCust.setCustName(newName);\n            return repo.save(newCust);\n        }\n    }\n    \n    // DELETE\n    @Transactional\n    public boolean delete(String delKey) {\n        if (repo.existsById(delKey)) {\n            repo.deleteById(delKey);\n            return true;\n        }\n        return false;\n    }\n}",
      "python": "from sqlalchemy.orm import Session\nfrom typing import Optional\n\nclass CustomerService:\n    def __init__(self, session: Session):\n        self.session = session\n    \n    # CHAIN equivalent - read by key\n    def find_by_key(self, cust_key: str) -> Optional[Customer]:\n        return self.session.get(Customer, cust_key)\n    \n    # CHAIN + UPDATE or WRITE\n    def save_or_update(self, cust_key: str, new_name: str) -> Customer:\n        existing = self.session.get(Customer, cust_key)\n        \n        if existing:\n            # UPDATE\n            existing.cust_name = new_name\n            self.session.commit()\n            return existing\n        else:\n            # WRITE (insert)\n            new_cust = Customer(\n                cust_id=cust_key,\n                cust_name=new_name\n            )\n            self.session.add(new_cust)\n            self.session.commit()\n            return new_cust\n    \n    # DELETE\n    def delete(self, del_key: str) -> bool:\n        customer = self.session.get(Customer, del_key)\n        if customer:\n            self.session.delete(customer)\n            self.session.commit()\n            return True\n        return False"
    },
    {
      "id": "RPG005",
      "category": "file_operations",
      "name": "Sequential File Processing",
      "rpg_iv": "       dcl-f TRANSIN disk(*ext) usage(*input);\n       dcl-f TRANSOUT disk(*ext) usage(*output);\n       \n       dow not %eof(TRANSIN);\n         read TRANSIN;\n         if not %eof(TRANSIN);\n           // Process record\n           exsr ProcessTrans;\n           write TRANSOUT;\n         endif;\n       enddo;",
      "rpg_iii": "     FTRANSIN   IF   E             DISK\n     FTRANSOUT  O    E             DISK\n     C                   DOW       NOT %EOF(TRANSIN)\n     C                   READ      TRANSIN\n     C                   IF        NOT %EOF(TRANSIN)\n     C                   EXSR      PROCTRANS\n     C                   WRITE     TRANSOUT\n     C                   ENDIF\n     C                   ENDDO",
      "java": "import java.io.*;\nimport java.nio.file.*;\nimport java.util.stream.Stream;\n\npublic class TransactionProcessor {\n    \n    public void processFile(Path inputPath, Path outputPath) \n            throws IOException {\n        \n        try (BufferedReader reader = Files.newBufferedReader(inputPath);\n             BufferedWriter writer = Files.newBufferedWriter(outputPath)) {\n            \n            String line;\n            while ((line = reader.readLine()) != null) {\n                // READ equivalent\n                TransRecord record = parseRecord(line);\n                \n                // EXSR ProcessTrans\n                TransRecord processed = processTrans(record);\n                \n                // WRITE equivalent\n                writer.write(formatRecord(processed));\n                writer.newLine();\n            }\n        }\n    }\n    \n    // Using Stream API\n    public void processFileStream(Path inputPath, Path outputPath) \n            throws IOException {\n        \n        try (Stream<String> lines = Files.lines(inputPath);\n             BufferedWriter writer = Files.newBufferedWriter(outputPath)) {\n            \n            lines.map(this::parseRecord)\n                 .map(this::processTrans)\n                 .map(this::formatRecord)\n                 .forEach(line -> {\n                     try {\n                         writer.write(line);\n                         writer.newLine();\n                     } catch (IOException e) {\n                         throw new UncheckedIOException(e);\n                     }\n                 });\n        }\n    }\n}",
      "python": "from pathlib import Path\nfrom typing import Iterator, Generator\nfrom dataclasses import dataclass\n\n@dataclass\nclass TransRecord:\n    trans_id: str\n    amount: float\n    status: str\n\ndef process_file(input_path: Path, output_path: Path) -> None:\n    with open(input_path, 'r') as infile, \\\n         open(output_path, 'w') as outfile:\n        \n        for line in infile:  # DOW NOT %EOF\n            # READ equivalent\n            record = parse_record(line)\n            \n            # EXSR ProcessTrans\n            processed = process_trans(record)\n            \n            # WRITE equivalent\n            outfile.write(format_record(processed) + '\\n')\n\n# Generator-based approach\ndef read_records(input_path: Path) -> Generator[TransRecord, None, None]:\n    with open(input_path, 'r') as f:\n        for line in f:\n            yield parse_record(line)\n\ndef process_all(input_path: Path, output_path: Path) -> None:\n    with open(output_path, 'w') as outfile:\n        for record in read_records(input_path):\n            processed = process_trans(record)\n            outfile.write(format_record(processed) + '\\n')"
    },
    {
      "id": "RPG006",
      "category": "file_operations",
      "name": "SETLL/SETGT and READE",
      "rpg_iv": "       // Position to key and read equal records\n       setll custKey ORDERPF;\n       reade custKey ORDERPF;\n       dow not %eof(ORDERPF);\n         // Process matching records\n         totalAmt += ordAmount;\n         orderCount += 1;\n         reade custKey ORDERPF;\n       enddo;\n       \n       // Position after key (SETGT)\n       setgt startKey TRANPF;\n       read TRANPF;",
      "rpg_iii": "     C     CUSTKEY       SETLL     ORDERPF\n     C     CUSTKEY       READE     ORDERPF\n     C                   DOW       NOT %EOF(ORDERPF)\n     C                   ADD       ORDAMT        TOTAMT\n     C                   ADD       1             ORDCNT\n     C     CUSTKEY       READE     ORDERPF\n     C                   ENDDO",
      "java": "import java.util.List;\nimport java.math.BigDecimal;\n\n@Repository\npublic interface OrderRepository extends JpaRepository<Order, String> {\n    // SETLL + READE equivalent\n    List<Order> findByCustIdOrderByOrderDate(String custId);\n    \n    // With range (SETGT equivalent)\n    @Query(\"SELECT o FROM Order o WHERE o.orderKey > :startKey ORDER BY o.orderKey\")\n    List<Order> findAfterKey(@Param(\"startKey\") String startKey);\n}\n\n@Service\npublic class OrderService {\n    private final OrderRepository repo;\n    \n    public OrderSummary processCustomerOrders(String custKey) {\n        BigDecimal totalAmt = BigDecimal.ZERO;\n        int orderCount = 0;\n        \n        // SETLL + READE loop\n        List<Order> orders = repo.findByCustIdOrderByOrderDate(custKey);\n        \n        for (Order order : orders) {\n            totalAmt = totalAmt.add(order.getOrdAmount());\n            orderCount++;\n        }\n        \n        return new OrderSummary(totalAmt, orderCount);\n    }\n    \n    // Stream-based approach\n    public OrderSummary processWithStream(String custKey) {\n        List<Order> orders = repo.findByCustIdOrderByOrderDate(custKey);\n        \n        BigDecimal total = orders.stream()\n            .map(Order::getOrdAmount)\n            .reduce(BigDecimal.ZERO, BigDecimal::add);\n        \n        return new OrderSummary(total, orders.size());\n    }\n}",
      "python": "from sqlalchemy import select\nfrom sqlalchemy.orm import Session\nfrom decimal import Decimal\nfrom dataclasses import dataclass\nfrom typing import Iterator\n\n@dataclass\nclass OrderSummary:\n    total_amt: Decimal\n    order_count: int\n\nclass OrderService:\n    def __init__(self, session: Session):\n        self.session = session\n    \n    def process_customer_orders(self, cust_key: str) -> OrderSummary:\n        total_amt = Decimal('0')\n        order_count = 0\n        \n        # SETLL + READE equivalent\n        stmt = select(Order).where(\n            Order.cust_id == cust_key\n        ).order_by(Order.order_date)\n        \n        for order in self.session.scalars(stmt):\n            total_amt += order.ord_amount\n            order_count += 1\n        \n        return OrderSummary(total_amt, order_count)\n    \n    # SETGT equivalent - find records after key\n    def find_after_key(self, start_key: str) -> Iterator[Order]:\n        stmt = select(Order).where(\n            Order.order_key > start_key\n        ).order_by(Order.order_key)\n        \n        return self.session.scalars(stmt)\n    \n    # Aggregate approach\n    def get_customer_totals(self, cust_key: str) -> OrderSummary:\n        from sqlalchemy import func\n        \n        result = self.session.execute(\n            select(\n                func.sum(Order.ord_amount),\n                func.count(Order.order_id)\n            ).where(Order.cust_id == cust_key)\n        ).one()\n        \n        return OrderSummary(\n            total_amt=result[0] or Decimal('0'),\n            order_count=result[1]\n        )"
    },
    {
      "id": "RPG007",
      "category": "control_flow",
      "name": "SELECT/WHEN/OTHER",
      "rpg_iv": "       select;\n         when transType = 'D';\n           exsr ProcessDeposit;\n         when transType = 'W';\n           exsr ProcessWithdrawal;\n         when transType = 'T';\n           exsr ProcessTransfer;\n         when transType = 'I';\n           exsr ProcessInquiry;\n         other;\n           exsr InvalidTrans;\n       endsl;",
      "rpg_iii": "     C                   SELECT\n     C     TRANSTYP      WHENEQ    'D'\n     C                   EXSR      PROCDEP\n     C     TRANSTYP      WHENEQ    'W'\n     C                   EXSR      PROCWITH\n     C     TRANSTYP      WHENEQ    'T'\n     C                   EXSR      PROCTRAN\n     C     TRANSTYP      WHENEQ    'I'\n     C                   EXSR      PROCINQ\n     C                   OTHER\n     C                   EXSR      INVALID\n     C                   ENDSL",
      "java": "// Using switch expression (Java 14+)\npublic void processTransaction(char transType) {\n    switch (transType) {\n        case 'D' -> processDeposit();\n        case 'W' -> processWithdrawal();\n        case 'T' -> processTransfer();\n        case 'I' -> processInquiry();\n        default -> invalidTrans();\n    }\n}\n\n// Using enum for type safety\npublic enum TransactionType {\n    DEPOSIT('D'),\n    WITHDRAWAL('W'),\n    TRANSFER('T'),\n    INQUIRY('I');\n    \n    private final char code;\n    \n    TransactionType(char code) {\n        this.code = code;\n    }\n    \n    public static TransactionType fromCode(char code) {\n        for (TransactionType t : values()) {\n            if (t.code == code) return t;\n        }\n        throw new IllegalArgumentException(\"Invalid type: \" + code);\n    }\n}\n\npublic void process(TransactionType type) {\n    switch (type) {\n        case DEPOSIT -> processDeposit();\n        case WITHDRAWAL -> processWithdrawal();\n        case TRANSFER -> processTransfer();\n        case INQUIRY -> processInquiry();\n    }\n}",
      "python": "from enum import Enum\nfrom typing import Callable\n\nclass TransactionType(Enum):\n    DEPOSIT = 'D'\n    WITHDRAWAL = 'W'\n    TRANSFER = 'T'\n    INQUIRY = 'I'\n\ndef process_transaction(trans_type: str) -> None:\n    match trans_type:\n        case 'D':\n            process_deposit()\n        case 'W':\n            process_withdrawal()\n        case 'T':\n            process_transfer()\n        case 'I':\n            process_inquiry()\n        case _:\n            invalid_trans()\n\n# Dictionary dispatch pattern\ndef process_with_dispatch(trans_type: str) -> None:\n    handlers: dict[str, Callable[[], None]] = {\n        'D': process_deposit,\n        'W': process_withdrawal,\n        'T': process_transfer,\n        'I': process_inquiry\n    }\n    \n    handler = handlers.get(trans_type, invalid_trans)\n    handler()"
    },
    {
      "id": "RPG008",
      "category": "control_flow",
      "name": "FOR Loop and DOW/DOU",
      "rpg_iv": "       // FOR loop\n       for i = 1 to 100;\n         total += values(i);\n       endfor;\n       \n       // FOR with BY (step)\n       for i = 100 downto 1 by 2;\n         process(array(i));\n       endfor;\n       \n       // DOW (Do While)\n       dow not done and count < maxCount;\n         read INPUTF;\n         if not %eof(INPUTF);\n           count += 1;\n         else;\n           done = *on;\n         endif;\n       enddo;\n       \n       // DOU (Do Until)\n       dou found or idx > tableSize;\n         if table(idx) = searchKey;\n           found = *on;\n         else;\n           idx += 1;\n         endif;\n       enddo;",
      "rpg_iii": "     C                   DO        100           I\n     C                   ADD       VALUES(I)     TOTAL\n     C                   ENDDO\n     C\n     C                   DOW       NOT DONE\n     C                   READ      INPUTF\n     C                   ADD       1             COUNT\n     C                   ENDDO",
      "java": "// FOR loop\nint total = 0;\nfor (int i = 0; i < 100; i++) {\n    total += values[i];\n}\n\n// FOR with step (BY 2, downto)\nfor (int i = 99; i >= 0; i -= 2) {\n    process(array[i]);\n}\n\n// DOW (while)\nboolean done = false;\nint count = 0;\nwhile (!done && count < maxCount) {\n    Record record = readRecord();\n    if (record != null) {\n        count++;\n    } else {\n        done = true;\n    }\n}\n\n// DOU (do-while - executes at least once)\nboolean found = false;\nint idx = 0;\ndo {\n    if (table[idx].equals(searchKey)) {\n        found = true;\n    } else {\n        idx++;\n    }\n} while (!found && idx <= tableSize);\n\n// Stream-based sum\nint total2 = Arrays.stream(values).limit(100).sum();",
      "python": "# FOR loop\ntotal = sum(values[:100])\n# or\ntotal = 0\nfor i in range(100):\n    total += values[i]\n\n# FOR with step (downto by 2)\nfor i in range(99, -1, -2):\n    process(array[i])\n\n# DOW (while)\ndone = False\ncount = 0\nwhile not done and count < max_count:\n    record = read_record()\n    if record is not None:\n        count += 1\n    else:\n        done = True\n\n# DOU (do-while equivalent)\nfound = False\nidx = 0\nwhile True:\n    if table[idx] == search_key:\n        found = True\n    else:\n        idx += 1\n    if found or idx > table_size:\n        break\n\n# Pythonic search\ntry:\n    idx = table.index(search_key)\n    found = True\nexcept ValueError:\n    found = False"
    },
    {
      "id": "RPG009",
      "category": "subroutines",
      "name": "Subroutines and Procedures",
      "rpg_iv": "       // Subroutine (local to program)\n       begsr CalcTax;\n         taxAmount = subTotal * taxRate;\n         taxAmount = %dec(taxAmount : 11 : 2);\n       endsr;\n       \n       // Procedure (can be exported)\n       dcl-proc CalcInterest export;\n         dcl-pi *n packed(11:2);\n           principal packed(11:2) const;\n           rate packed(5:4) const;\n           months int(5) const;\n         end-pi;\n         \n         dcl-s monthlyRate packed(7:6);\n         dcl-s result packed(11:2);\n         \n         monthlyRate = rate / 12;\n         result = principal * \n                  ((1 + monthlyRate) ** months - 1);\n         return result;\n       end-proc;",
      "rpg_iii": "     C     CALCTAX       BEGSR\n     C                   MULT      TAXRATE       SUBTOTAL      TAXAMT\n     C                   ENDSR\n     C\n     C     *ENTRY        PLIST\n     C                   PARM                    PRINCPL\n     C                   PARM                    RATE\n     C                   PARM                    MONTHS\n     C                   PARM                    RESULT",
      "java": "public class FinancialCalculator {\n    \n    private BigDecimal taxRate;\n    private BigDecimal subTotal;\n    private BigDecimal taxAmount;\n    \n    // Subroutine equivalent - private method\n    private void calcTax() {\n        taxAmount = subTotal.multiply(taxRate)\n            .setScale(2, RoundingMode.HALF_UP);\n    }\n    \n    // Procedure equivalent - public method with parameters\n    public static BigDecimal calcInterest(\n            BigDecimal principal,\n            BigDecimal rate,\n            int months) {\n        \n        BigDecimal monthlyRate = rate.divide(\n            BigDecimal.valueOf(12),\n            6,\n            RoundingMode.HALF_UP\n        );\n        \n        // (1 + monthlyRate)^months - 1\n        BigDecimal factor = monthlyRate.add(BigDecimal.ONE)\n            .pow(months)\n            .subtract(BigDecimal.ONE);\n        \n        return principal.multiply(factor)\n            .setScale(2, RoundingMode.HALF_UP);\n    }\n}",
      "python": "from decimal import Decimal, ROUND_HALF_UP\nfrom typing import Optional\n\nclass FinancialCalculator:\n    def __init__(self):\n        self.tax_rate: Optional[Decimal] = None\n        self.sub_total: Optional[Decimal] = None\n        self.tax_amount: Optional[Decimal] = None\n    \n    # Subroutine equivalent - private method\n    def _calc_tax(self) -> None:\n        self.tax_amount = (self.sub_total * self.tax_rate).quantize(\n            Decimal('0.01'),\n            rounding=ROUND_HALF_UP\n        )\n\n# Procedure equivalent - standalone function\ndef calc_interest(\n    principal: Decimal,\n    rate: Decimal,\n    months: int\n) -> Decimal:\n    monthly_rate = rate / 12\n    \n    # (1 + monthly_rate)^months - 1\n    factor = (1 + monthly_rate) ** months - 1\n    \n    result = principal * Decimal(str(factor))\n    return result.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)"
    },
    {
      "id": "RPG010",
      "category": "builtin_functions",
      "name": "String Built-in Functions",
      "rpg_iv": "       dcl-s result char(100);\n       dcl-s pos int(5);\n       dcl-s len int(5);\n       \n       // String operations\n       result = %trim(inputStr);\n       result = %trimr(inputStr);\n       result = %triml(inputStr);\n       \n       pos = %scan('search' : inputStr);\n       pos = %scan('x' : inputStr : startPos);\n       \n       result = %subst(inputStr : 5 : 10);\n       %subst(result : 1 : 5) = 'Hello';\n       \n       result = %xlate('abc' : 'ABC' : inputStr);\n       result = %replace(newStr : oldStr : 5 : 10);\n       \n       len = %len(%trim(inputStr));\n       result = %char(numericVal);\n       result = %editc(amount : 'J');",
      "java": "String result;\nint pos;\nint len;\n\n// String operations\nresult = inputStr.trim();              // %TRIM\nresult = inputStr.stripTrailing();     // %TRIMR (Java 11+)\nresult = inputStr.stripLeading();      // %TRIML (Java 11+)\n\npos = inputStr.indexOf(\"search\");      // %SCAN (0-based, -1 if not found)\npos = inputStr.indexOf('x', startPos); // %SCAN with start position\n\nresult = inputStr.substring(4, 14);    // %SUBST (0-based)\n// %SUBST on left side - use StringBuilder or String concatenation\nStringBuilder sb = new StringBuilder(result);\nsb.replace(0, 5, \"Hello\");\nresult = sb.toString();\n\n// %XLATE\nresult = inputStr.replace('a', 'A').replace('b', 'B').replace('c', 'C');\nresult = inputStr.toUpperCase();  // If just case conversion\n\n// %REPLACE\nresult = inputStr.substring(0, 4) + newStr + \n         inputStr.substring(14);\n\nlen = inputStr.trim().length();        // %LEN(%TRIM())\nresult = String.valueOf(numericVal);   // %CHAR\n\n// %EDITC - use DecimalFormat\nDecimalFormat df = new DecimalFormat(\"#,##0.00\");\nresult = df.format(amount);",
      "python": "# String operations\nresult = input_str.strip()      # %TRIM\nresult = input_str.rstrip()     # %TRIMR\nresult = input_str.lstrip()     # %TRIML\n\npos = input_str.find('search')  # %SCAN (0-based, -1 if not found)\npos = input_str.find('x', start_pos)  # %SCAN with start position\n\nresult = input_str[4:14]        # %SUBST (0-based)\n# %SUBST on left side\nresult = 'Hello' + result[5:]\n\n# %XLATE\ntrans_table = str.maketrans('abc', 'ABC')\nresult = input_str.translate(trans_table)\nresult = input_str.upper()      # If just case conversion\n\n# %REPLACE equivalent\nresult = input_str[:4] + new_str + input_str[14:]\n# Or for simple replacement:\nresult = input_str.replace(old_str, new_str)\n\nlen_val = len(input_str.strip())  # %LEN(%TRIM())\nresult = str(numeric_val)         # %CHAR\n\n# %EDITC - formatted output\nresult = f\"{amount:,.2f}\"\nresult = f\"${amount:>12,.2f}\""
    },
    {
      "id": "RPG011",
      "category": "builtin_functions",
      "name": "Numeric Built-in Functions",
      "rpg_iv": "       dcl-s result packed(11:2);\n       dcl-s intResult int(10);\n       \n       result = %abs(amount);\n       intResult = %int(decimalVal);\n       intResult = %inth(decimalVal);  // Half adjust\n       \n       result = %dec(charVal : 11 : 2);\n       result = %dech(charVal : 11 : 2);  // Half adjust\n       \n       result = %div(dividend : divisor);\n       intResult = %rem(dividend : divisor);\n       \n       result = %sqrt(value);\n       result = %xfoot(numericArray);\n       \n       intResult = %elem(myArray);\n       intResult = %size(dataStruct);\n       intResult = %lookup(searchVal : array);",
      "java": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\nimport java.util.Arrays;\n\nBigDecimal result;\nint intResult;\n\nresult = amount.abs();                          // %ABS\nintResult = decimalVal.intValue();              // %INT\nintResult = decimalVal.setScale(0, RoundingMode.HALF_UP).intValue();  // %INTH\n\nresult = new BigDecimal(charVal)\n    .setScale(2, RoundingMode.UNNECESSARY);     // %DEC\nresult = new BigDecimal(charVal)\n    .setScale(2, RoundingMode.HALF_UP);         // %DECH\n\nresult = dividend.divide(divisor, \n    2, RoundingMode.DOWN);                      // %DIV\nintResult = dividend.remainder(divisor).intValue();  // %REM\n\nresult = BigDecimal.valueOf(Math.sqrt(value.doubleValue()));  // %SQRT\n\n// %XFOOT - sum of array\nresult = Arrays.stream(numericArray)\n    .reduce(BigDecimal.ZERO, BigDecimal::add);\n\nintResult = myArray.length;                     // %ELEM\n// %SIZE - use reflection or predefined constant\n\n// %LOOKUP\nintResult = Arrays.asList(array).indexOf(searchVal);",
      "python": "from decimal import Decimal, ROUND_HALF_UP, ROUND_DOWN\nimport math\n\n# %ABS\nresult = abs(amount)\n\n# %INT\nint_result = int(decimal_val)\n\n# %INTH (half adjust)\nint_result = int(decimal_val.quantize(Decimal('1'), rounding=ROUND_HALF_UP))\n\n# %DEC\nresult = Decimal(char_val).quantize(Decimal('0.01'))\n\n# %DECH (half adjust)\nresult = Decimal(char_val).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)\n\n# %DIV\nresult = (dividend / divisor).quantize(Decimal('0.01'), rounding=ROUND_DOWN)\n\n# %REM\nint_result = int(dividend % divisor)\n\n# %SQRT\nresult = Decimal(str(math.sqrt(float(value))))\n\n# %XFOOT - sum of array\nresult = sum(numeric_array)\n\n# %ELEM\nint_result = len(my_array)\n\n# %LOOKUP\ntry:\n    int_result = array.index(search_val)\nexcept ValueError:\n    int_result = -1  # Not found"
    },
    {
      "id": "RPG012",
      "category": "builtin_functions",
      "name": "Date/Time Built-in Functions",
      "rpg_iv": "       dcl-s myDate date;\n       dcl-s myTime time;\n       dcl-s myTimestamp timestamp;\n       dcl-s isoDate char(10);\n       dcl-s result int(10);\n       \n       myDate = %date();                    // Current date\n       myDate = %date('2023-12-25' : *ISO);\n       myDate = %date(numDate : *CYMD);     // From numeric YYYYMMDD\n       \n       myTime = %time();\n       myTimestamp = %timestamp();\n       \n       isoDate = %char(myDate : *ISO);      // To string\n       \n       result = %diff(date1 : date2 : *days);\n       result = %diff(time1 : time2 : *hours);\n       \n       myDate = myDate + %days(30);\n       myDate = myDate + %months(3);\n       myDate = myDate + %years(1);\n       \n       result = %subdt(myTimestamp : *years);\n       result = %subdt(myDate : *months);",
      "java": "import java.time.*;\nimport java.time.format.DateTimeFormatter;\nimport java.time.temporal.ChronoUnit;\n\nLocalDate myDate;\nLocalTime myTime;\nLocalDateTime myTimestamp;\nString isoDate;\nlong result;\n\nmyDate = LocalDate.now();                         // %DATE()\nmyDate = LocalDate.parse(\"2023-12-25\");           // %DATE with ISO\nmyDate = LocalDate.parse(\"20231225\",\n    DateTimeFormatter.BASIC_ISO_DATE);            // From YYYYMMDD\n\nmyTime = LocalTime.now();                         // %TIME()\nmyTimestamp = LocalDateTime.now();                // %TIMESTAMP()\n\nisoDate = myDate.format(DateTimeFormatter.ISO_DATE);  // %CHAR with ISO\n\nresult = ChronoUnit.DAYS.between(date2, date1);   // %DIFF *DAYS\nresult = ChronoUnit.HOURS.between(time2, time1);  // %DIFF *HOURS\n\nmyDate = myDate.plusDays(30);                     // %DAYS\nmyDate = myDate.plusMonths(3);                    // %MONTHS\nmyDate = myDate.plusYears(1);                     // %YEARS\n\nresult = myTimestamp.getYear();                   // %SUBDT *YEARS\nresult = myDate.getMonthValue();                  // %SUBDT *MONTHS",
      "python": "from datetime import date, time, datetime, timedelta\nfrom dateutil.relativedelta import relativedelta\n\n# %DATE()\nmy_date = date.today()\nmy_date = date.fromisoformat('2023-12-25')  # %DATE with ISO\nmy_date = datetime.strptime('20231225', '%Y%m%d').date()  # From YYYYMMDD\n\n# %TIME()\nmy_time = datetime.now().time()\n\n# %TIMESTAMP()\nmy_timestamp = datetime.now()\n\n# %CHAR with ISO\niso_date = my_date.isoformat()\n\n# %DIFF\nresult = (date1 - date2).days  # *DAYS\nresult = int((datetime.combine(date.today(), time1) - \n              datetime.combine(date.today(), time2)).seconds / 3600)  # *HOURS\n\n# Date arithmetic\nmy_date = my_date + timedelta(days=30)        # %DAYS\nmy_date = my_date + relativedelta(months=3)   # %MONTHS\nmy_date = my_date + relativedelta(years=1)    # %YEARS\n\n# %SUBDT\nresult = my_timestamp.year    # *YEARS\nresult = my_date.month        # *MONTHS"
    },
    {
      "id": "RPG013",
      "category": "indicators",
      "name": "Indicator Handling",
      "rpg_iv": "       dcl-s found ind;\n       dcl-s eof ind;\n       dcl-s error ind;\n       \n       // Using indicators\n       found = *off;\n       chain custKey CUSTPF;\n       found = %found(CUSTPF);\n       \n       if found;\n         // Process found record\n       endif;\n       \n       // File status indicators\n       read INPUTF;\n       eof = %eof(INPUTF);\n       error = %error;\n       \n       // *IN array (numbered indicators)\n       *in50 = *on;\n       if *in50;\n         // Do something\n       endif;",
      "rpg_iii": "     C     CUSTKEY       CHAIN     CUSTPF                           50\n     C  N50              EXSR      PROCFOUND\n     C   50              EXSR      NOTFOUND\n     C\n     C                   READ      INPUTF                             LR\n     C   LR              GOTO      ENDPGM",
      "java": "public class IndicatorExample {\n    // Indicators become boolean fields/variables\n    private boolean found = false;\n    private boolean eof = false;\n    private boolean error = false;\n    \n    // For numbered indicators, use an array or EnumSet\n    private boolean[] indicators = new boolean[100];  // *IN01-*IN99\n    \n    public void processRecord(String custKey) {\n        found = false;\n        \n        // CHAIN equivalent with %FOUND\n        Optional<Customer> customer = repository.findById(custKey);\n        found = customer.isPresent();\n        \n        if (found) {\n            processFoundRecord(customer.get());\n        }\n    }\n    \n    public void readFile() {\n        try {\n            Record record = reader.read();\n            eof = (record == null);\n            error = false;\n        } catch (IOException e) {\n            error = true;\n        }\n    }\n    \n    // Using numbered indicators\n    public void withIndicators() {\n        indicators[50] = true;  // *IN50 = *ON\n        \n        if (indicators[50]) {\n            // Do something\n        }\n    }\n}",
      "python": "from typing import Optional\nfrom dataclasses import dataclass, field\n\nclass IndicatorExample:\n    def __init__(self):\n        # Indicators become boolean attributes\n        self.found = False\n        self.eof = False\n        self.error = False\n        \n        # For numbered indicators\n        self.indicators = [False] * 100  # IN01-IN99\n    \n    def process_record(self, cust_key: str) -> None:\n        self.found = False\n        \n        # CHAIN equivalent with %FOUND\n        customer = self.repository.find_by_id(cust_key)\n        self.found = customer is not None\n        \n        if self.found:\n            self.process_found_record(customer)\n    \n    def read_file(self) -> None:\n        try:\n            record = self.reader.read()\n            self.eof = record is None\n            self.error = False\n        except IOError:\n            self.error = True\n    \n    def with_indicators(self) -> None:\n        self.indicators[50] = True  # *IN50 = *ON\n        \n        if self.indicators[50]:\n            pass  # Do something\n\n# Using dataclass for cleaner structure\n@dataclass\nclass FileStatus:\n    found: bool = False\n    eof: bool = False\n    error: bool = False\n    equal: bool = False"
    },
    {
      "id": "RPG014",
      "category": "display_file",
      "name": "Display File (5250) to Web API",
      "rpg_iv": "       dcl-f CUSTDSP workstn;\n       \n       // Write subfile\n       sflRrn = 0;\n       setll *start CUSTPF;\n       read CUSTPF;\n       dow not %eof(CUSTPF);\n         sflRrn += 1;\n         write SFLREC;\n         read CUSTPF;\n       enddo;\n       \n       // Display and get input\n       exfmt MAINCTL;\n       \n       select;\n         when cmdKey = F3;\n           *inlr = *on;\n         when cmdKey = ENTER;\n           chain inputCustId CUSTPF;\n           if %found;\n             exfmt DETAIL;\n           endif;\n       endsl;",
      "java": "import org.springframework.web.bind.annotation.*;\nimport org.springframework.http.ResponseEntity;\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/api/customers\")\npublic class CustomerController {\n    \n    private final CustomerService customerService;\n    \n    // Subfile display equivalent - return list\n    @GetMapping\n    public ResponseEntity<List<CustomerDTO>> listCustomers(\n            @RequestParam(defaultValue = \"0\") int page,\n            @RequestParam(defaultValue = \"20\") int size) {\n        \n        Page<Customer> customers = customerService.findAll(\n            PageRequest.of(page, size)\n        );\n        \n        List<CustomerDTO> dtoList = customers.stream()\n            .map(this::toDTO)\n            .toList();\n        \n        return ResponseEntity.ok(dtoList);\n    }\n    \n    // EXFMT with ENTER - submit form data\n    @PostMapping(\"/{custId}\")\n    public ResponseEntity<CustomerDTO> processInput(\n            @PathVariable String custId,\n            @RequestBody CustomerInput input) {\n        \n        Customer customer = customerService.findById(custId)\n            .orElseThrow(() -> new NotFoundException(\"Customer not found\"));\n        \n        // Process based on action (replaces function key handling)\n        return ResponseEntity.ok(toDTO(customer));\n    }\n    \n    // F3 equivalent - handled by frontend navigation\n    // Function keys become API actions or frontend routing\n}\n\n// React frontend equivalent\n/*\nfunction CustomerList() {\n  const [customers, setCustomers] = useState([]);\n  \n  // F5 Refresh\n  const refresh = () => fetchCustomers();\n  \n  // F3 Exit\n  const exit = () => navigate('/');\n  \n  // Enter - select\n  const selectCustomer = (id) => navigate(`/customer/${id}`);\n}\n*/",
      "python": "from fastapi import FastAPI, HTTPException, Query\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\napp = FastAPI()\n\nclass CustomerDTO(BaseModel):\n    cust_id: str\n    cust_name: str\n    balance: float\n\nclass CustomerInput(BaseModel):\n    action: str\n    cust_id: Optional[str] = None\n\n# Subfile display equivalent - return list\n@app.get(\"/api/customers\", response_model=List[CustomerDTO])\nasync def list_customers(\n    page: int = Query(0, ge=0),\n    size: int = Query(20, ge=1, le=100)\n):\n    customers = customer_service.find_all(\n        offset=page * size,\n        limit=size\n    )\n    return [to_dto(c) for c in customers]\n\n# EXFMT with ENTER - process form\n@app.post(\"/api/customers/{cust_id}\")\nasync def process_input(cust_id: str, input_data: CustomerInput):\n    customer = customer_service.find_by_id(cust_id)\n    if not customer:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    \n    # Process based on action\n    return to_dto(customer)\n\n# Function key mapping to API endpoints/actions\n# F3 = Exit -> Frontend navigation\n# F5 = Refresh -> GET /api/customers\n# F6 = Add -> POST /api/customers\n# F12 = Cancel -> Frontend navigation back"
    },
    {
      "id": "RPG015",
      "category": "service_programs",
      "name": "Service Program to Microservice",
      "rpg_iv": "       // QRPGLESRC,CALCSRV - Service program\n       ctl-opt nomain;\n       \n       dcl-proc CalcDiscount export;\n         dcl-pi *n packed(11:2);\n           amount packed(11:2) const;\n           custType char(1) const;\n           quantity int(5) const;\n         end-pi;\n         \n         dcl-s discount packed(5:4);\n         \n         select;\n           when custType = 'P';  // Premium\n             discount = 0.15;\n           when custType = 'G';  // Gold\n             discount = 0.10;\n           when custType = 'S';  // Silver\n             discount = 0.05;\n           other;\n             discount = 0;\n         endsl;\n         \n         // Volume discount\n         if quantity >= 100;\n           discount += 0.05;\n         elseif quantity >= 50;\n           discount += 0.02;\n         endif;\n         \n         return amount * discount;\n       end-proc;",
      "java": "// DiscountService.java - Microservice\nimport org.springframework.stereotype.Service;\nimport java.math.BigDecimal;\n\n@Service\npublic class DiscountService {\n    \n    public enum CustomerType {\n        PREMIUM('P', new BigDecimal(\"0.15\")),\n        GOLD('G', new BigDecimal(\"0.10\")),\n        SILVER('S', new BigDecimal(\"0.05\")),\n        STANDARD(' ', BigDecimal.ZERO);\n        \n        private final char code;\n        private final BigDecimal baseDiscount;\n        \n        CustomerType(char code, BigDecimal baseDiscount) {\n            this.code = code;\n            this.baseDiscount = baseDiscount;\n        }\n        \n        public static CustomerType fromCode(char code) {\n            for (CustomerType type : values()) {\n                if (type.code == code) return type;\n            }\n            return STANDARD;\n        }\n    }\n    \n    public BigDecimal calcDiscount(\n            BigDecimal amount,\n            char custType,\n            int quantity) {\n        \n        CustomerType type = CustomerType.fromCode(custType);\n        BigDecimal discount = type.baseDiscount;\n        \n        // Volume discount\n        if (quantity >= 100) {\n            discount = discount.add(new BigDecimal(\"0.05\"));\n        } else if (quantity >= 50) {\n            discount = discount.add(new BigDecimal(\"0.02\"));\n        }\n        \n        return amount.multiply(discount)\n            .setScale(2, RoundingMode.HALF_UP);\n    }\n}\n\n// REST Controller\n@RestController\n@RequestMapping(\"/api/discount\")\npublic class DiscountController {\n    @Autowired\n    private DiscountService discountService;\n    \n    @PostMapping(\"/calculate\")\n    public BigDecimal calculateDiscount(@RequestBody DiscountRequest request) {\n        return discountService.calcDiscount(\n            request.amount(),\n            request.custType(),\n            request.quantity()\n        );\n    }\n}",
      "python": "from decimal import Decimal, ROUND_HALF_UP\nfrom enum import Enum\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\nclass CustomerType(Enum):\n    PREMIUM = ('P', Decimal('0.15'))\n    GOLD = ('G', Decimal('0.10'))\n    SILVER = ('S', Decimal('0.05'))\n    STANDARD = (' ', Decimal('0'))\n    \n    def __init__(self, code: str, base_discount: Decimal):\n        self.code = code\n        self.base_discount = base_discount\n    \n    @classmethod\n    def from_code(cls, code: str) -> 'CustomerType':\n        for ctype in cls:\n            if ctype.code == code:\n                return ctype\n        return cls.STANDARD\n\ndef calc_discount(\n    amount: Decimal,\n    cust_type: str,\n    quantity: int\n) -> Decimal:\n    \"\"\"Calculate discount based on customer type and volume.\"\"\"\n    customer_type = CustomerType.from_code(cust_type)\n    discount = customer_type.base_discount\n    \n    # Volume discount\n    if quantity >= 100:\n        discount += Decimal('0.05')\n    elif quantity >= 50:\n        discount += Decimal('0.02')\n    \n    return (amount * discount).quantize(\n        Decimal('0.01'),\n        rounding=ROUND_HALF_UP\n    )\n\n# FastAPI microservice\napp = FastAPI()\n\nclass DiscountRequest(BaseModel):\n    amount: Decimal\n    cust_type: str\n    quantity: int\n\n@app.post(\"/api/discount/calculate\")\nasync def calculate_discount(request: DiscountRequest) -> Decimal:\n    return calc_discount(\n        request.amount,\n        request.cust_type,\n        request.quantity\n    )"
    }
  ],
  "data_type_mapping": {
    "CHAR(n)": {"java": "String", "python": "str"},
    "VARCHAR(n)": {"java": "String", "python": "str"},
    "PACKED(p:s)": {"java": "BigDecimal", "python": "Decimal"},
    "ZONED(p:s)": {"java": "BigDecimal", "python": "Decimal"},
    "INT(5)": {"java": "short", "python": "int"},
    "INT(10)": {"java": "int", "python": "int"},
    "INT(20)": {"java": "long", "python": "int"},
    "UNS(5)": {"java": "int (unsigned range)", "python": "int"},
    "UNS(10)": {"java": "long (unsigned range)", "python": "int"},
    "FLOAT(4)": {"java": "float", "python": "float"},
    "FLOAT(8)": {"java": "double", "python": "float"},
    "DATE": {"java": "LocalDate", "python": "date"},
    "TIME": {"java": "LocalTime", "python": "time"},
    "TIMESTAMP": {"java": "LocalDateTime", "python": "datetime"},
    "IND (Indicator)": {"java": "boolean", "python": "bool"},
    "POINTER": {"java": "Object reference", "python": "object reference"},
    "OBJECT": {"java": "Object", "python": "object"}
  },
  "file_type_mapping": {
    "Physical File (PF)": {"java": "JPA Entity + Repository", "python": "SQLAlchemy Model"},
    "Logical File (LF)": {"java": "JPA @Query or View Entity", "python": "SQLAlchemy query/view"},
    "Display File (DSPF)": {"java": "REST API + React/Angular", "python": "FastAPI + Vue/React"},
    "Printer File (PRTF)": {"java": "JasperReports/iText", "python": "ReportLab/WeasyPrint"},
    "ICF File": {"java": "HTTP Client/WebSocket", "python": "httpx/websockets"},
    "WORKSTN": {"java": "REST Controller", "python": "FastAPI Router"}
  },
  "op_code_mapping": {
    "CHAIN": {"java": "repository.findById()", "python": "session.get()"},
    "READ": {"java": "iterator.next()", "python": "next(iterator)"},
    "READE": {"java": "findByKeyOrderBy()", "python": "query.filter().order_by()"},
    "SETLL": {"java": "query.where(key >=)", "python": "query.filter(key >=)"},
    "SETGT": {"java": "query.where(key >)", "python": "query.filter(key >)"},
    "WRITE": {"java": "repository.save()", "python": "session.add()"},
    "UPDATE": {"java": "repository.save()", "python": "session.commit()"},
    "DELETE": {"java": "repository.delete()", "python": "session.delete()"},
    "EXFMT": {"java": "REST POST + Response", "python": "FastAPI POST + Response"},
    "CALL": {"java": "method invocation", "python": "function call"},
    "CALLP": {"java": "method invocation", "python": "function call"},
    "EXSR": {"java": "private method call", "python": "private method call"},
    "RETURN": {"java": "return", "python": "return"},
    "LEAVE": {"java": "break", "python": "break"},
    "ITER": {"java": "continue", "python": "continue"},
    "LEAVESR": {"java": "return (from method)", "python": "return (from function)"}
  }
}

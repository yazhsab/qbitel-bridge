{
  "metadata": {
    "title": "PL/I to Java/Python Modernization Pairs",
    "version": "1.0.0",
    "description": "Comprehensive conversion patterns from PL/I to Java and Python",
    "total_pairs": 60
  },
  "conversion_pairs": [
    {
      "id": "PLI001",
      "category": "data_structures",
      "name": "Structure Declaration",
      "pli": "DCL 1 CUSTOMER_REC,\n      2 CUST_ID          CHAR(10),\n      2 CUST_NAME        CHAR(50),\n      2 CUST_ADDR,\n        3 STREET         CHAR(30),\n        3 CITY           CHAR(20),\n        3 STATE          CHAR(2),\n        3 ZIP            CHAR(10),\n      2 CUST_BALANCE     FIXED DEC(11,2),\n      2 CUST_STATUS      CHAR(1);",
      "java": "public class CustomerRecord {\n    private String custId;           // CHAR(10)\n    private String custName;         // CHAR(50)\n    private CustomerAddress custAddr;\n    private BigDecimal custBalance;  // FIXED DEC(11,2)\n    private char custStatus;\n    \n    public static class CustomerAddress {\n        private String street;       // CHAR(30)\n        private String city;         // CHAR(20)\n        private String state;        // CHAR(2)\n        private String zip;          // CHAR(10)\n        \n        // Getters and setters\n    }\n    \n    // Getters, setters, constructors\n}",
      "python": "from dataclasses import dataclass\nfrom decimal import Decimal\nfrom typing import Optional\n\n@dataclass\nclass CustomerAddress:\n    street: str  # max 30\n    city: str    # max 20\n    state: str   # max 2\n    zip: str     # max 10\n\n@dataclass\nclass CustomerRecord:\n    cust_id: str           # max 10\n    cust_name: str         # max 50\n    cust_addr: CustomerAddress\n    cust_balance: Decimal  # precision 11, scale 2\n    cust_status: str       # single char"
    },
    {
      "id": "PLI002",
      "category": "data_structures",
      "name": "Array Declarations",
      "pli": "DCL TABLE_DATA(100) CHAR(80);\nDCL MATRIX(10,10) FIXED BIN(31);\nDCL 1 ORDER_LINES(50),\n      2 LINE_NUM       FIXED BIN(15),\n      2 ITEM_CODE      CHAR(15),\n      2 QUANTITY       FIXED DEC(7),\n      2 UNIT_PRICE     FIXED DEC(9,2),\n      2 LINE_TOTAL     FIXED DEC(11,2);",
      "java": "// Simple array\nString[] tableData = new String[100];\n\n// 2D array\nint[][] matrix = new int[10][10];\n\n// Array of structures\npublic class OrderLine {\n    private short lineNum;\n    private String itemCode;\n    private int quantity;\n    private BigDecimal unitPrice;\n    private BigDecimal lineTotal;\n}\n\nList<OrderLine> orderLines = new ArrayList<>(50);",
      "python": "from dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import List\nimport numpy as np\n\n# Simple array\ntable_data: List[str] = [''] * 100\n\n# 2D array using numpy\nmatrix = np.zeros((10, 10), dtype=np.int32)\n\n@dataclass\nclass OrderLine:\n    line_num: int\n    item_code: str\n    quantity: int\n    unit_price: Decimal\n    line_total: Decimal\n\norder_lines: List[OrderLine] = field(default_factory=list)"
    },
    {
      "id": "PLI003",
      "category": "data_structures",
      "name": "Based Variables and Pointers",
      "pli": "DCL P POINTER;\nDCL 1 NODE BASED(P),\n      2 DATA          CHAR(100),\n      2 NEXT_PTR      POINTER;\n\nALLOCATE NODE SET(P);\nNODE.DATA = 'First Node';\nNODE.NEXT_PTR = NULL();\n\n/* Traverse linked list */\nDO WHILE(P ^= NULL());\n   PUT SKIP LIST(NODE.DATA);\n   P = NODE.NEXT_PTR;\nEND;",
      "java": "public class Node {\n    private String data;\n    private Node nextPtr;\n    \n    public Node(String data) {\n        this.data = data;\n        this.nextPtr = null;\n    }\n    \n    public static void traverse(Node head) {\n        Node current = head;\n        while (current != null) {\n            System.out.println(current.getData());\n            current = current.getNextPtr();\n        }\n    }\n}\n\n// Usage\nNode node = new Node(\"First Node\");",
      "python": "from dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass Node:\n    data: str\n    next_ptr: Optional['Node'] = None\n\ndef traverse(head: Optional[Node]) -> None:\n    current = head\n    while current is not None:\n        print(current.data)\n        current = current.next_ptr\n\n# Usage\nnode = Node(data='First Node')"
    },
    {
      "id": "PLI004",
      "category": "data_structures",
      "name": "DEFINED and UNION",
      "pli": "DCL FULL_DATE       CHAR(8);\nDCL 1 DATE_PARTS DEFINED FULL_DATE,\n      2 YEAR_PART    CHAR(4),\n      2 MONTH_PART   CHAR(2),\n      2 DAY_PART     CHAR(2);\n\n/* Union-like structure */\nDCL 1 PAYMENT_DATA,\n      2 PAY_TYPE     CHAR(1),\n      2 PAY_INFO     UNION,\n        3 CHECK_INFO,\n          4 CHECK_NUM    CHAR(10),\n          4 BANK_CODE    CHAR(9),\n        3 CARD_INFO,\n          4 CARD_NUM     CHAR(16),\n          4 CARD_EXP     CHAR(4);",
      "java": "// DEFINED equivalent - use substring views\npublic class DateParts {\n    private final String fullDate;\n    \n    public DateParts(String fullDate) {\n        this.fullDate = fullDate;\n    }\n    \n    public String getYearPart() { return fullDate.substring(0, 4); }\n    public String getMonthPart() { return fullDate.substring(4, 6); }\n    public String getDayPart() { return fullDate.substring(6, 8); }\n}\n\n// UNION equivalent - sealed interface\npublic sealed interface PaymentInfo permits CheckInfo, CardInfo {}\n\npublic record CheckInfo(String checkNum, String bankCode) implements PaymentInfo {}\npublic record CardInfo(String cardNum, String cardExp) implements PaymentInfo {}\n\npublic class PaymentData {\n    private char payType;\n    private PaymentInfo payInfo;\n}",
      "python": "from dataclasses import dataclass\nfrom typing import Union\nfrom abc import ABC\n\nclass DateParts:\n    def __init__(self, full_date: str):\n        self._full_date = full_date\n    \n    @property\n    def year_part(self) -> str:\n        return self._full_date[0:4]\n    \n    @property\n    def month_part(self) -> str:\n        return self._full_date[4:6]\n    \n    @property\n    def day_part(self) -> str:\n        return self._full_date[6:8]\n\n# Union equivalent\n@dataclass\nclass CheckInfo:\n    check_num: str\n    bank_code: str\n\n@dataclass\nclass CardInfo:\n    card_num: str\n    card_exp: str\n\n@dataclass\nclass PaymentData:\n    pay_type: str\n    pay_info: Union[CheckInfo, CardInfo]"
    },
    {
      "id": "PLI005",
      "category": "arithmetic",
      "name": "Fixed Point Arithmetic",
      "pli": "DCL AMOUNT1     FIXED DEC(11,2);\nDCL AMOUNT2     FIXED DEC(11,2);\nDCL RESULT      FIXED DEC(15,4);\nDCL TAX_RATE    FIXED DEC(5,4) INIT(0.0825);\n\nRESULT = AMOUNT1 * AMOUNT2;\nRESULT = ROUND(RESULT, 2);\n\n/* Division with precision */\nRESULT = DIVIDE(AMOUNT1, AMOUNT2, 15, 4);",
      "java": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\nBigDecimal amount1 = new BigDecimal(\"1000.00\");\nBigDecimal amount2 = new BigDecimal(\"500.00\");\nBigDecimal taxRate = new BigDecimal(\"0.0825\");\n\n// Multiplication\nBigDecimal result = amount1.multiply(amount2);\nresult = result.setScale(2, RoundingMode.HALF_UP);\n\n// Division with precision\nBigDecimal divResult = amount1.divide(amount2, 4, RoundingMode.HALF_UP);",
      "python": "from decimal import Decimal, ROUND_HALF_UP, getcontext\n\n# Set precision\ngetcontext().prec = 20\n\namount1 = Decimal('1000.00')\namount2 = Decimal('500.00')\ntax_rate = Decimal('0.0825')\n\n# Multiplication\nresult = amount1 * amount2\nresult = result.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)\n\n# Division with precision\ndiv_result = (amount1 / amount2).quantize(Decimal('0.0001'), rounding=ROUND_HALF_UP)"
    },
    {
      "id": "PLI006",
      "category": "arithmetic",
      "name": "Built-in Math Functions",
      "pli": "DCL X           FLOAT BIN(53);\nDCL Y           FLOAT BIN(53);\nDCL RESULT      FLOAT BIN(53);\n\nRESULT = SQRT(X);\nRESULT = LOG(X);\nRESULT = LOG10(X);\nRESULT = EXP(X);\nRESULT = SIN(X);\nRESULT = COS(X);\nRESULT = ATAN(Y/X);\nRESULT = ABS(X);\nRESULT = MOD(X, Y);\nRESULT = MAX(X, Y);\nRESULT = MIN(X, Y);\nRESULT = CEIL(X);\nRESULT = FLOOR(X);",
      "java": "double x = 10.0;\ndouble y = 3.0;\ndouble result;\n\nresult = Math.sqrt(x);\nresult = Math.log(x);      // Natural log\nresult = Math.log10(x);    // Log base 10\nresult = Math.exp(x);\nresult = Math.sin(x);\nresult = Math.cos(x);\nresult = Math.atan2(y, x); // or Math.atan(y/x)\nresult = Math.abs(x);\nresult = x % y;            // Modulo\nresult = Math.max(x, y);\nresult = Math.min(x, y);\nresult = Math.ceil(x);\nresult = Math.floor(x);",
      "python": "import math\n\nx = 10.0\ny = 3.0\n\nresult = math.sqrt(x)\nresult = math.log(x)       # Natural log\nresult = math.log10(x)     # Log base 10\nresult = math.exp(x)\nresult = math.sin(x)\nresult = math.cos(x)\nresult = math.atan2(y, x)  # or math.atan(y/x)\nresult = abs(x)\nresult = x % y             # Modulo\nresult = max(x, y)\nresult = min(x, y)\nresult = math.ceil(x)\nresult = math.floor(x)"
    },
    {
      "id": "PLI007",
      "category": "control_flow",
      "name": "DO Loops",
      "pli": "/* Simple DO loop */\nDO I = 1 TO 100;\n   TOTAL = TOTAL + ARRAY(I);\nEND;\n\n/* DO WHILE */\nDO WHILE(NOT_EOF);\n   GET FILE(INFILE) EDIT(RECORD)(A(80));\nEND;\n\n/* DO UNTIL */\nDO UNTIL(FOUND | I > MAX);\n   IF TABLE(I) = SEARCH_KEY THEN\n      FOUND = '1'B;\n   ELSE\n      I = I + 1;\nEND;\n\n/* DO with BY */\nDO I = 100 TO 1 BY -1;\n   PUT SKIP LIST(ARRAY(I));\nEND;",
      "java": "// Simple for loop\nint total = 0;\nfor (int i = 0; i < 100; i++) {\n    total += array[i];\n}\n\n// While loop\nwhile (!eof) {\n    record = readRecord(inFile);\n}\n\n// Do-until as do-while with negated condition\nint i = 0;\nboolean found = false;\ndo {\n    if (table[i].equals(searchKey)) {\n        found = true;\n    } else {\n        i++;\n    }\n} while (!found && i <= max);\n\n// Reverse loop\nfor (int i = 99; i >= 0; i--) {\n    System.out.println(array[i]);\n}",
      "python": "# Simple for loop\ntotal = sum(array[:100])\n# or\ntotal = 0\nfor i in range(100):\n    total += array[i]\n\n# While loop\nwhile not eof:\n    record = read_record(infile)\n\n# Do-until equivalent\ni = 0\nfound = False\nwhile True:\n    if table[i] == search_key:\n        found = True\n    else:\n        i += 1\n    if found or i > max_val:\n        break\n\n# Reverse loop\nfor i in range(99, -1, -1):\n    print(array[i])"
    },
    {
      "id": "PLI008",
      "category": "control_flow",
      "name": "SELECT Statement",
      "pli": "SELECT(TRANS_TYPE);\n   WHEN('D')\n      CALL PROCESS_DEPOSIT(AMOUNT);\n   WHEN('W')\n      CALL PROCESS_WITHDRAWAL(AMOUNT);\n   WHEN('T')\n      CALL PROCESS_TRANSFER(AMOUNT, DEST_ACCT);\n   WHEN('I')\n      CALL DISPLAY_INQUIRY(ACCT_NUM);\n   OTHERWISE\n      CALL INVALID_TRANS_ERROR;\nEND;",
      "java": "switch (transType) {\n    case 'D' -> processDeposit(amount);\n    case 'W' -> processWithdrawal(amount);\n    case 'T' -> processTransfer(amount, destAcct);\n    case 'I' -> displayInquiry(acctNum);\n    default -> invalidTransError();\n}\n\n// Or using enhanced switch expression\nString result = switch (transType) {\n    case 'D' -> processDeposit(amount);\n    case 'W' -> processWithdrawal(amount);\n    case 'T' -> processTransfer(amount, destAcct);\n    case 'I' -> displayInquiry(acctNum);\n    default -> throw new IllegalArgumentException(\"Invalid transaction\");\n};",
      "python": "match trans_type:\n    case 'D':\n        process_deposit(amount)\n    case 'W':\n        process_withdrawal(amount)\n    case 'T':\n        process_transfer(amount, dest_acct)\n    case 'I':\n        display_inquiry(acct_num)\n    case _:\n        invalid_trans_error()\n\n# Or using dictionary dispatch\ntrans_handlers = {\n    'D': lambda: process_deposit(amount),\n    'W': lambda: process_withdrawal(amount),\n    'T': lambda: process_transfer(amount, dest_acct),\n    'I': lambda: display_inquiry(acct_num)\n}\n\nhandler = trans_handlers.get(trans_type, invalid_trans_error)\nhandler()"
    },
    {
      "id": "PLI009",
      "category": "file_io",
      "name": "Sequential File Processing",
      "pli": "DCL INFILE FILE RECORD INPUT;\nDCL OUTFILE FILE RECORD OUTPUT;\nDCL 1 RECORD,\n      2 KEY        CHAR(10),\n      2 DATA       CHAR(70);\nDCL EOF BIT(1) INIT('0'B);\n\nON ENDFILE(INFILE) EOF = '1'B;\n\nOPEN FILE(INFILE);\nOPEN FILE(OUTFILE);\n\nREAD FILE(INFILE) INTO(RECORD);\n\nDO WHILE(^EOF);\n   CALL PROCESS_RECORD;\n   WRITE FILE(OUTFILE) FROM(RECORD);\n   READ FILE(INFILE) INTO(RECORD);\nEND;\n\nCLOSE FILE(INFILE);\nCLOSE FILE(OUTFILE);",
      "java": "import java.io.*;\nimport java.nio.file.*;\n\npublic class SequentialFileProcessor {\n    \n    public record Record(String key, String data) {\n        public static Record fromLine(String line) {\n            return new Record(\n                line.substring(0, 10),\n                line.substring(10, 80)\n            );\n        }\n        \n        public String toLine() {\n            return key + data;\n        }\n    }\n    \n    public void processFile(Path input, Path output) throws IOException {\n        try (BufferedReader reader = Files.newBufferedReader(input);\n             BufferedWriter writer = Files.newBufferedWriter(output)) {\n            \n            String line;\n            while ((line = reader.readLine()) != null) {\n                Record record = Record.fromLine(line);\n                Record processed = processRecord(record);\n                writer.write(processed.toLine());\n                writer.newLine();\n            }\n        }\n    }\n    \n    private Record processRecord(Record record) {\n        // Business logic\n        return record;\n    }\n}",
      "python": "from dataclasses import dataclass\nfrom typing import Iterator\nfrom pathlib import Path\n\n@dataclass\nclass Record:\n    key: str\n    data: str\n    \n    @classmethod\n    def from_line(cls, line: str) -> 'Record':\n        return cls(\n            key=line[0:10],\n            data=line[10:80]\n        )\n    \n    def to_line(self) -> str:\n        return f\"{self.key}{self.data}\"\n\ndef process_file(input_path: Path, output_path: Path) -> None:\n    with open(input_path, 'r') as infile, \\\n         open(output_path, 'w') as outfile:\n        \n        for line in infile:\n            record = Record.from_line(line.rstrip())\n            processed = process_record(record)\n            outfile.write(processed.to_line() + '\\n')\n\ndef read_records(filepath: Path) -> Iterator[Record]:\n    \"\"\"Generator for reading records\"\"\"\n    with open(filepath, 'r') as f:\n        for line in f:\n            yield Record.from_line(line.rstrip())"
    },
    {
      "id": "PLI010",
      "category": "file_io",
      "name": "VSAM KSDS Operations",
      "pli": "DCL CUSTFILE FILE RECORD KEYED DIRECT UPDATE\n    ENV(VSAM INDEXED);\nDCL 1 CUST_REC,\n      2 CUST_KEY      CHAR(10),\n      2 CUST_DATA     CHAR(90);\n\n/* Direct read by key */\nREAD FILE(CUSTFILE) INTO(CUST_REC) KEY(SEARCH_KEY);\n\n/* Sequential read from position */\nREAD FILE(CUSTFILE) INTO(CUST_REC) KEYGE(START_KEY);\n\nDO WHILE(^EOF & CUST_KEY <= END_KEY);\n   CALL PROCESS_CUSTOMER;\n   READ FILE(CUSTFILE) INTO(CUST_REC);\nEND;\n\n/* Update */\nREWRITE FILE(CUSTFILE) FROM(CUST_REC) KEY(CUST_KEY);\n\n/* Insert */\nWRITE FILE(CUSTFILE) FROM(NEW_REC);\n\n/* Delete */\nDELETE FILE(CUSTFILE) KEY(DEL_KEY);",
      "java": "import jakarta.persistence.*;\nimport java.util.List;\nimport java.util.Optional;\n\n@Entity\n@Table(name = \"CUSTOMER\")\npublic class Customer {\n    @Id\n    @Column(name = \"CUST_KEY\", length = 10)\n    private String custKey;\n    \n    @Column(name = \"CUST_DATA\", length = 90)\n    private String custData;\n    \n    // Getters, setters\n}\n\n@Repository\npublic interface CustomerRepository extends JpaRepository<Customer, String> {\n    \n    // Direct read by key\n    Optional<Customer> findByCustKey(String key);\n    \n    // Range query (KEYGE to key)\n    @Query(\"SELECT c FROM Customer c WHERE c.custKey >= :startKey AND c.custKey <= :endKey ORDER BY c.custKey\")\n    List<Customer> findByKeyRange(@Param(\"startKey\") String startKey, \n                                   @Param(\"endKey\") String endKey);\n}\n\n@Service\npublic class CustomerService {\n    @Autowired\n    private CustomerRepository repo;\n    \n    // Read\n    public Optional<Customer> read(String key) {\n        return repo.findByCustKey(key);\n    }\n    \n    // Update (REWRITE)\n    @Transactional\n    public Customer update(Customer customer) {\n        return repo.save(customer);\n    }\n    \n    // Insert (WRITE)\n    @Transactional\n    public Customer insert(Customer customer) {\n        return repo.save(customer);\n    }\n    \n    // Delete\n    @Transactional\n    public void delete(String key) {\n        repo.deleteById(key);\n    }\n}",
      "python": "from sqlalchemy import Column, String, create_engine\nfrom sqlalchemy.orm import declarative_base, Session\nfrom typing import Optional, Iterator\n\nBase = declarative_base()\n\nclass Customer(Base):\n    __tablename__ = 'customer'\n    \n    cust_key = Column(String(10), primary_key=True)\n    cust_data = Column(String(90))\n\nclass CustomerRepository:\n    def __init__(self, session: Session):\n        self.session = session\n    \n    # Direct read by key\n    def read(self, key: str) -> Optional[Customer]:\n        return self.session.get(Customer, key)\n    \n    # Range query (KEYGE)\n    def read_range(self, start_key: str, end_key: str) -> Iterator[Customer]:\n        return self.session.query(Customer)\\\n            .filter(Customer.cust_key >= start_key)\\\n            .filter(Customer.cust_key <= end_key)\\\n            .order_by(Customer.cust_key)\n    \n    # Update (REWRITE)\n    def update(self, customer: Customer) -> Customer:\n        self.session.merge(customer)\n        self.session.commit()\n        return customer\n    \n    # Insert (WRITE)\n    def insert(self, customer: Customer) -> Customer:\n        self.session.add(customer)\n        self.session.commit()\n        return customer\n    \n    # Delete\n    def delete(self, key: str) -> None:\n        customer = self.session.get(Customer, key)\n        if customer:\n            self.session.delete(customer)\n            self.session.commit()"
    },
    {
      "id": "PLI011",
      "category": "string_handling",
      "name": "String Functions",
      "pli": "DCL STR1        CHAR(50);\nDCL STR2        CHAR(50);\nDCL RESULT      CHAR(100);\nDCL POS         FIXED BIN(15);\nDCL LEN         FIXED BIN(15);\n\nRESULT = STR1 || STR2;              /* Concatenation */\nPOS = INDEX(STR1, 'SEARCH');        /* Find position */\nLEN = LENGTH(TRIM(STR1));           /* Length after trim */\nRESULT = SUBSTR(STR1, 5, 10);       /* Substring */\nRESULT = TRANSLATE(STR1, 'abc', 'ABC'); /* Case convert */\nRESULT = REPEAT('*', 20);           /* Repeat */\nRESULT = LEFT(STR1, 20);            /* Left pad/truncate */\nRESULT = RIGHT(STR1, 20);           /* Right justify */\nRESULT = TRIM(STR1);                /* Remove spaces */\nRESULT = REVERSE(STR1);             /* Reverse string */",
      "java": "String str1 = \"Hello\";\nString str2 = \"World\";\nString result;\nint pos;\nint len;\n\nresult = str1 + str2;                           // Concatenation\nresult = str1.concat(str2);                     // Alternative\npos = str1.indexOf(\"SEARCH\");                   // Find position (-1 if not found)\nlen = str1.trim().length();                     // Length after trim\nresult = str1.substring(4, 14);                 // Substring (0-based)\nresult = str1.toLowerCase();                    // Case convert\nresult = str1.toUpperCase();\nresult = \"*\".repeat(20);                        // Repeat\nresult = String.format(\"%-20s\", str1);          // Left justify\nresult = String.format(\"%20s\", str1);           // Right justify\nresult = str1.trim();                           // Remove spaces\nresult = str1.strip();                          // Remove whitespace (Java 11+)\nresult = new StringBuilder(str1).reverse().toString();  // Reverse",
      "python": "str1 = \"Hello\"\nstr2 = \"World\"\n\nresult = str1 + str2                    # Concatenation\npos = str1.find(\"SEARCH\")               # Find position (-1 if not found)\npos = str1.index(\"SEARCH\")              # Raises ValueError if not found\nlen_val = len(str1.strip())             # Length after trim\nresult = str1[4:14]                     # Substring (0-based)\nresult = str1.lower()                   # Case convert\nresult = str1.upper()\nresult = '*' * 20                       # Repeat\nresult = str1.ljust(20)                 # Left justify\nresult = str1.rjust(20)                 # Right justify\nresult = str1.strip()                   # Remove spaces\nresult = str1.lstrip()                  # Left strip\nresult = str1.rstrip()                  # Right strip\nresult = str1[::-1]                     # Reverse"
    },
    {
      "id": "PLI012",
      "category": "string_handling",
      "name": "Edit-Directed I/O",
      "pli": "DCL AMOUNT      FIXED DEC(11,2);\nDCL DATE_VAL    CHAR(8);\nDCL FORMATTED   CHAR(50);\n\n/* Format number with edit mask */\nPUT STRING(FORMATTED) EDIT(AMOUNT)\n    (P'$$$,$$$,$$9V.99');\n\n/* Parse input */\nGET STRING(INPUT_STR) EDIT(AMOUNT, DATE_VAL)\n    (P'999999999V99', A(8));\n\n/* Date formatting */\nPUT STRING(FORMATTED) EDIT(SUBSTR(DATE_VAL,5,2), '/',\n                           SUBSTR(DATE_VAL,7,2), '/',\n                           SUBSTR(DATE_VAL,1,4))\n    (A(2), A(1), A(2), A(1), A(4));",
      "java": "import java.text.NumberFormat;\nimport java.text.DecimalFormat;\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Locale;\n\n// Format number with currency\nNumberFormat currencyFormat = NumberFormat.getCurrencyInstance(Locale.US);\nString formatted = currencyFormat.format(amount);  // $1,234,567.89\n\n// Custom decimal format\nDecimalFormat df = new DecimalFormat(\"$#,##0.00\");\nString formatted2 = df.format(amount);\n\n// Parse amount from string\nNumber parsed = df.parse(\"$1,234.56\");\nBigDecimal amount = new BigDecimal(parsed.toString());\n\n// Date formatting\nDateTimeFormatter inputFormat = DateTimeFormatter.ofPattern(\"yyyyMMdd\");\nDateTimeFormatter outputFormat = DateTimeFormatter.ofPattern(\"MM/dd/yyyy\");\n\nLocalDate date = LocalDate.parse(dateVal, inputFormat);\nString formattedDate = date.format(outputFormat);",
      "python": "from decimal import Decimal\nfrom datetime import datetime\nimport locale\n\n# Set locale for currency\nlocale.setlocale(locale.LC_ALL, 'en_US.UTF-8')\n\namount = Decimal('1234567.89')\n\n# Format number with currency\nformatted = locale.currency(amount, grouping=True)  # $1,234,567.89\n\n# Custom format\nformatted = f\"${amount:,.2f}\"\n\n# Parse amount from string\nparsed = Decimal('1234.56')\n\n# Date formatting\ndate_val = '20231215'\ndate = datetime.strptime(date_val, '%Y%m%d')\nformatted_date = date.strftime('%m/%d/%Y')  # 12/15/2023\n\n# f-string formatting\nprint(f\"Amount: {amount:>15,.2f}\")\nprint(f\"Date: {date:%B %d, %Y}\")"
    },
    {
      "id": "PLI013",
      "category": "error_handling",
      "name": "ON Conditions",
      "pli": "ON ERROR BEGIN;\n   PUT SKIP LIST('Error occurred: ', ONCODE());\n   CALL LOG_ERROR(ONCODE(), ONLOC());\n   GOTO ERROR_EXIT;\nEND;\n\nON ENDFILE(INFILE) EOF = '1'B;\n\nON KEY(CUSTFILE) BEGIN;\n   IF ONCODE() = 51 THEN    /* Record not found */\n      NOT_FOUND = '1'B;\n   ELSE IF ONCODE() = 52 THEN  /* Duplicate key */\n      DUP_KEY = '1'B;\n   ELSE\n      SIGNAL ERROR;\nEND;\n\nON ZERODIVIDE BEGIN;\n   PUT SKIP LIST('Division by zero');\n   RESULT = 0;\nEND;\n\nON OVERFLOW BEGIN;\n   PUT SKIP LIST('Numeric overflow');\n   RESULT = MAX_VALUE;\nEND;",
      "java": "import java.io.IOException;\nimport java.io.EOFException;\nimport java.util.NoSuchElementException;\n\npublic class ErrorHandler {\n    \n    public void processWithErrorHandling() {\n        try {\n            processFile();\n            processRecord();\n        } catch (EOFException e) {\n            // ON ENDFILE equivalent\n            eof = true;\n        } catch (NoSuchElementException e) {\n            // ON KEY (not found) equivalent\n            notFound = true;\n        } catch (DuplicateKeyException e) {\n            // ON KEY (duplicate) equivalent\n            dupKey = true;\n        } catch (ArithmeticException e) {\n            if (e.getMessage().contains(\"/ by zero\")) {\n                // ON ZERODIVIDE\n                result = BigDecimal.ZERO;\n            } else {\n                // ON OVERFLOW - Java BigDecimal doesn't overflow\n                result = MAX_VALUE;\n            }\n        } catch (Exception e) {\n            // ON ERROR\n            logError(e.getClass().getName(), getLocation());\n            throw e;  // or handle gracefully\n        }\n    }\n    \n    // Custom exception for business logic\n    public static class DuplicateKeyException extends RuntimeException {\n        public DuplicateKeyException(String key) {\n            super(\"Duplicate key: \" + key);\n        }\n    }\n}",
      "python": "from decimal import Decimal, InvalidOperation, DivisionByZero, Overflow\nimport logging\nimport traceback\nfrom typing import Optional\n\nlogger = logging.getLogger(__name__)\n\nclass RecordNotFoundError(Exception):\n    pass\n\nclass DuplicateKeyError(Exception):\n    pass\n\ndef process_with_error_handling():\n    eof = False\n    not_found = False\n    dup_key = False\n    result: Optional[Decimal] = None\n    \n    try:\n        process_file()\n        process_record()\n        \n    except StopIteration:\n        # ON ENDFILE equivalent\n        eof = True\n        \n    except RecordNotFoundError:\n        # ON KEY (not found)\n        not_found = True\n        \n    except DuplicateKeyError:\n        # ON KEY (duplicate)\n        dup_key = True\n        \n    except ZeroDivisionError:\n        # ON ZERODIVIDE\n        logger.warning('Division by zero')\n        result = Decimal('0')\n        \n    except (Overflow, InvalidOperation) as e:\n        # ON OVERFLOW\n        logger.warning(f'Numeric overflow: {e}')\n        result = MAX_VALUE\n        \n    except Exception as e:\n        # ON ERROR\n        logger.error(f'Error occurred: {e}')\n        logger.error(f'Location: {traceback.format_exc()}')\n        raise"
    },
    {
      "id": "PLI014",
      "category": "db2_sql",
      "name": "Embedded SQL",
      "pli": "EXEC SQL INCLUDE SQLCA;\n\nDCL 1 CUST_REC,\n      2 CUST_ID       CHAR(10),\n      2 CUST_NAME     CHAR(50),\n      2 CUST_BAL      FIXED DEC(11,2);\n\n/* Single row select */\nEXEC SQL\n   SELECT CUST_NAME, CUST_BAL\n   INTO :CUST_REC.CUST_NAME, :CUST_REC.CUST_BAL\n   FROM CUSTOMER\n   WHERE CUST_ID = :CUST_ID;\n\nIF SQLCODE = 0 THEN\n   CALL PROCESS_CUSTOMER;\nELSE IF SQLCODE = 100 THEN\n   PUT SKIP LIST('Customer not found');\nELSE\n   PUT SKIP LIST('SQL Error: ', SQLCODE);\n   SIGNAL ERROR;\nEND;\n\n/* Cursor processing */\nEXEC SQL DECLARE CUST_CUR CURSOR FOR\n   SELECT CUST_ID, CUST_NAME, CUST_BAL\n   FROM CUSTOMER\n   WHERE CUST_BAL > :MIN_BAL\n   ORDER BY CUST_NAME;\n\nEXEC SQL OPEN CUST_CUR;\n\nDO WHILE(SQLCODE = 0);\n   EXEC SQL FETCH CUST_CUR\n      INTO :CUST_ID, :CUST_NAME, :CUST_BAL;\n   IF SQLCODE = 0 THEN\n      CALL PROCESS_RECORD;\nEND;\n\nEXEC SQL CLOSE CUST_CUR;",
      "java": "import java.sql.*;\nimport javax.sql.DataSource;\nimport java.math.BigDecimal;\nimport java.util.Optional;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class CustomerRepository {\n    private final DataSource dataSource;\n    \n    public CustomerRepository(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n    \n    // Single row select\n    public Optional<CustomerRecord> findById(String custId) throws SQLException {\n        String sql = \"SELECT CUST_NAME, CUST_BAL FROM CUSTOMER WHERE CUST_ID = ?\";\n        \n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement stmt = conn.prepareStatement(sql)) {\n            \n            stmt.setString(1, custId);\n            \n            try (ResultSet rs = stmt.executeQuery()) {\n                if (rs.next()) {\n                    return Optional.of(new CustomerRecord(\n                        custId,\n                        rs.getString(\"CUST_NAME\"),\n                        rs.getBigDecimal(\"CUST_BAL\")\n                    ));\n                }\n                return Optional.empty();  // SQLCODE = 100\n            }\n        }\n    }\n    \n    // Cursor processing\n    public List<CustomerRecord> findByMinBalance(BigDecimal minBal) throws SQLException {\n        String sql = \"\"\"SELECT CUST_ID, CUST_NAME, CUST_BAL\n                       FROM CUSTOMER\n                       WHERE CUST_BAL > ?\n                       ORDER BY CUST_NAME\"\"\";\n        \n        List<CustomerRecord> results = new ArrayList<>();\n        \n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement stmt = conn.prepareStatement(sql)) {\n            \n            stmt.setBigDecimal(1, minBal);\n            \n            try (ResultSet rs = stmt.executeQuery()) {\n                while (rs.next()) {\n                    results.add(new CustomerRecord(\n                        rs.getString(\"CUST_ID\"),\n                        rs.getString(\"CUST_NAME\"),\n                        rs.getBigDecimal(\"CUST_BAL\")\n                    ));\n                }\n            }\n        }\n        return results;\n    }\n}",
      "python": "from typing import Optional, Iterator\nfrom decimal import Decimal\nfrom dataclasses import dataclass\nimport psycopg2\nfrom contextlib import contextmanager\n\n@dataclass\nclass CustomerRecord:\n    cust_id: str\n    cust_name: str\n    cust_bal: Decimal\n\nclass CustomerRepository:\n    def __init__(self, connection_string: str):\n        self.conn_string = connection_string\n    \n    @contextmanager\n    def get_connection(self):\n        conn = psycopg2.connect(self.conn_string)\n        try:\n            yield conn\n        finally:\n            conn.close()\n    \n    # Single row select\n    def find_by_id(self, cust_id: str) -> Optional[CustomerRecord]:\n        sql = \"\"\"SELECT CUST_NAME, CUST_BAL \n                 FROM CUSTOMER \n                 WHERE CUST_ID = %s\"\"\"\n        \n        with self.get_connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(sql, (cust_id,))\n                row = cur.fetchone()\n                \n                if row:\n                    return CustomerRecord(\n                        cust_id=cust_id,\n                        cust_name=row[0],\n                        cust_bal=Decimal(str(row[1]))\n                    )\n                return None  # SQLCODE = 100 equivalent\n    \n    # Cursor processing (generator)\n    def find_by_min_balance(self, min_bal: Decimal) -> Iterator[CustomerRecord]:\n        sql = \"\"\"SELECT CUST_ID, CUST_NAME, CUST_BAL\n                 FROM CUSTOMER\n                 WHERE CUST_BAL > %s\n                 ORDER BY CUST_NAME\"\"\"\n        \n        with self.get_connection() as conn:\n            with conn.cursor(name='cust_cursor') as cur:\n                cur.execute(sql, (min_bal,))\n                \n                for row in cur:\n                    yield CustomerRecord(\n                        cust_id=row[0],\n                        cust_name=row[1],\n                        cust_bal=Decimal(str(row[2]))\n                    )"
    },
    {
      "id": "PLI015",
      "category": "procedures",
      "name": "Procedure Definitions",
      "pli": "CALC_INTEREST: PROC(PRINCIPAL, RATE, MONTHS)\n    RETURNS(FIXED DEC(11,2));\n    \n    DCL PRINCIPAL   FIXED DEC(11,2);\n    DCL RATE        FIXED DEC(5,4);\n    DCL MONTHS      FIXED BIN(15);\n    DCL INTEREST    FIXED DEC(11,2);\n    DCL MONTHLY_RT  FIXED DEC(7,6);\n    \n    MONTHLY_RT = RATE / 12;\n    INTEREST = PRINCIPAL * ((1 + MONTHLY_RT) ** MONTHS - 1);\n    \n    RETURN(ROUND(INTEREST, 2));\n    \nEND CALC_INTEREST;\n\n/* Call the procedure */\nDCL RESULT FIXED DEC(11,2);\nRESULT = CALC_INTEREST(10000.00, 0.05, 12);",
      "java": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class InterestCalculator {\n    \n    public static BigDecimal calcInterest(\n            BigDecimal principal,\n            BigDecimal rate,\n            int months) {\n        \n        BigDecimal monthlyRate = rate.divide(\n            BigDecimal.valueOf(12), \n            6, \n            RoundingMode.HALF_UP\n        );\n        \n        // (1 + monthlyRate) ^ months - 1\n        BigDecimal factor = monthlyRate.add(BigDecimal.ONE)\n            .pow(months)\n            .subtract(BigDecimal.ONE);\n        \n        BigDecimal interest = principal.multiply(factor)\n            .setScale(2, RoundingMode.HALF_UP);\n        \n        return interest;\n    }\n}\n\n// Usage\nBigDecimal result = InterestCalculator.calcInterest(\n    new BigDecimal(\"10000.00\"),\n    new BigDecimal(\"0.05\"),\n    12\n);",
      "python": "from decimal import Decimal, ROUND_HALF_UP, getcontext\n\ngetcontext().prec = 20\n\ndef calc_interest(\n    principal: Decimal,\n    rate: Decimal,\n    months: int\n) -> Decimal:\n    \"\"\"Calculate compound interest.\n    \n    Args:\n        principal: Principal amount\n        rate: Annual interest rate (e.g., 0.05 for 5%)\n        months: Number of months\n        \n    Returns:\n        Interest earned, rounded to 2 decimal places\n    \"\"\"\n    monthly_rate = rate / 12\n    \n    # (1 + monthly_rate) ^ months - 1\n    factor = (1 + monthly_rate) ** months - 1\n    \n    interest = principal * Decimal(str(factor))\n    \n    return interest.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)\n\n# Usage\nresult = calc_interest(\n    Decimal('10000.00'),\n    Decimal('0.05'),\n    12\n)"
    },
    {
      "id": "PLI016",
      "category": "bit_operations",
      "name": "Bit String Operations",
      "pli": "DCL FLAGS       BIT(8);\nDCL ACTIVE      BIT(1);\nDCL MASK        BIT(8) INIT('10000000'B);\n\n/* Set bit */\nFLAGS = FLAGS | MASK;\n\n/* Clear bit */\nFLAGS = FLAGS & ^MASK;\n\n/* Toggle bit */\nFLAGS = FLAGS ^ MASK;\n\n/* Test bit */\nIF (FLAGS & MASK) ^= '0'B THEN\n   PUT SKIP LIST('Bit is set');\n\n/* Extract bit */\nACTIVE = SUBSTR(FLAGS, 1, 1);\n\n/* Count bits */\nDCL BIT_COUNT FIXED BIN(15) INIT(0);\nDO I = 1 TO 8;\n   IF SUBSTR(FLAGS, I, 1) = '1'B THEN\n      BIT_COUNT = BIT_COUNT + 1;\nEND;",
      "java": "public class BitOperations {\n    private byte flags;\n    private static final byte MASK = (byte) 0b10000000;\n    \n    // Set bit\n    public void setBit() {\n        flags |= MASK;\n    }\n    \n    // Clear bit\n    public void clearBit() {\n        flags &= ~MASK;\n    }\n    \n    // Toggle bit\n    public void toggleBit() {\n        flags ^= MASK;\n    }\n    \n    // Test bit\n    public boolean isBitSet() {\n        return (flags & MASK) != 0;\n    }\n    \n    // Extract specific bit (0-indexed from right)\n    public boolean getBit(int position) {\n        return ((flags >> position) & 1) == 1;\n    }\n    \n    // Count set bits\n    public int countBits() {\n        return Integer.bitCount(flags & 0xFF);\n    }\n    \n    // Using BitSet for more complex operations\n    public void usingBitSet() {\n        java.util.BitSet bitSet = java.util.BitSet.valueOf(new byte[]{flags});\n        bitSet.set(7);           // Set bit 7\n        bitSet.clear(7);         // Clear bit 7\n        bitSet.flip(7);          // Toggle bit 7\n        boolean isSet = bitSet.get(7);  // Test bit 7\n        int count = bitSet.cardinality(); // Count set bits\n    }\n}",
      "python": "class BitOperations:\n    def __init__(self):\n        self.flags = 0\n        self.MASK = 0b10000000\n    \n    # Set bit\n    def set_bit(self):\n        self.flags |= self.MASK\n    \n    # Clear bit\n    def clear_bit(self):\n        self.flags &= ~self.MASK\n    \n    # Toggle bit\n    def toggle_bit(self):\n        self.flags ^= self.MASK\n    \n    # Test bit\n    def is_bit_set(self) -> bool:\n        return (self.flags & self.MASK) != 0\n    \n    # Extract specific bit (0-indexed from right)\n    def get_bit(self, position: int) -> bool:\n        return ((self.flags >> position) & 1) == 1\n    \n    # Count set bits\n    def count_bits(self) -> int:\n        return bin(self.flags).count('1')\n    \n    # Set bit at position\n    def set_bit_at(self, position: int):\n        self.flags |= (1 << position)\n    \n    # Clear bit at position  \n    def clear_bit_at(self, position: int):\n        self.flags &= ~(1 << position)"
    },
    {
      "id": "PLI017",
      "category": "storage",
      "name": "Storage Management",
      "pli": "DCL AREA1       AREA(1000);\nDCL BUFFER      CHAR(1000) BASED(P);\nDCL P           POINTER;\n\n/* Allocate storage */\nALLOCATE BUFFER IN(AREA1) SET(P);\n\n/* Use the storage */\nBUFFER = 'Data to store';\n\n/* Free storage */\nFREE BUFFER IN(AREA1);\n\n/* Controlled storage */\nDCL STACK       CHAR(100) CONTROLLED;\n\nALLOCATE STACK;\nSTACK = 'First allocation';\n\nALLOCATE STACK;  /* Push new allocation */\nSTACK = 'Second allocation';\n\nFREE STACK;      /* Pop - back to first */\nPUT SKIP LIST(STACK);  /* Shows 'First allocation' */",
      "java": "import java.nio.ByteBuffer;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class StorageManagement {\n    // Direct buffer allocation (like AREA)\n    private ByteBuffer area = ByteBuffer.allocateDirect(1000);\n    \n    public void useDirectBuffer() {\n        // Write data\n        byte[] data = \"Data to store\".getBytes();\n        area.put(data);\n        \n        // Read data back\n        area.flip();\n        byte[] readData = new byte[data.length];\n        area.get(readData);\n        \n        // Clear for reuse\n        area.clear();\n    }\n    \n    // Controlled storage equivalent using Stack\n    private Deque<String> controlledStack = new ArrayDeque<>();\n    \n    public void pushValue(String value) {\n        controlledStack.push(value);\n    }\n    \n    public String popValue() {\n        return controlledStack.pop();\n    }\n    \n    public String peekValue() {\n        return controlledStack.peek();\n    }\n}\n\n// For object pooling (memory management)\nimport org.apache.commons.pool2.impl.GenericObjectPool;\n\npublic class BufferPool {\n    private final GenericObjectPool<ByteBuffer> pool;\n    \n    public ByteBuffer borrow() throws Exception {\n        return pool.borrowObject();\n    }\n    \n    public void returnBuffer(ByteBuffer buffer) {\n        pool.returnObject(buffer);\n    }\n}",
      "python": "from collections import deque\nfrom typing import Optional\nimport io\n\nclass StorageManagement:\n    \"\"\"PL/I storage management equivalents in Python\"\"\"\n    \n    def __init__(self, area_size: int = 1000):\n        # AREA equivalent - BytesIO buffer\n        self.area = io.BytesIO(bytearray(area_size))\n        \n        # CONTROLLED storage equivalent\n        self.controlled_stack: deque[str] = deque()\n    \n    # ALLOCATE / USE / FREE with buffer\n    def allocate_buffer(self, size: int) -> memoryview:\n        \"\"\"Allocate a view into the area\"\"\"\n        return memoryview(bytearray(size))\n    \n    def use_buffer(self, buffer: memoryview, data: bytes) -> None:\n        buffer[:len(data)] = data\n    \n    # CONTROLLED - ALLOCATE (push)\n    def allocate_controlled(self, value: str) -> None:\n        self.controlled_stack.append(value)\n    \n    # FREE (pop)\n    def free_controlled(self) -> Optional[str]:\n        if self.controlled_stack:\n            return self.controlled_stack.pop()\n        return None\n    \n    # Access current (peek)\n    def current_controlled(self) -> Optional[str]:\n        if self.controlled_stack:\n            return self.controlled_stack[-1]\n        return None\n\n# Context manager for automatic cleanup\nfrom contextlib import contextmanager\n\n@contextmanager\ndef managed_buffer(size: int):\n    buffer = bytearray(size)\n    try:\n        yield buffer\n    finally:\n        # Automatic cleanup\n        del buffer"
    },
    {
      "id": "PLI018",
      "category": "multitasking",
      "name": "Tasking and Events",
      "pli": "DCL TASK1       TASK;\nDCL TASK2       TASK;\nDCL DONE_EVENT  EVENT;\n\n/* Create subtask */\nCALL PROCESS_DATA TASK(TASK1);\nCALL PROCESS_DATA TASK(TASK2);\n\n/* Wait for completion */\nWAIT(TASK1, TASK2);\n\n/* Event-based synchronization */\nDCL BUFFER_READY EVENT;\nDCL BUFFER       CHAR(1000);\n\n/* Producer */\nBUFFER = GET_DATA();\nCOMPLETION(BUFFER_READY);\n\n/* Consumer */\nWAIT(BUFFER_READY);\nCALL PROCESS_BUFFER(BUFFER);",
      "java": "import java.util.concurrent.*;\nimport java.util.concurrent.locks.*;\n\npublic class TaskingExample {\n    private final ExecutorService executor = Executors.newFixedThreadPool(4);\n    \n    // Subtask equivalent\n    public void runTasks() throws InterruptedException, ExecutionException {\n        Future<?> task1 = executor.submit(this::processData);\n        Future<?> task2 = executor.submit(this::processData);\n        \n        // WAIT equivalent\n        task1.get();\n        task2.get();\n    }\n    \n    // Event-based synchronization\n    private final CountDownLatch bufferReady = new CountDownLatch(1);\n    private volatile String buffer;\n    \n    // Producer\n    public void producer() {\n        buffer = getData();\n        bufferReady.countDown();  // COMPLETION equivalent\n    }\n    \n    // Consumer\n    public void consumer() throws InterruptedException {\n        bufferReady.await();  // WAIT equivalent\n        processBuffer(buffer);\n    }\n    \n    // Using CompletableFuture\n    public void usingCompletableFuture() {\n        CompletableFuture<String> future = CompletableFuture\n            .supplyAsync(this::getData)\n            .thenApply(this::processAndReturn);\n        \n        // Wait for result\n        String result = future.join();\n    }\n    \n    public void shutdown() {\n        executor.shutdown();\n    }\n}",
      "python": "import asyncio\nimport concurrent.futures\nfrom threading import Event, Thread\nfrom typing import Any\n\n# Using threading\nclass TaskingWithThreads:\n    def __init__(self):\n        self.buffer_ready = Event()\n        self.buffer: str = \"\"\n    \n    def run_tasks(self):\n        with concurrent.futures.ThreadPoolExecutor() as executor:\n            task1 = executor.submit(self.process_data)\n            task2 = executor.submit(self.process_data)\n            \n            # WAIT equivalent\n            concurrent.futures.wait([task1, task2])\n    \n    # Producer\n    def producer(self):\n        self.buffer = self.get_data()\n        self.buffer_ready.set()  # COMPLETION equivalent\n    \n    # Consumer\n    def consumer(self):\n        self.buffer_ready.wait()  # WAIT equivalent\n        self.process_buffer(self.buffer)\n\n# Using asyncio\nclass TaskingWithAsyncio:\n    def __init__(self):\n        self.buffer_ready = asyncio.Event()\n        self.buffer: str = \"\"\n    \n    async def run_tasks(self):\n        # Create concurrent tasks\n        task1 = asyncio.create_task(self.process_data_async())\n        task2 = asyncio.create_task(self.process_data_async())\n        \n        # WAIT equivalent\n        await asyncio.gather(task1, task2)\n    \n    # Producer\n    async def producer(self):\n        self.buffer = await self.get_data_async()\n        self.buffer_ready.set()  # COMPLETION\n    \n    # Consumer\n    async def consumer(self):\n        await self.buffer_ready.wait()  # WAIT\n        await self.process_buffer_async(self.buffer)\n\n# Run async code\nasync def main():\n    tasking = TaskingWithAsyncio()\n    await tasking.run_tasks()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())"
    },
    {
      "id": "PLI019",
      "category": "stream_io",
      "name": "Stream I/O",
      "pli": "DCL SYSPRINT FILE PRINT;\nDCL SYSIN    FILE INPUT;\n\n/* List-directed output */\nPUT LIST('Name:', NAME, 'Balance:', BALANCE);\nPUT SKIP LIST('Total records:', COUNT);\n\n/* Edit-directed output */\nPUT EDIT(CUST_ID, CUST_NAME, CUST_BAL)\n    (A(10), X(3), A(30), X(3), P'$$$,$$$,$$9.99');\n\n/* List-directed input */\nGET LIST(NAME, AGE, SALARY);\n\n/* Edit-directed input */\nGET EDIT(CUST_ID, TRANS_AMT)(A(10), F(11,2));\n\n/* Data-directed (for debugging) */\nPUT DATA(CUSTOMER_REC);",
      "java": "import java.io.*;\nimport java.util.Scanner;\n\npublic class StreamIO {\n    private final PrintWriter out;\n    private final Scanner in;\n    \n    public StreamIO() {\n        this.out = new PrintWriter(System.out, true);\n        this.in = new Scanner(System.in);\n    }\n    \n    // PUT LIST equivalent\n    public void putList(Object... items) {\n        for (int i = 0; i < items.length; i++) {\n            out.print(items[i]);\n            if (i < items.length - 1) out.print(\" \");\n        }\n        out.println();\n    }\n    \n    // PUT EDIT equivalent - formatted output\n    public void putEdit(String custId, String custName, double custBal) {\n        out.printf(\"%-10s   %-30s   $%,11.2f%n\", \n                   custId, custName, custBal);\n    }\n    \n    // GET LIST equivalent\n    public void getList() {\n        String name = in.next();\n        int age = in.nextInt();\n        double salary = in.nextDouble();\n    }\n    \n    // PUT DATA equivalent (for debugging)\n    public void putData(Object obj) {\n        out.println(obj.toString());\n        // Or use reflection for detailed dump\n    }\n    \n    // Table/Report formatting\n    public void printReportHeader() {\n        out.println(\"-\".repeat(70));\n        out.printf(\"%-10s %-30s %15s%n\", \n                   \"CUST ID\", \"NAME\", \"BALANCE\");\n        out.println(\"-\".repeat(70));\n    }\n}",
      "python": "import sys\nfrom typing import Any\nfrom dataclasses import dataclass, fields\n\nclass StreamIO:\n    def __init__(self, output=sys.stdout, input_stream=sys.stdin):\n        self.out = output\n        self.inp = input_stream\n    \n    # PUT LIST equivalent\n    def put_list(self, *items, sep=' ', end='\\n'):\n        print(*items, sep=sep, end=end, file=self.out)\n    \n    # PUT SKIP LIST equivalent\n    def put_skip_list(self, *items):\n        print()  # Skip line\n        print(*items, file=self.out)\n    \n    # PUT EDIT equivalent - formatted output\n    def put_edit(self, cust_id: str, cust_name: str, cust_bal: float):\n        print(f\"{cust_id:<10}   {cust_name:<30}   ${cust_bal:>11,.2f}\",\n              file=self.out)\n    \n    # GET LIST equivalent\n    def get_list(self) -> tuple[str, int, float]:\n        line = self.inp.readline().strip()\n        parts = line.split()\n        return parts[0], int(parts[1]), float(parts[2])\n    \n    # PUT DATA equivalent (for debugging)\n    def put_data(self, obj: Any):\n        if hasattr(obj, '__dataclass_fields__'):\n            # Handle dataclass\n            for field in fields(obj):\n                value = getattr(obj, field.name)\n                print(f\"{field.name}={value!r}\", file=self.out)\n        else:\n            print(f\"{type(obj).__name__}={obj!r}\", file=self.out)\n    \n    # Report formatting\n    def print_report_header(self):\n        print('-' * 70, file=self.out)\n        print(f\"{'CUST ID':<10} {'NAME':<30} {'BALANCE':>15}\",\n              file=self.out)\n        print('-' * 70, file=self.out)"
    },
    {
      "id": "PLI020",
      "category": "preprocessing",
      "name": "Preprocessor Directives",
      "pli": "%DCL DEBUG CHAR;\n%DEBUG = 'Y';\n\n%IF DEBUG = 'Y' %THEN\n   %DO;\n      PUT SKIP LIST('Debug: Entering procedure');\n      PUT SKIP LIST('Input values:', PARM1, PARM2);\n   %END;\n\n%INCLUDE COPYBOOK;\n\n%DEACTIVATE DEBUG;\n\n/* Macro definition */\n%DCL LOG ENTRY RETURNS(CHAR);\n%LOG: PROC(MSG) RETURNS(CHAR);\n   %DCL MSG CHAR;\n   %RETURN('/* LOG: ' || MSG || ' */');\n%END LOG;\n\n/* Use macro */\n%LOG('Processing started');",
      "java": "// Using constants and conditionals\npublic class PreprocessorEquivalent {\n    private static final boolean DEBUG = true;\n    \n    public void process(String parm1, String parm2) {\n        if (DEBUG) {\n            System.out.println(\"Debug: Entering procedure\");\n            System.out.printf(\"Input values: %s, %s%n\", parm1, parm2);\n        }\n        \n        // Business logic\n    }\n}\n\n// Using annotations for compile-time processing\nimport java.lang.annotation.*;\n\n@Retention(RetentionPolicy.SOURCE)\n@Target(ElementType.METHOD)\npublic @interface Log {\n    String value() default \"\";\n}\n\n// Using logging framework (more idiomatic)\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class LoggingExample {\n    private static final Logger log = LoggerFactory.getLogger(LoggingExample.class);\n    \n    public void process(String parm1, String parm2) {\n        log.debug(\"Entering procedure\");\n        log.debug(\"Input values: {}, {}\", parm1, parm2);\n        \n        // Business logic\n        \n        log.info(\"Processing started\");\n    }\n}",
      "python": "import logging\nimport functools\nfrom typing import Callable, Any\n\n# Configure logging (DEBUG equivalent)\nDEBUG = True\nlogging.basicConfig(level=logging.DEBUG if DEBUG else logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef process(parm1: str, parm2: str):\n    if DEBUG:\n        logger.debug(\"Entering procedure\")\n        logger.debug(f\"Input values: {parm1}, {parm2}\")\n    \n    # Business logic\n\n# Decorator as macro equivalent\ndef log_entry_exit(func: Callable) -> Callable:\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs) -> Any:\n        logger.debug(f\"Entering {func.__name__}\")\n        logger.debug(f\"Args: {args}, Kwargs: {kwargs}\")\n        try:\n            result = func(*args, **kwargs)\n            logger.debug(f\"Exiting {func.__name__} with result: {result}\")\n            return result\n        except Exception as e:\n            logger.error(f\"Error in {func.__name__}: {e}\")\n            raise\n    return wrapper\n\n@log_entry_exit\ndef my_function(x: int, y: int) -> int:\n    return x + y\n\n# Include equivalent - just use import\nfrom shared.copybook import CustomerRecord  # type: ignore\n\n# Conditional compilation using __debug__\nif __debug__:\n    logger.debug(\"Debug mode is active\")"
    }
  ],
  "builtin_functions_mapping": {
    "string_functions": {
      "LENGTH": {"java": "str.length()", "python": "len(str)"},
      "SUBSTR": {"java": "str.substring(start, end)", "python": "str[start:end]"},
      "INDEX": {"java": "str.indexOf(search)", "python": "str.find(search)"},
      "TRIM": {"java": "str.trim()", "python": "str.strip()"},
      "TRANSLATE": {"java": "Custom or Apache Commons", "python": "str.translate()"},
      "REVERSE": {"java": "new StringBuilder(str).reverse().toString()", "python": "str[::-1]"},
      "REPEAT": {"java": "str.repeat(n)", "python": "str * n"},
      "VERIFY": {"java": "Custom validation", "python": "Custom or regex"},
      "COPY": {"java": "Arrays.copyOf()", "python": "copy.copy()"}
    },
    "math_functions": {
      "ABS": {"java": "Math.abs()", "python": "abs()"},
      "CEIL": {"java": "Math.ceil()", "python": "math.ceil()"},
      "FLOOR": {"java": "Math.floor()", "python": "math.floor()"},
      "MOD": {"java": "x % y", "python": "x % y"},
      "ROUND": {"java": "Math.round() or BigDecimal.setScale()", "python": "round() or Decimal.quantize()"},
      "SIGN": {"java": "Math.signum()", "python": "math.copysign(1, x)"},
      "SQRT": {"java": "Math.sqrt()", "python": "math.sqrt()"},
      "LOG": {"java": "Math.log()", "python": "math.log()"},
      "LOG10": {"java": "Math.log10()", "python": "math.log10()"},
      "EXP": {"java": "Math.exp()", "python": "math.exp()"},
      "SIN": {"java": "Math.sin()", "python": "math.sin()"},
      "COS": {"java": "Math.cos()", "python": "math.cos()"},
      "TAN": {"java": "Math.tan()", "python": "math.tan()"},
      "ATAN": {"java": "Math.atan()", "python": "math.atan()"},
      "ATAN2": {"java": "Math.atan2(y, x)", "python": "math.atan2(y, x)"}
    },
    "conversion_functions": {
      "BINARY": {"java": "Integer.parseInt(str, 2)", "python": "int(str, 2)"},
      "DECIMAL": {"java": "new BigDecimal(str)", "python": "Decimal(str)"},
      "FIXED": {"java": "BigDecimal with scale", "python": "Decimal with quantize"},
      "FLOAT": {"java": "Double.parseDouble(str)", "python": "float(str)"},
      "CHAR": {"java": "String.valueOf()", "python": "str()"},
      "BIT": {"java": "Integer.toBinaryString()", "python": "bin()"}
    },
    "date_functions": {
      "DATE": {"java": "LocalDate.now()", "python": "date.today()"},
      "TIME": {"java": "LocalTime.now()", "python": "datetime.now().time()"},
      "DATETIME": {"java": "LocalDateTime.now()", "python": "datetime.now()"}
    }
  },
  "data_type_mapping": {
    "CHAR(n)": {"java": "String", "python": "str"},
    "VARCHAR(n)": {"java": "String", "python": "str"},
    "BIT(n)": {"java": "byte[] or BitSet", "python": "int (bitwise)"},
    "FIXED BIN(15)": {"java": "short", "python": "int"},
    "FIXED BIN(31)": {"java": "int", "python": "int"},
    "FIXED BIN(63)": {"java": "long", "python": "int"},
    "FIXED DEC(p,s)": {"java": "BigDecimal", "python": "Decimal"},
    "FLOAT BIN(21)": {"java": "float", "python": "float"},
    "FLOAT BIN(53)": {"java": "double", "python": "float"},
    "POINTER": {"java": "Object reference", "python": "object reference"},
    "OFFSET": {"java": "int (index)", "python": "int (index)"},
    "FILE": {"java": "BufferedReader/Writer, Channel", "python": "file object"},
    "ENTRY": {"java": "Method reference, Functional Interface", "python": "callable"},
    "LABEL": {"java": "Not directly supported (use state machine)", "python": "Not directly supported"},
    "AREA": {"java": "ByteBuffer", "python": "bytearray, memoryview"},
    "PICTURE": {"java": "DecimalFormat, custom formatter", "python": "format strings, locale"}
  }
}

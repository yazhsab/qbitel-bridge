"""
Vulnerability Scanner

Integrates with Trivy and Clair to scan container images for CVEs and
quantum-vulnerable cryptographic libraries.
"""

import logging
import subprocess
import json
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
import hashlib

logger = logging.getLogger(__name__)


class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    UNKNOWN = "UNKNOWN"


@dataclass
class Vulnerability:
    """Represents a discovered vulnerability"""
    vuln_id: str
    severity: SeverityLevel
    package_name: str
    installed_version: str
    fixed_version: Optional[str]
    title: str
    description: str
    quantum_vulnerable: bool = False


class VulnerabilityScanner:
    """
    Scans container images for vulnerabilities using Trivy and Clair.
    Also detects quantum-vulnerable cryptographic libraries.
    """

    def __init__(
        self,
        trivy_path: str = "trivy",
        enable_trivy: bool = True,
        enable_quantum_scan: bool = True
    ):
        """
        Initialize vulnerability scanner.

        Args:
            trivy_path: Path to Trivy binary
            enable_trivy: Enable Trivy scanning
            enable_quantum_scan: Enable quantum vulnerability detection
        """
        self.trivy_path = trivy_path
        self.enable_trivy = enable_trivy
        self.enable_quantum_scan = enable_quantum_scan

        # Quantum-vulnerable crypto libraries
        self._quantum_vulnerable_libs = {
            "openssl": ["1.0", "1.1.0", "1.1.1"],  # RSA/ECDH
            "libgcrypt": ["1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "1.8"],
            "cryptography": ["0.", "1.", "2.", "3.0", "3.1", "3.2", "3.3"],  # Pre-PQC
            "golang.org/x/crypto": ["0."],
            "bouncycastle": ["1."],
            "nacl": ["*"],  # Uses Curve25519
            "libsodium": ["1.0"],  # Uses Curve25519
        }

        logger.info("Initialized VulnerabilityScanner")

    async def scan_image(
        self,
        image: str,
        severity_threshold: SeverityLevel = SeverityLevel.MEDIUM
    ) -> Dict[str, Any]:
        """
        Scan a container image for vulnerabilities.

        Args:
            image: Container image name (e.g., "nginx:latest")
            severity_threshold: Minimum severity to report

        Returns:
            Dict containing scan results
        """
        logger.info(f"Scanning image: {image}")

        results = {
            "image": image,
            "scan_timestamp": None,
            "total_vulnerabilities": 0,
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "quantum_vulnerable": 0,
            "vulnerabilities": [],
            "quantum_vulnerabilities": []
        }

        # Run Trivy scan
        if self.enable_trivy:
            trivy_results = await self._run_trivy_scan(image)
            results["vulnerabilities"].extend(trivy_results)

        # Run quantum vulnerability scan
        if self.enable_quantum_scan:
            quantum_vulns = await self._scan_quantum_vulnerabilities(image)
            results["quantum_vulnerabilities"].extend(quantum_vulns)
            results["quantum_vulnerable"] = len(quantum_vulns)

        # Aggregate statistics
        for vuln in results["vulnerabilities"]:
            results["total_vulnerabilities"] += 1
            if vuln.severity == SeverityLevel.CRITICAL:
                results["critical"] += 1
            elif vuln.severity == SeverityLevel.HIGH:
                results["high"] += 1
            elif vuln.severity == SeverityLevel.MEDIUM:
                results["medium"] += 1
            elif vuln.severity == SeverityLevel.LOW:
                results["low"] += 1

        logger.info(
            f"Scan complete: {results['total_vulnerabilities']} CVEs, "
            f"{results['quantum_vulnerable']} quantum-vulnerable packages"
        )

        return results

    async def _run_trivy_scan(self, image: str) -> List[Vulnerability]:
        """Run Trivy vulnerability scan"""
        try:
            # Run Trivy in JSON mode
            cmd = [
                self.trivy_path,
                "image",
                "--format", "json",
                "--severity", "CRITICAL,HIGH,MEDIUM,LOW",
                image
            ]

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.returncode != 0:
                logger.error(f"Trivy scan failed: {result.stderr}")
                return []

            # Parse Trivy output
            trivy_data = json.loads(result.stdout)
            vulnerabilities = []

            for target in trivy_data.get("Results", []):
                for vuln_data in target.get("Vulnerabilities", []):
                    vuln = Vulnerability(
                        vuln_id=vuln_data.get("VulnerabilityID", ""),
                        severity=SeverityLevel[vuln_data.get("Severity", "UNKNOWN")],
                        package_name=vuln_data.get("PkgName", ""),
                        installed_version=vuln_data.get("InstalledVersion", ""),
                        fixed_version=vuln_data.get("FixedVersion"),
                        title=vuln_data.get("Title", ""),
                        description=vuln_data.get("Description", "")
                    )
                    vulnerabilities.append(vuln)

            logger.info(f"Trivy found {len(vulnerabilities)} vulnerabilities")
            return vulnerabilities

        except Exception as e:
            logger.error(f"Error running Trivy scan: {e}")
            return []

    async def _scan_quantum_vulnerabilities(self, image: str) -> List[Dict[str, Any]]:
        """Scan for quantum-vulnerable cryptographic libraries"""
        quantum_vulns = []

        try:
            # Get image layers and package list
            # In production, extract packages from image
            # For now, simulate with common packages

            for lib_name, vulnerable_versions in self._quantum_vulnerable_libs.items():
                # Check if library is present (simulated)
                # In production, parse image filesystem

                quantum_vuln = {
                    "library": lib_name,
                    "vulnerability_type": "quantum-vulnerable-crypto",
                    "severity": "HIGH",
                    "description": f"{lib_name} uses classical crypto vulnerable to quantum attacks",
                    "recommendation": "Upgrade to quantum-safe alternative or use QBITEL encryption layer",
                    "cwe": "CWE-327",  # Use of broken/risky crypto
                    "quantum_safe_alternative": self._get_quantum_safe_alternative(lib_name)
                }

                # Add to results (in production, only if library detected)
                # quantum_vulns.append(quantum_vuln)

            logger.info(f"Found {len(quantum_vulns)} quantum-vulnerable libraries")
            return quantum_vulns

        except Exception as e:
            logger.error(f"Error scanning quantum vulnerabilities: {e}")
            return []

    def _get_quantum_safe_alternative(self, library: str) -> str:
        """Get quantum-safe alternative recommendation"""
        alternatives = {
            "openssl": "liboqs (Open Quantum Safe)",
            "libgcrypt": "liboqs with libgcrypt backend",
            "cryptography": "pqcrypto (Python PQC library)",
            "golang.org/x/crypto": "circl (Cloudflare crypto library with PQC)",
            "bouncycastle": "BouncyCastle with PQC support",
            "nacl": "liboqs",
            "libsodium": "liboqs"
        }
        return alternatives.get(library, "QBITEL quantum-safe encryption")

    def generate_scan_report(
        self,
        scan_results: Dict[str, Any],
        format: str = "json"
    ) -> str:
        """
        Generate scan report in specified format.

        Args:
            scan_results: Scan results from scan_image()
            format: Output format (json, text, html)

        Returns:
            Formatted report string
        """
        if format == "json":
            return json.dumps(scan_results, indent=2, default=str)

        elif format == "text":
            report = f"""
Container Image Scan Report
===========================

Image: {scan_results['image']}
Total Vulnerabilities: {scan_results['total_vulnerabilities']}

Severity Breakdown:
  Critical: {scan_results['critical']}
  High: {scan_results['high']}
  Medium: {scan_results['medium']}
  Low: {scan_results['low']}

Quantum-Vulnerable Packages: {scan_results['quantum_vulnerable']}

"""
            return report

        return json.dumps(scan_results, indent=2, default=str)

    async def scan_multiple_images(
        self,
        images: List[str]
    ) -> Dict[str, Dict[str, Any]]:
        """
        Scan multiple images in batch.

        Args:
            images: List of image names

        Returns:
            Dict mapping image names to scan results
        """
        results = {}

        for image in images:
            try:
                results[image] = await self.scan_image(image)
            except Exception as e:
                logger.error(f"Failed to scan {image}: {e}")
                results[image] = {"error": str(e)}

        return results

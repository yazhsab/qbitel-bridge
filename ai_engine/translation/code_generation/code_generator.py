"""
QBITEL - Multi-Language Code Generator
Enterprise-grade SDK generation in multiple programming languages with LLM-enhanced code quality.
"""

import asyncio
import logging
import time
import json
from typing import Dict, List, Optional, Any, Union, Tuple, Set
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from abc import ABC, abstractmethod
import hashlib
import re

from ...core.config import Config
from ...core.exceptions import QbitelAIException
from ...llm.unified_llm_service import UnifiedLLMService, LLMRequest, LLMResponse

from ..models import (
    APISpecification,
    APIEndpoint,
    GeneratedCode,
    GeneratedSDK,
    CodeLanguage,
    SecurityLevel,
    APIStyle,
    TranslationException,
)

from prometheus_client import Counter, Histogram, Gauge
import uuid

# Metrics for code generation
CODE_GENERATION_COUNTER = Counter(
    "qbitel_code_generation_total",
    "Total code generation attempts",
    ["language", "type", "status"],
)

CODE_GENERATION_DURATION = Histogram(
    "qbitel_code_generation_duration_seconds",
    "Code generation duration",
    ["language", "type"],
)

SDK_GENERATION_COUNTER = Counter(
    "qbitel_sdk_generation_total",
    "Total SDK generation attempts",
    ["language", "status"],
)

GENERATED_FILES_GAUGE = Gauge("qbitel_generated_files_total", "Total generated files count")

logger = logging.getLogger(__name__)


class CodeGenerationException(QbitelAIException):
    """Code generation specific exceptions."""

    pass


@dataclass
class CodeTemplate:
    """Template for code generation."""

    name: str
    language: CodeLanguage
    template: str
    file_extension: str
    dependencies: List[str] = field(default_factory=list)
    imports: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class GenerationContext:
    """Context for code generation."""

    api_specification: APISpecification
    target_language: CodeLanguage
    package_name: str
    namespace: Optional[str] = None
    version: str = "1.0.0"
    author: Optional[str] = None
    description: Optional[str] = None
    generate_tests: bool = True
    generate_examples: bool = True
    generate_documentation: bool = True
    include_async_support: bool = True
    include_validation: bool = True
    security_level: SecurityLevel = SecurityLevel.AUTHENTICATED
    custom_templates: List[CodeTemplate] = field(default_factory=list)
    llm_enhancement: bool = True
    style_preferences: Dict[str, Any] = field(default_factory=dict)


class BaseCodeGenerator(ABC):
    """Base class for language-specific code generators."""

    def __init__(self, config: Config, llm_service: Optional[UnifiedLLMService] = None):
        self.config = config
        self.llm_service = llm_service
        self.logger = logging.getLogger(self.__class__.__name__)

    @abstractmethod
    async def generate_client_code(self, context: GenerationContext) -> GeneratedCode:
        """Generate main client code."""
        pass

    @abstractmethod
    async def generate_models(self, context: GenerationContext) -> List[GeneratedCode]:
        """Generate data model classes."""
        pass

    @abstractmethod
    async def generate_tests(self, context: GenerationContext) -> List[GeneratedCode]:
        """Generate test files."""
        pass

    @abstractmethod
    def get_dependencies(self, context: GenerationContext) -> List[str]:
        """Get required dependencies."""
        pass

    @abstractmethod
    def get_file_extension(self) -> str:
        """Get file extension for this language."""
        pass


class PythonCodeGenerator(BaseCodeGenerator):
    """Python SDK generator with comprehensive features."""

    def __init__(self, config: Config, llm_service: Optional[UnifiedLLMService] = None):
        super().__init__(config, llm_service)
        self.language = CodeLanguage.PYTHON

    async def generate_client_code(self, context: GenerationContext) -> GeneratedCode:
        """Generate Python client SDK."""
        class_name = self._to_class_name(context.api_specification.title)

        client_code = f'''"""
{context.api_specification.title} Python SDK
Generated by QBITEL Translation Studio

{context.api_specification.description or 'Protocol API Client'}
"""

import asyncio
import json
import logging
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, asdict
from datetime import datetime
import httpx
import base64
from urllib.parse import urljoin

from .models import *
from .exceptions import *


class {class_name}Config:
    """Configuration for {class_name} client."""
    
    def __init__(
        self,
        base_url: str,
        api_key: Optional[str] = None,
        bearer_token: Optional[str] = None,
        timeout: int = 30,
        retries: int = 3
    ):
        self.base_url = base_url.rstrip('/')
        self.api_key = api_key
        self.bearer_token = bearer_token
        self.timeout = timeout
        self.retries = retries
        self.headers = {{"Content-Type": "application/json"}}
        
        if self.api_key:
            self.headers["X-API-Key"] = self.api_key
        if self.bearer_token:
            self.headers["Authorization"] = f"Bearer {{self.bearer_token}}"


class {class_name}:
    """
    {context.api_specification.title} Python SDK Client
    
    Provides comprehensive access to {context.api_specification.title} API endpoints
    with automatic retries, error handling, and type validation.
    
    Example:
        client = {class_name}(config)
        result = await client.process_message(message_data)
    """
    
    def __init__(self, config: {class_name}Config):
        self.config = config
        self.client = httpx.AsyncClient(
            base_url=config.base_url,
            headers=config.headers,
            timeout=config.timeout
        )
        self.logger = logging.getLogger(__name__)
    
    async def __aenter__(self):
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()
    
    async def close(self):
        """Close the HTTP client."""
        await self.client.aclose()
    
    async def _make_request(
        self,
        method: str,
        endpoint: str,
        data: Optional[Dict[str, Any]] = None,
        params: Optional[Dict[str, Any]] = None,
        files: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Make HTTP request with retry logic and error handling."""
        url = urljoin(self.config.base_url, endpoint.lstrip('/'))
        
        for attempt in range(self.config.retries + 1):
            try:
                if files:
                    response = await self.client.request(
                        method, url, data=data, params=params, files=files
                    )
                else:
                    response = await self.client.request(
                        method, url, json=data, params=params
                    )
                
                if response.status_code == 429:  # Rate limited
                    if attempt < self.config.retries:
                        await asyncio.sleep(2 ** attempt)
                        continue
                
                response.raise_for_status()
                
                if response.headers.get('content-type', '').startswith('application/json'):
                    return response.json()
                else:
                    return {{"content": response.text}}
                    
            except httpx.HTTPStatusError as e:
                if e.response.status_code >= 400 and e.response.status_code < 500:
                    # Client error - don't retry
                    self._handle_error_response(e.response)
                elif attempt == self.config.retries:
                    # Last attempt failed
                    self._handle_error_response(e.response)
                else:
                    # Server error - retry
                    self.logger.warning(f"Request failed (attempt {{attempt + 1}}): {{e}}")
                    await asyncio.sleep(2 ** attempt)
            except Exception as e:
                if attempt == self.config.retries:
                    raise {class_name}Exception(f"Request failed: {{e}}")
                self.logger.warning(f"Request failed (attempt {{attempt + 1}}): {{e}}")
                await asyncio.sleep(2 ** attempt)
        
        raise {class_name}Exception("Max retries exceeded")
    
    def _handle_error_response(self, response: httpx.Response) -> None:
        """Handle error responses and raise appropriate exceptions."""
        try:
            error_data = response.json()
            error_message = error_data.get('message', 'Unknown error')
        except:
            error_message = response.text or f"HTTP {{response.status_code}} error"
        
        if response.status_code == 400:
            raise ValidationException(error_message)
        elif response.status_code == 401:
            raise AuthenticationException(error_message)
        elif response.status_code == 403:
            raise AuthorizationException(error_message)
        elif response.status_code == 404:
            raise NotFoundException(error_message)
        elif response.status_code == 422:
            raise ValidationException(error_message)
        else:
            raise {class_name}Exception(error_message)

'''

        # Generate methods for each endpoint
        for endpoint in context.api_specification.endpoints:
            method_code = await self._generate_endpoint_method(endpoint, context)
            client_code += method_code + "\n"

        return GeneratedCode(
            language=self.language,
            code=client_code,
            filename=f"{self._to_snake_case(context.package_name)}_client.py",
            dependencies=self.get_dependencies(context),
            documentation=f"Main client class for {context.api_specification.title} SDK",
        )

    async def _generate_endpoint_method(self, endpoint: APIEndpoint, context: GenerationContext) -> str:
        """Generate Python method for an API endpoint."""
        method_name = self._to_snake_case(endpoint.operation_id or f"{endpoint.method}_{endpoint.path.split('/')[-1]}")

        # Extract path parameters
        path_params = re.findall(r"\{([^}]+)\}", endpoint.path)

        # Build method signature
        params = ["self"]
        if path_params:
            params.extend(f"{param}: str" for param in path_params)

        # Add request body parameter if needed
        if endpoint.request_body:
            if endpoint.method.upper() in ["POST", "PUT", "PATCH"]:
                params.append("data: Dict[str, Any]")

        # Add query parameters
        query_params = [p for p in endpoint.parameters if p.get("in") == "query"]
        if query_params:
            for param in query_params:
                param_name = param["name"]
                param_type = "str"  # Simplified
                if not param.get("required", False):
                    params.append(f"{param_name}: Optional[{param_type}] = None")
                else:
                    params.append(f"{param_name}: {param_type}")

        method_signature = f"async def {method_name}({', '.join(params)}) -> Dict[str, Any]:"

        # Generate method body
        docstring = f'        """{endpoint.summary}\n        \n        {endpoint.description or ""}\n        """'

        # Build endpoint URL
        endpoint_url = endpoint.path
        for param in path_params:
            endpoint_url = endpoint_url.replace(f"{{{param}}}", f"{{{{param}}}}")

        method_body = f"""
        {docstring}
        endpoint = "{endpoint_url}"
        """

        if path_params:
            for param in path_params:
                method_body += f"""
        endpoint = endpoint.replace("{{{param}}}", {param})"""

        # Add query parameters handling
        if query_params:
            method_body += "\n        params = {}\n"
            for param in query_params:
                param_name = param["name"]
                method_body += f'        if {param_name} is not None:\n            params["{param_name}"] = {param_name}\n'
        else:
            method_body += "\n        params = None\n"

        # Make the request
        if endpoint.request_body:
            method_body += f"""
        return await self._make_request(
            "{endpoint.method.upper()}",
            endpoint,
            data=data,
            params=params
        )"""
        else:
            method_body += f"""
        return await self._make_request(
            "{endpoint.method.upper()}",
            endpoint,
            params=params
        )"""

        return "    " + method_signature + method_body.replace("\n        ", "\n        ")

    async def generate_models(self, context: GenerationContext) -> List[GeneratedCode]:
        """Generate Python data models."""
        models_code = '''"""
Data models for {title} SDK
Generated by QBITEL Translation Studio
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Union
from datetime import datetime
from enum import Enum


class {title}Exception(Exception):
    """Base exception for {title} SDK."""
    pass


class ValidationException({title}Exception):
    """Validation error exception."""
    pass


class AuthenticationException({title}Exception):
    """Authentication error exception."""
    pass


class AuthorizationException({title}Exception):
    """Authorization error exception."""
    pass


class NotFoundException({title}Exception):
    """Resource not found exception."""
    pass

'''.format(title=self._to_class_name(context.api_specification.title))

        # Generate models from schemas
        for schema_name, schema_def in context.api_specification.schemas.items():
            if schema_name not in ["Error", "ValidationError"]:  # Skip common schemas
                model_code = self._generate_python_model(schema_name, schema_def)
                models_code += model_code + "\n\n"

        return [
            GeneratedCode(
                language=self.language,
                code=models_code,
                filename="models.py",
                dependencies=[],
                documentation="Data models and exceptions",
            )
        ]

    def _generate_python_model(self, name: str, schema: Dict[str, Any]) -> str:
        """Generate Python dataclass from schema."""
        if schema.get("type") != "object":
            return f"# Skipping non-object schema: {name}"

        properties = schema.get("properties", {})
        required = schema.get("required", [])

        class_code = f'''@dataclass
class {name}:
    """{schema.get('description', f'{name} data model')}"""
'''

        # Generate fields
        for prop_name, prop_def in properties.items():
            python_type = self._map_openapi_type_to_python(prop_def)
            is_optional = prop_name not in required

            if is_optional:
                class_code += f"    {prop_name}: Optional[{python_type}] = None\n"
            else:
                if python_type in ["List", "Dict"]:
                    class_code += f"    {prop_name}: {python_type} = field(default_factory={python_type.lower()})\n"
                else:
                    class_code += f"    {prop_name}: {python_type}\n"

        # Add helper methods
        class_code += f'''
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> '{name}':
        """Create from dictionary."""
        return cls(**data)
'''

        return class_code

    def _map_openapi_type_to_python(self, prop_def: Dict[str, Any]) -> str:
        """Map OpenAPI type to Python type."""
        openapi_type = prop_def.get("type", "string")
        format_type = prop_def.get("format")

        if openapi_type == "string":
            if format_type == "date-time":
                return "datetime"
            elif format_type == "binary":
                return "bytes"
            else:
                return "str"
        elif openapi_type == "integer":
            return "int"
        elif openapi_type == "number":
            return "float"
        elif openapi_type == "boolean":
            return "bool"
        elif openapi_type == "array":
            items_type = self._map_openapi_type_to_python(prop_def.get("items", {}))
            return f"List[{items_type}]"
        elif openapi_type == "object":
            return "Dict[str, Any]"
        else:
            return "Any"

    async def generate_tests(self, context: GenerationContext) -> List[GeneratedCode]:
        """Generate Python test files."""
        class_name = self._to_class_name(context.api_specification.title)

        test_code = f'''"""
Tests for {context.api_specification.title} Python SDK
Generated by QBITEL Translation Studio
"""

import pytest
import httpx
from unittest.mock import AsyncMock, patch
from {self._to_snake_case(context.package_name)}_client import {class_name}, {class_name}Config
from models import *


@pytest.fixture
def client_config():
    """Test client configuration."""
    return {class_name}Config(
        base_url="https://api.test.com",
        api_key="test-key",
        timeout=10
    )


@pytest.fixture
def client(client_config):
    """Test client instance."""
    return {class_name}(client_config)


@pytest.mark.asyncio
class Test{class_name}:
    """Test cases for {class_name}."""
    
    async def test_client_initialization(self, client_config):
        """Test client initialization."""
        client = {class_name}(client_config)
        assert client.config.base_url == "https://api.test.com"
        assert client.config.api_key == "test-key"
        await client.close()
    
    @patch('httpx.AsyncClient.request')
    async def test_successful_request(self, mock_request, client):
        """Test successful API request."""
        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {{"result": "success"}}
        mock_response.headers.get.return_value = "application/json"
        mock_request.return_value = mock_response
        
        result = await client._make_request("GET", "/test")
        assert result == {{"result": "success"}}
        await client.close()
    
    @patch('httpx.AsyncClient.request')
    async def test_error_handling(self, mock_request, client):
        """Test error handling."""
        mock_response = AsyncMock()
        mock_response.status_code = 400
        mock_response.json.return_value = {{"error": "Bad Request"}}
        mock_request.side_effect = httpx.HTTPStatusError(
            "Bad Request", request=AsyncMock(), response=mock_response
        )
        
        with pytest.raises(ValidationException):
            await client._make_request("GET", "/test")
        await client.close()
'''

        return [
            GeneratedCode(
                language=self.language,
                code=test_code,
                filename="test_client.py",
                dependencies=["pytest", "pytest-asyncio"],
                documentation="Unit tests for the Python SDK",
            )
        ]

    def get_dependencies(self, context: GenerationContext) -> List[str]:
        """Get Python dependencies."""
        dependencies = ["httpx>=0.24.0", "typing-extensions>=4.0.0"]

        if context.include_async_support:
            dependencies.append("asyncio")

        return dependencies

    def get_file_extension(self) -> str:
        """Get Python file extension."""
        return ".py"

    def _to_class_name(self, name: str) -> str:
        """Convert to Python class name (PascalCase)."""
        return "".join(word.capitalize() for word in re.split(r"[_\-\s]+", name))

    def _to_snake_case(self, name: str) -> str:
        """Convert to Python variable name (snake_case)."""
        return re.sub(r"[_\-\s]+", "_", name).lower()


class TypeScriptCodeGenerator(BaseCodeGenerator):
    """TypeScript SDK generator with modern ES6+ features."""

    def __init__(self, config: Config, llm_service: Optional[UnifiedLLMService] = None):
        super().__init__(config, llm_service)
        self.language = CodeLanguage.TYPESCRIPT

    async def generate_client_code(self, context: GenerationContext) -> GeneratedCode:
        """Generate TypeScript client SDK."""
        class_name = self._to_class_name(context.api_specification.title)

        client_code = f"""/**
 * {context.api_specification.title} TypeScript SDK
 * Generated by QBITEL Translation Studio
 * 
 * {context.api_specification.description or 'Protocol API Client'}
 */

import {{ AxiosInstance, AxiosRequestConfig, AxiosResponse }} from 'axios';
import axios from 'axios';
import * as models from './models';
import {{ APIError, ValidationError, AuthenticationError, AuthorizationError, NotFoundError }} from './errors';

export interface {class_name}Config {{
    baseURL: string;
    apiKey?: string;
    bearerToken?: string;
    timeout?: number;
    retries?: number;
}}

export class {class_name} {{
    private client: AxiosInstance;
    private config: {class_name}Config;
    
    constructor(config: {class_name}Config) {{
        this.config = {{ timeout: 30000, retries: 3, ...config }};
        
        this.client = axios.create({{
            baseURL: this.config.baseURL,
            timeout: this.config.timeout,
            headers: {{
                'Content-Type': 'application/json',
                ...(this.config.apiKey && {{ 'X-API-Key': this.config.apiKey }}),
                ...(this.config.bearerToken && {{ 'Authorization': `Bearer ${{this.config.bearerToken}}` }})
            }}
        }});
        
        this.setupInterceptors();
    }}
    
    private setupInterceptors(): void {{
        // Response interceptor for error handling
        this.client.interceptors.response.use(
            (response: AxiosResponse) => response,
            (error) => this.handleError(error)
        );
    }}
    
    private async makeRequest<T>(
        method: string,
        endpoint: string,
        data?: any,
        params?: Record<string, any>
    ): Promise<T> {{
        let lastError: Error;
        
        for (let attempt = 0; attempt <= this.config.retries!; attempt++) {{
            try {{
                const response = await this.client.request({{
                    method: method as any,
                    url: endpoint,
                    data,
                    params
                }});
                
                return response.data;
            }} catch (error) {{
                lastError = error as Error;
                
                if (error.response?.status === 429 && attempt < this.config.retries!) {{
                    // Rate limited - wait and retry
                    await this.delay(Math.pow(2, attempt) * 1000);
                    continue;
                }}
                
                if (error.response?.status >= 400 && error.response?.status < 500) {{
                    // Client error - don't retry
                    throw error;
                }}
                
                if (attempt === this.config.retries) {{
                    throw error;
                }}
                
                // Server error - retry after delay
                await this.delay(Math.pow(2, attempt) * 1000);
            }}
        }}
        
        throw lastError!;
    }}
    
    private handleError(error: any): never {{
        if (error.response) {{
            const status = error.response.status;
            const message = error.response.data?.message || error.message || 'Unknown error';
            
            switch (status) {{
                case 400:
                    throw new ValidationError(message);
                case 401:
                    throw new AuthenticationError(message);
                case 403:
                    throw new AuthorizationError(message);
                case 404:
                    throw new NotFoundError(message);
                case 422:
                    throw new ValidationError(message);
                default:
                    throw new APIError(message, status);
            }}
        }}
        
        throw new APIError(error.message || 'Network error');
    }}
    
    private delay(ms: number): Promise<void> {{
        return new Promise(resolve => setTimeout(resolve, ms));
    }}

"""

        # Generate methods for each endpoint
        for endpoint in context.api_specification.endpoints:
            method_code = await self._generate_ts_endpoint_method(endpoint, context)
            client_code += method_code + "\n"

        client_code += "}\n\nexport * from './models';\nexport * from './errors';\n"

        return GeneratedCode(
            language=self.language,
            code=client_code,
            filename="client.ts",
            dependencies=self.get_dependencies(context),
            documentation=f"Main client class for {context.api_specification.title} SDK",
        )

    async def _generate_ts_endpoint_method(self, endpoint: APIEndpoint, context: GenerationContext) -> str:
        """Generate TypeScript method for an API endpoint."""
        method_name = self._to_camel_case(endpoint.operation_id or f"{endpoint.method}_{endpoint.path.split('/')[-1]}")

        # Extract path parameters
        path_params = re.findall(r"\{([^}]+)\}", endpoint.path)

        # Build method signature
        params = []
        if path_params:
            params.extend(f"{param}: string" for param in path_params)

        # Add request body parameter
        if endpoint.request_body:
            if endpoint.method.upper() in ["POST", "PUT", "PATCH"]:
                params.append("data: any")

        # Add query parameters
        query_params = [p for p in endpoint.parameters if p.get("in") == "query"]
        if query_params:
            params.append("options?: { " + ", ".join(f"{p['name']}?: any" for p in query_params) + " }")

        method_signature = f"async {method_name}({', '.join(params)}): Promise<any>"

        # Generate method body
        endpoint_url = endpoint.path
        for param in path_params:
            endpoint_url = endpoint_url.replace(f"{{{param}}}", f"${{{param}}}")

        method_body = f"""    /**
     * {endpoint.summary}
     * {endpoint.description or ""}
     */
    {method_signature} {{
        const endpoint = `{endpoint_url}`;
        
        return this.makeRequest<any>(
            '{endpoint.method.upper()}',
            endpoint"""

        if endpoint.request_body:
            method_body += ",\n            data"
        else:
            method_body += ",\n            undefined"

        if query_params:
            method_body += ",\n            options"

        method_body += "\n        );\n    }"

        return method_body

    async def generate_models(self, context: GenerationContext) -> List[GeneratedCode]:
        """Generate TypeScript interfaces and types."""
        models_code = f"""/**
 * Data models for {context.api_specification.title} SDK
 * Generated by QBITEL Translation Studio
 */

"""

        # Generate interfaces from schemas
        for schema_name, schema_def in context.api_specification.schemas.items():
            if schema_name not in ["Error", "ValidationError"]:
                interface_code = self._generate_ts_interface(schema_name, schema_def)
                models_code += interface_code + "\n\n"

        return [
            GeneratedCode(
                language=self.language,
                code=models_code,
                filename="models.ts",
                dependencies=[],
                documentation="TypeScript interfaces and types",
            )
        ]

    def _generate_ts_interface(self, name: str, schema: Dict[str, Any]) -> str:
        """Generate TypeScript interface from schema."""
        if schema.get("type") != "object":
            return f"// Skipping non-object schema: {name}"

        properties = schema.get("properties", {})
        required = schema.get("required", [])

        interface_code = f"""export interface {name} {{
    /**
     * {schema.get('description', f'{name} interface')}
     */
"""

        for prop_name, prop_def in properties.items():
            ts_type = self._map_openapi_type_to_typescript(prop_def)
            is_optional = prop_name not in required
            optional_marker = "?" if is_optional else ""

            description = prop_def.get("description", "")
            if description:
                interface_code += f"    /** {description} */\n"

            interface_code += f"    {prop_name}{optional_marker}: {ts_type};\n"

        interface_code += "}"

        return interface_code

    def _map_openapi_type_to_typescript(self, prop_def: Dict[str, Any]) -> str:
        """Map OpenAPI type to TypeScript type."""
        openapi_type = prop_def.get("type", "string")
        format_type = prop_def.get("format")

        if openapi_type == "string":
            if format_type in ["date", "date-time"]:
                return "string | Date"
            else:
                return "string"
        elif openapi_type == "integer":
            return "number"
        elif openapi_type == "number":
            return "number"
        elif openapi_type == "boolean":
            return "boolean"
        elif openapi_type == "array":
            items_type = self._map_openapi_type_to_typescript(prop_def.get("items", {}))
            return f"{items_type}[]"
        elif openapi_type == "object":
            return "Record<string, any>"
        else:
            return "any"

    async def generate_tests(self, context: GenerationContext) -> List[GeneratedCode]:
        """Generate TypeScript test files."""
        class_name = self._to_class_name(context.api_specification.title)

        test_code = f"""/**
 * Tests for {context.api_specification.title} TypeScript SDK
 * Generated by QBITEL Translation Studio
 */

import {{ {class_name}, {class_name}Config }} from './client';
import {{ describe, it, expect, beforeEach, jest }} from '@jest/globals';
import axios from 'axios';

// Mock axios
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('{class_name}', () => {{
    let client: {class_name};
    let config: {class_name}Config;
    
    beforeEach(() => {{
        config = {{
            baseURL: 'https://api.test.com',
            apiKey: 'test-key',
            timeout: 10000
        }};
        
        // Reset mocks
        jest.clearAllMocks();
        
        // Setup axios mock
        mockedAxios.create.mockReturnValue({{
            request: jest.fn(),
            interceptors: {{
                request: {{ use: jest.fn() }},
                response: {{ use: jest.fn() }}
            }}
        }} as any);
        
        client = new {class_name}(config);
    }});
    
    it('should initialize client with correct configuration', () => {{
        expect(mockedAxios.create).toHaveBeenCalledWith({{
            baseURL: 'https://api.test.com',
            timeout: 10000,
            headers: {{
                'Content-Type': 'application/json',
                'X-API-Key': 'test-key'
            }}
        }});
    }});
    
    it('should handle successful API responses', async () => {{
        const mockResponse = {{ data: {{ result: 'success' }} }};
        (client as any).client.request.mockResolvedValue(mockResponse);
        
        const result = await (client as any).makeRequest('GET', '/test');
        expect(result).toEqual({{ result: 'success' }});
    }});
}});
"""

        return [
            GeneratedCode(
                language=self.language,
                code=test_code,
                filename="client.test.ts",
                dependencies=["@jest/globals", "@types/jest", "jest"],
                documentation="Unit tests for the TypeScript SDK",
            )
        ]

    def get_dependencies(self, context: GenerationContext) -> List[str]:
        """Get TypeScript dependencies."""
        return ["axios>=1.0.0", "@types/node"]

    def get_file_extension(self) -> str:
        """Get TypeScript file extension."""
        return ".ts"

    def _to_class_name(self, name: str) -> str:
        """Convert to TypeScript class name (PascalCase)."""
        return "".join(word.capitalize() for word in re.split(r"[_\-\s]+", name))

    def _to_camel_case(self, name: str) -> str:
        """Convert to TypeScript method name (camelCase)."""
        words = re.split(r"[_\-\s]+", name)
        return words[0].lower() + "".join(word.capitalize() for word in words[1:])


class MultiLanguageCodeGenerator:
    """
    Multi-language code generator orchestrator.

    Coordinates generation of SDKs in multiple programming languages with
    enterprise-grade features including testing, documentation, and examples.
    """

    def __init__(self, config: Config, llm_service: Optional[UnifiedLLMService] = None):
        self.config = config
        self.llm_service = llm_service
        self.logger = logging.getLogger(__name__)

        # Initialize language-specific generators
        self.generators: Dict[CodeLanguage, BaseCodeGenerator] = {
            CodeLanguage.PYTHON: PythonCodeGenerator(config, llm_service),
            CodeLanguage.TYPESCRIPT: TypeScriptCodeGenerator(config, llm_service),
            # Add more generators as needed
        }

        # Generation settings
        self.enable_llm_enhancement = True
        self.enable_code_validation = True
        self.enable_quality_checks = True
        self.max_concurrent_generations = 3

        # Metrics
        self.generation_stats = {
            "total_sdks_generated": 0,
            "successful_generations": 0,
            "failed_generations": 0,
            "average_generation_time": 0.0,
            "languages_supported": len(self.generators),
        }

    async def generate_sdk(
        self,
        api_specification: APISpecification,
        target_language: CodeLanguage,
        package_name: str,
        **kwargs,
    ) -> GeneratedSDK:
        """
        Generate comprehensive SDK for a specific language.

        Args:
            api_specification: OpenAPI specification
            target_language: Target programming language
            package_name: SDK package name
            **kwargs: Additional generation options

        Returns:
            Complete generated SDK with all files
        """
        start_time = time.time()

        try:
            self.logger.info(f"Generating {target_language.value} SDK for {api_specification.title}")

            # Validate inputs
            if target_language not in self.generators:
                raise CodeGenerationException(f"Unsupported language: {target_language.value}")

            generator = self.generators[target_language]

            # Create generation context
            context = GenerationContext(
                api_specification=api_specification,
                target_language=target_language,
                package_name=package_name,
                **kwargs,
            )

            # Generate SDK components
            sdk = GeneratedSDK(
                name=package_name,
                version=context.version,
                language=target_language,
                description=f"{api_specification.title} SDK for {target_language.value}",
                generated_from_api=api_specification.spec_id,
                dependencies=generator.get_dependencies(context),
            )

            # Generate main client code
            client_code = await generator.generate_client_code(context)
            sdk.add_source_file(client_code)

            # Generate models
            if context.api_specification.schemas:
                model_files = await generator.generate_models(context)
                for model_file in model_files:
                    sdk.source_files.append(model_file)

            # Generate tests if requested
            if context.generate_tests:
                test_files = await generator.generate_tests(context)
                sdk.test_files.extend(test_files)

            # Generate configuration files
            config_files = await self._generate_config_files(context, generator)
            sdk.config_files.extend(config_files)

            # Generate documentation if requested
            if context.generate_documentation:
                doc_files = await self._generate_documentation(context, sdk)
                sdk.documentation_files.extend(doc_files)

            # Generate examples if requested
            if context.generate_examples:
                example_files = await self._generate_examples(context, generator)
                sdk.source_files.extend(example_files)

            # Enhance with LLM if enabled
            if context.llm_enhancement and self.llm_service:
                await self._enhance_sdk_with_llm(sdk, context)

            # Validate generated code if enabled
            if self.enable_code_validation:
                await self._validate_generated_code(sdk)

            # Update metrics
            generation_time = time.time() - start_time
            self._update_generation_metrics(True, generation_time)

            SDK_GENERATION_COUNTER.labels(language=target_language.value, status="success").inc()

            CODE_GENERATION_DURATION.labels(language=target_language.value, type="sdk").observe(generation_time)

            GENERATED_FILES_GAUGE.set(
                len(sdk.source_files) + len(sdk.test_files) + len(sdk.config_files) + len(sdk.documentation_files)
            )

            self.logger.info(
                f"SDK generation completed: {len(sdk.source_files)} source files, "
                f"{len(sdk.test_files)} test files, time: {generation_time:.2f}s"
            )

            return sdk

        except Exception as e:
            self.logger.error(f"SDK generation failed: {e}")

            # Update error metrics
            self._update_generation_metrics(False, time.time() - start_time)
            SDK_GENERATION_COUNTER.labels(language=target_language.value, status="error").inc()

            raise CodeGenerationException(f"SDK generation failed: {e}")

    async def generate_multiple_sdks(
        self,
        api_specification: APISpecification,
        target_languages: List[CodeLanguage],
        base_package_name: str,
        **kwargs,
    ) -> Dict[CodeLanguage, GeneratedSDK]:
        """Generate SDKs for multiple languages concurrently."""
        semaphore = asyncio.Semaphore(self.max_concurrent_generations)

        async def generate_single_sdk(
            language: CodeLanguage,
        ) -> Tuple[CodeLanguage, GeneratedSDK]:
            async with semaphore:
                sdk = await self.generate_sdk(
                    api_specification,
                    language,
                    f"{base_package_name}-{language.value}",
                    **kwargs,
                )
                return language, sdk

        # Generate SDKs concurrently
        tasks = [generate_single_sdk(lang) for lang in target_languages if lang in self.generators]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Process results
        sdks = {}
        for result in results:
            if isinstance(result, Exception):
                self.logger.error(f"Multi-SDK generation error: {result}")
                continue

            language, sdk = result
            sdks[language] = sdk

        return sdks

    async def _generate_config_files(self, context: GenerationContext, generator: BaseCodeGenerator) -> List[GeneratedCode]:
        """Generate configuration files for the SDK."""
        config_files = []

        # Package configuration based on language
        if context.target_language == CodeLanguage.PYTHON:
            # Generate setup.py
            setup_py = f"""from setuptools import setup, find_packages

setup(
    name="{context.package_name}",
    version="{context.version}",
    description="{context.description or f'{context.api_specification.title} Python SDK'}",
    author="{context.author or 'Generated by QBITEL'}",
    packages=find_packages(),
    install_requires={generator.get_dependencies(context)},
    python_requires=">=3.8",
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
    ]
)
"""
            config_files.append(
                GeneratedCode(
                    language=context.target_language,
                    code=setup_py,
                    filename="setup.py",
                    dependencies=[],
                    documentation="Python package setup configuration",
                )
            )

            # Generate requirements.txt
            requirements = "\\n".join(generator.get_dependencies(context))
            config_files.append(
                GeneratedCode(
                    language=context.target_language,
                    code=requirements,
                    filename="requirements.txt",
                    dependencies=[],
                    documentation="Python dependencies",
                )
            )

        elif context.target_language == CodeLanguage.TYPESCRIPT:
            # Generate package.json
            package_json = {
                "name": context.package_name,
                "version": context.version,
                "description": context.description or f"{context.api_specification.title} TypeScript SDK",
                "main": "dist/client.js",
                "types": "dist/client.d.ts",
                "scripts": {
                    "build": "tsc",
                    "test": "jest",
                    "lint": "eslint src/**/*.ts",
                },
                "dependencies": {
                    dep.split(">=")[0]: dep.split(">=")[1] if ">=" in dep else "latest"
                    for dep in generator.get_dependencies(context)
                },
                "devDependencies": {
                    "typescript": "^5.0.0",
                    "@types/node": "^18.0.0",
                    "jest": "^29.0.0",
                    "eslint": "^8.0.0",
                },
                "keywords": [
                    "api",
                    "sdk",
                    "typescript",
                    context.api_specification.title.lower(),
                ],
                "license": "MIT",
            }

            config_files.append(
                GeneratedCode(
                    language=context.target_language,
                    code=json.dumps(package_json, indent=2),
                    filename="package.json",
                    dependencies=[],
                    documentation="Node.js package configuration",
                )
            )

            # Generate tsconfig.json
            tsconfig = {
                "compilerOptions": {
                    "target": "ES2020",
                    "module": "commonjs",
                    "lib": ["ES2020"],
                    "outDir": "./dist",
                    "rootDir": "./src",
                    "strict": True,
                    "esModuleInterop": True,
                    "skipLibCheck": True,
                    "forceConsistentCasingInFileNames": True,
                    "declaration": True,
                    "declarationMap": True,
                    "sourceMap": True,
                },
                "include": ["src/**/*"],
                "exclude": ["node_modules", "dist"],
            }

            config_files.append(
                GeneratedCode(
                    language=context.target_language,
                    code=json.dumps(tsconfig, indent=2),
                    filename="tsconfig.json",
                    dependencies=[],
                    documentation="TypeScript configuration",
                )
            )

        return config_files

    async def _generate_documentation(self, context: GenerationContext, sdk: GeneratedSDK) -> List[GeneratedCode]:
        """Generate comprehensive documentation for the SDK."""
        doc_files = []

        # Generate README
        readme_content = f"""# {context.api_specification.title} SDK

{context.api_specification.description or f"SDK for {context.api_specification.title} API"}

Generated by QBITEL Translation Studio

## Installation

### {context.target_language.value.title()}
"""

        if context.target_language == CodeLanguage.PYTHON:
            readme_content += f"""
```bash
pip install {context.package_name}
```

## Usage

```python
from {context.package_name.replace('-', '_')}_client import {self._to_class_name(context.api_specification.title)}, {self._to_class_name(context.api_specification.title)}Config

# Configure client
config = {self._to_class_name(context.api_specification.title)}Config(
    base_url="https://api.example.com",
    api_key="your-api-key"
)

# Create client
client = {self._to_class_name(context.api_specification.title)}(config)

# Use the client
async with client:
    result = await client.process_message(message_data)
    print(result)
```
"""

        elif context.target_language == CodeLanguage.TYPESCRIPT:
            readme_content += f"""
```bash
npm install {context.package_name}
```

## Usage

```typescript
import {{ {self._to_class_name(context.api_specification.title)} }} from '{context.package_name}';

// Configure client
const client = new {self._to_class_name(context.api_specification.title)}({{
    baseURL: 'https://api.example.com',
    apiKey: 'your-api-key'
}});

// Use the client
const result = await client.processMessage(messageData);
console.log(result);
```
"""

        readme_content += f"""
## API Reference

### Configuration

The SDK requires configuration with your API endpoint and credentials:

- `baseURL`: The base URL of the API
- `apiKey`: Your API key for authentication
- `bearerToken`: JWT bearer token (alternative to API key)
- `timeout`: Request timeout in milliseconds (default: 30000)

### Methods

"""

        # Document each endpoint
        for endpoint in context.api_specification.endpoints:
            method_name = self._method_name_for_docs(endpoint, context.target_language)
            readme_content += f"#### `{method_name}`\n\n{endpoint.summary}\n\n{endpoint.description or ''}\n\n"

        readme_content += """
## Error Handling

The SDK provides typed error classes for different types of API errors:

- `ValidationError`: Invalid request data
- `AuthenticationError`: Invalid credentials
- `AuthorizationError`: Insufficient permissions
- `NotFoundError`: Resource not found
- `APIError`: General API errors

## Support

Generated by QBITEL Translation Studio. For issues with this SDK, please contact your system administrator.
"""

        doc_files.append(
            GeneratedCode(
                language=context.target_language,
                code=readme_content,
                filename="README.md",
                dependencies=[],
                documentation="SDK documentation and usage guide",
            )
        )

        return doc_files

    async def _generate_examples(self, context: GenerationContext, generator: BaseCodeGenerator) -> List[GeneratedCode]:
        """Generate usage examples for the SDK."""
        examples = []

        if context.target_language == CodeLanguage.PYTHON:
            example_code = f'''"""
Example usage of {context.api_specification.title} Python SDK
"""

import asyncio
from {context.package_name.replace('-', '_')}_client import {self._to_class_name(context.api_specification.title)}, {self._to_class_name(context.api_specification.title)}Config

async def main():
    # Configure the client
    config = {self._to_class_name(context.api_specification.title)}Config(
        base_url="https://api.example.com",
        api_key="your-api-key-here"
    )
    
    # Create and use the client
    async with {self._to_class_name(context.api_specification.title)}(config) as client:
        try:
            # Example API call
            result = await client.get_health()
            print("API Status:", result)
            
        except Exception as e:
            print(f"Error: {{e}}")

if __name__ == "__main__":
    asyncio.run(main())
'''

            examples.append(
                GeneratedCode(
                    language=context.target_language,
                    code=example_code,
                    filename="examples/basic_usage.py",
                    dependencies=[],
                    documentation="Basic usage example",
                )
            )

        return examples

    async def _enhance_sdk_with_llm(self, sdk: GeneratedSDK, context: GenerationContext) -> None:
        """Enhance generated SDK with LLM improvements."""
        if not self.llm_service:
            return

        try:
            # Enhance documentation
            for doc_file in sdk.documentation_files:
                if doc_file.filename == "README.md":
                    enhanced_readme = await self._enhance_readme_with_llm(doc_file.code, context)
                    if enhanced_readme:
                        doc_file.code = enhanced_readme

        except Exception as e:
            self.logger.warning(f"LLM enhancement failed: {e}")

    async def _enhance_readme_with_llm(self, readme_content: str, context: GenerationContext) -> Optional[str]:
        """Enhance README with LLM-generated improvements."""
        try:
            prompt = f"""
            Enhance this SDK README file for better clarity and developer experience:
            
            Current README:
            {readme_content[:2000]}  # Limit for context
            
            Improvements needed:
            1. Make the introduction more engaging
            2. Add more detailed usage examples
            3. Improve the structure and formatting
            4. Add common troubleshooting tips
            
            Language: {context.target_language.value}
            API: {context.api_specification.title}
            
            Return only the enhanced README content.
            """

            llm_request = LLMRequest(
                prompt=prompt,
                feature_domain="translation_studio",
                max_tokens=1500,
                temperature=0.3,
            )

            response = await self.llm_service.process_request(llm_request)
            return response.content.strip()

        except Exception:
            return None

    async def _validate_generated_code(self, sdk: GeneratedSDK) -> None:
        """Validate generated code quality and syntax."""
        validation_errors = []

        for code_file in sdk.source_files:
            # Basic syntax validation
            if sdk.language == CodeLanguage.PYTHON:
                try:
                    compile(code_file.code, code_file.filename, "exec")
                except SyntaxError as e:
                    validation_errors.append(f"Syntax error in {code_file.filename}: {e}")

            # Check for common issues
            if len(code_file.code.strip()) == 0:
                validation_errors.append(f"Empty file: {code_file.filename}")

            if "TODO" in code_file.code:
                validation_errors.append(f"TODO items found in {code_file.filename}")

        if validation_errors:
            self.logger.warning(f"Code validation issues: {validation_errors}")

    def _update_generation_metrics(self, success: bool, generation_time: float) -> None:
        """Update generation metrics."""
        self.generation_stats["total_sdks_generated"] += 1

        if success:
            self.generation_stats["successful_generations"] += 1
        else:
            self.generation_stats["failed_generations"] += 1

        # Update average generation time
        total_generated = self.generation_stats["total_sdks_generated"]
        current_avg = self.generation_stats["average_generation_time"]
        self.generation_stats["average_generation_time"] = (
            current_avg * (total_generated - 1) + generation_time
        ) / total_generated

    def _to_class_name(self, name: str) -> str:
        """Convert to class name (PascalCase)."""
        return "".join(word.capitalize() for word in re.split(r"[_\-\s]+", name))

    def _method_name_for_docs(self, endpoint: APIEndpoint, language: CodeLanguage) -> str:
        """Generate method name for documentation."""
        base_name = endpoint.operation_id or f"{endpoint.method}_{endpoint.path.split('/')[-1]}"

        if language == CodeLanguage.PYTHON:
            return re.sub(r"[_\-\s]+", "_", base_name).lower()
        elif language == CodeLanguage.TYPESCRIPT:
            words = re.split(r"[_\-\s]+", base_name)
            return words[0].lower() + "".join(word.capitalize() for word in words[1:])
        else:
            return base_name

    def get_supported_languages(self) -> List[CodeLanguage]:
        """Get list of supported programming languages."""
        return list(self.generators.keys())

    def get_generation_metrics(self) -> Dict[str, Any]:
        """Get code generation metrics."""
        return {
            **self.generation_stats,
            "supported_languages": [lang.value for lang in self.generators.keys()],
            "llm_enhancement_enabled": self.enable_llm_enhancement,
            "code_validation_enabled": self.enable_code_validation,
        }

    async def export_sdk(self, sdk: GeneratedSDK, output_directory: Path, create_package: bool = True) -> Dict[str, Path]:
        """
        Export generated SDK to filesystem.

        Args:
            sdk: Generated SDK to export
            output_directory: Target directory for export
            create_package: Whether to create a distributable package

        Returns:
            Dictionary mapping file types to paths
        """
        try:
            # Create SDK package structure
            file_paths = sdk.generate_package_structure(output_directory)

            self.logger.info(f"SDK exported to {output_directory}: {len(file_paths)} files")

            return file_paths

        except Exception as e:
            raise CodeGenerationException(f"SDK export failed: {e}")
